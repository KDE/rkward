<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1-Based Variant V1.0//EN" "dtd/kdex.dtd" [
  <!ENTITY rkward '<application>RKWard</application>'>
  <!ENTITY kapp "&rkward;"><!-- replace rkward here -->
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE"><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title>Introduction to Writing Plugins for RKWard</title>

<authorgroup>
<author>
<firstname>Thomas</firstname>
<surname>Friedrichsmeier</surname>
<affiliation>
<address><email>tfry AT users DOT sourceforge DOT net</email></address>
</affiliation>
</author>
<!-- Additional authors go here -->
</authorgroup>

<!-- TRANS:ROLES_OF_TRANSLATORS -->

<copyright>
<year>2006</year>
<holder>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice>&FDLNotice;</legalnotice>

<date>2006-03-21</date>
<releaseinfo>0.3.5.00</releaseinfo>

<abstract>
<para>
This is a guide to writing plugins for &rkward;.
</para>
</abstract>

<keywordset>
<keyword>KDE</keyword>
<keyword>R</keyword>
<keyword>rkward</keyword>
<keyword>plugins</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title>Introduction</title>

<para>
Documentation as of &kapp; release 0.3.5.
</para>
<para>
This document describes how to write your own plugins. Note, that at the time of this writing, none of the concepts are set it stone. Therefore, this document should be regarded as an introduction to the current approach, and as a basis for discussion. All sorts of comments are welcome.
</para>
<para>
For questions and comments, please write to the &kapp; development mailing list.
</para>
<para>
<emphasis>You do not need to read this in order to use &kapp;.</emphasis> This document is about extending &kapp;. It is targeted at advanced users, or people willing to help improve &kapp;.
</para>
<para>
Writing a standard plugin is basically a three-step process:
<itemizedlist>
<listitem><link linkend="pluginmap">Placing a new Action in the menu-hierarchy</link></listitem>
<listitem><link linkend="mainxml">Describing the looks and behavior of the plugin-GUI</link></listitem>
<listitem><link linkend="phptemplate">Defining, how R-code is to be generated from the settings, the user makes in the GUI</link></listitem>
</itemizedlist>
Those will be dealt with in turn.
</para>
<para>
Some advanced concepts may be used in those three steps, but are dealt with in separate chapters, to keep things simple:
<itemizedlist>
<listitem><link linkend="logic">GUI logic</link></listitem>
<listitem><link linkend="embedding">Embedding Plugins into Plugins</link></listitem>
</itemizedlist>
</para>
<para>
Also, none of the chapters shows all options, but rather only the basic concepts. A complete <link linkend="reference">reference</link> of options is provided separately.
</para>
</chapter>

<chapter id="whatareplugins">
<title>Preliminaries: What are plugins in &kapp;? How do they work?</title>
<para>
Of course the first question you might have is: What portions of &kapp; functionality is realized using plugins? Or: What can plugins do?
</para>
<para>
One way to answer this is: Deselect all .pluginmap-files under Settings->Configure &kapp;->Plugins, and see what's missing. A slightly more helpful answer: Most acutal statistics functions accessable via the GUI are realized using plugins. Also, you can create fairly flexible GUIs for all kinds of operations using plugins.
</para>
<para>
The basic paradigm behind &kapp; plugins is the one we'll walk you through in this document: An xml-file describes what the GUI looks like. An additional PHP-file is used to generate R syntax from the GUI settings. That is, plugins do not really have to perform any statistical calculations. Rather plugins generate the R syntax needed to run those calculations. The R syntax is then sent to the R backend for evaluation, and typically a result is shown in the output window.
</para>
<para>
Read on in the next chapters to see how this is done.
</para>
</chapter>

<chapter id="pluginmap">
<title>Creating menu entries</title>
<para>
When you create a new plugin, you need to tell &kapp; about it. So the first thing to do, is to write a .pluginmap-file (or modify an existing one). The format of .pluginmap is XML. I'll walk you through an example (also of course, be sure you have &kapp; configured to load your pluginmap â€“ Settings->Configure &kapp;->Plugins):
</para>
<programlisting>
&lt;!DOCTYPE rkpluginmap&gt;
</programlisting>
<para>
The doctype is not really interpreted, but set it to "rkpluginmap" anyway.
</para>
<programlisting>
&lt;document base_prefix="" namespace="rkward"&gt;
</programlisting>
<para>
The "base_prefix"-attribute can be used, if all your plugins reside in a common directory. Basically, then, you can omit that directory from the filenames specified below. As you will see below, all plugins get a unique identifier. The "namespace" is a way to organized those ids, and make it less likely to create a duplicate identifier accidentally. Internally, basically the namespace and then a "::" gets prepended to all the identifiers you specify below.
</para>
<programlisting>
	&lt;components&gt;
</programlisting>
<para>
Components? Aren't we talking about plugins? Yes, but in the future, plugins will be no more than a special class of components. What we do here, then, is to register all components/plugins with &kapp;. Let's look at an example entry:
</para>
<programlisting>
		&lt;component type="standard" id="independent_samples_t_test" file="means/ttests/independent_samples.xml" label="Independent Samples" /&gt;
</programlisting>
<para>
First the "type"-attribute: Leave this to "standard" for now. Further types are not yet implemented. The "id" I've already hinted at. Each component has to be given a unique (in its namespace) identifier. Pick one that is easily recognizable. Avoid spaces and any special characters. Those are not banned, so far, but might have special meanings. With the "file" attribute, you specify where the <link linkend="mainxml">description of the actual plugin itself</link> is located. This is relative to the directory the .pluginmap-file is in, and the "base_prefix" above. Finally, give the component a label. This label will be shown whereever the plugin is placed in the menu (or in the future perhaps in other places as well).
</para>
<para>
Typically a .pluginmap-file will contain several components, so here are a few more:
</para>
<programlisting>
		&lt;component type="standard" id="unimplemented_test" file="means/unimplemented.xml" /&gt;
		&lt;component type="standard" id="fictional_t_test" file="means/ttests/fictional.xml" label="This is a fictional t-test" /&gt;
		&lt;component type="standard" id="descriptive" file="descriptive.xml" label="Descriptive Statistics" /&gt;
		&lt;component type="standard" id="corr_matrix" file="corr_matrix.xml" label="Correlation Matrix" /&gt;
		&lt;component type="standard" id="simple_anova" file="simple_anova.xml" label="Simple Anova" /&gt;
	&lt;/components&gt;
</programlisting>
<para>
Ok, this was the first step. &kapp; now knows those plugins exist. But how to invoke them? They need to be placed in a menu-hierarchy:
</para>
<programlisting>
	&lt;hierarchy&gt;
		&lt;menu id="analysis" label="Analysis" index="4"&gt;
</programlisting>
<para>
Right below the &lt;hierarchy&gt;-tag, you start describing, in which menu, your plugins should go. With the above line, you basically say, that your plugin should be in the "Analysis" menu (not necessarily directly there, but in a submenu). The "Analysis" menu is standard in &kapp;, so it does not acutally have to be created from scratch. However, if it did not exist yet, using the "label"-attribute you'd give it its name. The "index" attribute says, that the menu (if newly created) should be placed at the fourth position in the menubar.
Finally, the "id" once again identifies this menu. This is needed, so several .pluginmap-files can place their plugins in the same menus. They do this by looking for a menu with the given "id". If the id does not yet exist, a new menu will be created. Otherwise the entries will be added to the existing menu.
</para>
<programlisting>
			&lt;menu id="means" label="Means" index="1"&gt;
</programlisting>
<para>
Basically the same thing here: Now we define a submenu to the "Analysis"-menu. It is to be called "Means".
</para>
<programlisting>
				&lt;menu id="ttests" label="T-Tests"&gt;
</programlisting>
<para>
And a final level in the menu-hierarchy: A sub-menu of the sub-menu "Means". Note, that if you omit the "index" parameter, the new entry will be placed below any already existing ones.
</para>
<programlisting>
					&lt;entry component="independent_samples_t_test" /&gt;
</programlisting>
<para>
Now, finally, this is the menu, we want to place the plugin in. The &lt;entry&gt;-tag signals, this actually is the real thing, instead of another submenu. The "component"-attribute refers to the "id" you gave the plugin/component above.
</para>
<programlisting>
					&lt;entry component="fictional_t_test" /&gt;
				&lt;/menu&gt;
				&lt;entry component="fictional_t_test" /&gt;
			&lt;/menu&gt;
			&lt;menu id="frequency" label="Frequency" index="2"/&gt;
</programlisting>
<para>
In case you have lost track: This is another submenu to the "Analysis" menu. See the screenshot below. We'll skip some of what's not visible, marked with [...].
</para>
<programlisting>
				[...]
			&lt;/menu&gt;
			&lt;entry component="corr_matrix" index="4"/&gt;
			&lt;entry component="descriptive" index="3"/&gt;
			&lt;entry component="simple_anova" index="5"/&gt;
		&lt;/menu&gt;
</programlisting>
<para>
These are the final entries visible in the screenshots below. Note, that you don't need to define the entries in the order they should have in the menu. Use the "index"-attribute instead.
</para>
<programlisting>
		&lt;menu id="plots" label="Plots" index="5"&gt;
			[...]
		&lt;/menu&gt;
</programlisting>
<para>
Of course you can also place your plugins in menus other than "Analysis".
</para>
<programlisting>
		&lt;menu id="file" label="File" index="0"&gt;
			[...]
		&lt;/menu&gt;
</programlisting>
<para>
Even in standard-menus such as "File". All you need is the correct "id".
</para>
<programlisting>
	&lt;/hierarchy&gt;	
&lt;/document&gt;
</programlisting>
<para>
That's how to do it. And this screenshot shows the result:
</para>
<screenshot>
<screeninfo>Menu hierarchy created by the code shown above</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Menu hierarchy created by the code shown above</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
<para>
Confused? The easiest way to get started is probably taking some of the existing .plugin_map files shipped with the distribution, and modifying them to your needs. Also, if you need help, don't hesitate to write to the development mailing list.
</para>
</chapter>

<chapter id="mainxml">
<title>Defining the GUI</title>
<para>
In the <link linked="pluginmap">previous chapter</link> you've seen how to register a plugin with &kapp;. The most important ingredient was specifying the path to an XML file with a description of what the plugin actually looks like. In this chapter you'll learn how to create this XML file.
</para>
<para>
Once again we'll walk you through an example. The example is a (slightly simplified) version of the independent samples t-test.
</para>
<programlisting>
&lt;!DOCTYPE rkplugin&gt;
</programlisting>
<para>
The doctype is not really interpreted, yet. Set it to rkplugin, anyway.
</para>
<programlisting>
&lt;document&gt;
	&lt;code file="code.php"/&gt;
</programlisting>
<para>
All plugins generate some code. Currently the only way to do so is using PHP, as detailed in <link linkend="phptemplate">the next chapter</link>. This defines, where to look for the PHP-code. The filname is relative to the directory the plugin-xml is in.
</para>
<programlisting>
	&lt;dialog label="Independent Samples T-Test"&gt;
</programlisting>
<para>
As you know, plugins may have either a dialog or a wizard-interface or both. Here we start definining a dialog-interface. the label-attribute specifies the caption of the dialog.
</para>
<programlisting>
		&lt;tabbook&gt;
			&lt;tab label="Basic settings"&gt;
</programlisting>
<para>
GUI-elements can be organized using a tabbook. Here we define a tabbook as the first element in the dialog. Use &lt;tabbook&gt;[...]&lt;/tabbook&gt; to define the tabbook and then for each page in the tabbook use &lt;tab&gt;[...]&lt;/tab&gt;. The "label"-attribute in the &lt;tab&gt;-element allows you to specify a caption for that page of the tabbook.
</para>
<programlisting>
				&lt;row&gt;
</programlisting>
<para>
The &lt;row&gt; and &lt;column&gt; tags specify the layout of the GUI elements. Here you say, that you'd like to place some elements side-by-side (left to right) and the first of these elements is to be a:
</para>
<programlisting>
					&lt;varselector id="vars"/&gt;
</programlisting>
<para>
Using this simple tag you create a list from which the user can select variables. You have to specify an id for this element, so RKWard knows how to find it. Note that you may NOT use a dot (.) in the "id" string.
</para>
<programlisting>
					&lt;column&gt;
</programlisting>
<para>
Next, we nest a &lt;column&gt; inside the row. I.e. the following elements will be place above each other (top-to-bottom), and all will be to the right of the &lt;varselector&gt;.
</para>
<programlisting>
						&lt;varslot type="numeric" id="x" source="vars" required="true" label="compare"/&gt;
						&lt;varslot type="numeric" id="y" source="vars" required="true" label="against"/&gt;
</programlisting>
<para>
These elements are the counterpart to the &lt;varselector&gt;. They represent "slots" into which the user can put variables. You will note that the "source" is set to the same value as the "id" of the &lt;varselector&gt;. This means, the &lt;varslot&gt;s will each take their variables from the varselector. The &lt;varslot&gt;s also have to be given an "id". They may have a label, and they may be set to "required". This means that the submit-button will not be enabled until the &lt;varslot&gt; holds a valid value. Finally the "type"-attribute is not interpreted, yet, but it will be used to take care that only the correct types of variables will be allowed in the &lt;varslot&gt;.
</para>
<programlisting>
						&lt;radio id="hypothesis" label="using test hypothesis"&gt;
							&lt;option value="two.sided" label="Two-sided"/&gt;
							&lt;option value="greater" label="First is greater"/&gt;
							&lt;option value="less" label="Second is greater"/&gt;
						&lt;/radio&gt;
</programlisting>
<para>
Here, you define a group of &lt;radio&gt;-exclusive buttons. The group has a "label" and an "id". Each &lt;option&gt; (button) has a label and is assigned a value. This is the value the &lt;radio&gt;-element will return when the option is selected.
</para>
<programlisting>
					&lt;/column&gt;
				&lt;/row&gt;
			&lt;/tab&gt;
</programlisting>
<para>
Each tag has to be closed. We've put all the elements we wanted (the two &lt;varslots&gt; and the &lt;radio&gt;) in the &lt;column&gt;. We put all elements we wanted (the &lt;varselector&gt; and the &lt;column&gt; with those elements) in the &lt;row&gt;. And we've put all the elements we wanted into the first page in the &lt;tabbook&gt;. We're not yet done defining the &lt;tabbook&gt; (more pages to come) and of course there's more to come in the &lt;dialog&gt;, too. But this screenshot is basically what we've done so far:
</para>
<screenshot>
<screeninfo>T test plugin</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="t_test_plugin_example.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>T test plugin</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
<para>
Note that we have not specified the "Submit", "Close", etc. buttons or the code-view. Those elements get generated automatically. But of course we still have to define the second page of the &lt;tabbook&gt;:
</para>
<programlisting>
			&lt;tab label="Options"&gt;
				&lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
</programlisting>
<para>
By default elements will be placed top-to-bottom like in a &lt;column&gt;. Since that is what we want here, we don't have to explicitly state a &lt;row&gt; or &lt;column&gt;-layout. The first element we define is a checkbox. Just like the &lt;radio&gt;&lt;option&gt;s, the checkbox has a "label" and a "value". The "value" is what gets returned, if the checkbox is checked. Of course the checkbox also needs an "id".
</para>
<programlisting>
				&lt;frame label="Confidence Interval"&gt;
</programlisting>
<para>
Here's yet another layout-element: In order to signal that the two elements below  belong together, we draw a &lt;frame&gt; (box). That frame may have a caption. Since the frame is just a passive layout-element, it does not need an "id".
</para>
<programlisting>
					&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
					&lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
				&lt;/frame&gt;
</programlisting>
<para>
Inside the &lt;frame&gt; we place another &lt;checkbox&gt; (using checked="true", we signal that checkbox should be checked by default), and a &lt;spinbox&gt;. The spinbox allows the user to select a value between "min" and "max" with the default/initial value "0.95". Setting the "type" to "real" signals that real numbers are accepted as opposed to type="integer" which would accept integers only.
</para>
<programlisting>
			&lt;/tab&gt;
		&lt;/tabbook&gt;
	&lt;/dialog&gt;
</programlisting>
<para>
That all for the second page of the &lt;tabbook&gt;, all pages in the &lt;tabbook&gt; and all elements in the &lt;dialog&gt;. We're finished defining what the dialog looks like. Actually we don't have to define an additional &lt;wizard&gt;-interface, but here's how that would be done. Things should be fairly self-explanatory be now, so I leave that part without comments:
</para>
<programlisting>
	&lt;wizard label="Independent Samples T-Test"&gt;
		&lt;page id="firstpage"&gt;
			&lt;text&gt;As a first step, select the two variables you want to compare against each other. And specify, which one you theorize to be greater. Select two-sided, if your theory does not tell you, which variable is greater.&lt;/text&gt;
			&lt;row&gt;
				&lt;column&gt;
					&lt;varselector id="vars"/&gt;
				&lt;/column&gt;
				&lt;column&gt;
					&lt;varslot type="numeric" id="x" source="vars" required="true" label="compare"/&gt;
					&lt;varslot type="numeric" id="y" source="vars" required="true" label="against"/&gt;
					&lt;radio id="hypothesis" label="using test hypothesis"&gt;
						&lt;option value="two.sided" label="Two-sided"/&gt;
						&lt;option value="greater" label="First is greater"/&gt;
						&lt;option value="less" label="Second is greater"/&gt;
					&lt;/radio&gt;
				&lt;/column&gt;
			&lt;/row&gt;
		&lt;/page&gt;
		&lt;page id="secondpage"&gt;
			&lt;text&gt;Below are some advanced options. It's generally safe not to assume the variables have equal variances. An appropriate correction will be applied then. Chosing "assume equal variances" may increase test-strength, however.&lt;/text&gt;
			&lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
			&lt;text&gt;Sometimes it's helpful to get an estimate of the confidence interval of the difference in means. Below you can specify whether one should be shown, and which confidence-level should be applied (95% corresponds to a 5% level of significance).&lt;/text&gt;
			&lt;frame label="Confidence Interval"&gt;
				&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
				&lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
			&lt;/frame&gt;
		&lt;/page&gt;
	&lt;/wizard&gt;
</programlisting>
<para>
As you see, all of this is mostly a duplication of what has been defined for the dialog-interface. You may of course make the wizard-interface look very different to the plain dialog. Be sure, however, to assign corresponding elements the same "id" in both interfaces. This is not only used to transfer settings from the dialog-interface to the wizard-interface and back, when the user switches interfaces (which does not yet happen in the current version of RKWard), but also simplifies writing your code-template (see below). 
</para>
<programlisting>
&lt;/document&gt;
</programlisting>
<para>
Finally we close the &lt;document&gt;-tag, and that's it. The GUI is defined. You can save the file now. But how does R-syntax get generated from the GUI-settings? I'll deal with that next.
</para>
</chapter>

<chapter id="phptemplate">
<title>Generating R code from GUI settings</title>
<para>
Now we have a GUI defined, but we still need to generate some R-code from that. For that, we need another text-file, "code.php", located in the same directory as the <link linkend="mainxml">description.xml</link>. You may or may not be familiar with PHP. Documentation on PHP can be found here: http://www.php.net. But for most purposes you will not need to know much about PHP at all, as we'll only use some very basic features..
</para>
<para>
For the independent samples t-test, the code.php file looks as follows (with comments in between):
</para>
<programlisting>
&lt;?
</programlisting>
<para>
This is a sort of opening tag in PHP. Everything between &lt;? and ?&gt; will be interpreted as PHP-code. Everything outside of these tags will simply be returned as plain text. See below for examples.
</para>
<programlisting>
	function preprocess () {
	}
</programlisting>
<para>
The PHP-file is organized into four separate functions: preprocess, calculate, printout and cleanup. This is because not all code is needed at all stages. Currently the preprocess-function is not really used.
</para>
<programlisting>
	function calculate () {
?&gt;rk.temp &lt;- t.test (&lt;? getRK ("x"); ?&gt;, &lt;? getRK ("y"); ?&gt;, "&lt;? getRK ("hypothesis"); ?&gt;"&lt;? getRK ("varequal"); if (($conflevel = getRK_val ("conflevel")) != "0.95") echo (", conf.level=" . $conflevel); ?&gt;)
&lt;?
	}
</programlisting>
<para>
This function generates the actual R-syntax to be run from the GUI-settings. Let's look at this in detail:
First we leave the PHP-mode (?&gt;) and hence return
</para>
<screen>
rk.temp &lt;- t.test (
</screen>
<para>
as plain text. Next we need to fill in the value, the user selected as the first variable. Hence we enter PHP-mode again (&lt;?) and call 'getRK ("x");'. This prints out the value of the GUI-element with id "x": our first &lt;varslot&gt;. Next we leave PHP-mode again, print a ', ', and do the same to fetch the value of the element "y" - the second &lt;varslot&gt;. For the hypothesis (the &lt;radio&gt;-group), and the equal variances-&lt;checkbox&gt;, the procedure is very similar.
</para>
<para>
It gets a little more tricky for the confidence level. For reasons of aestethics, we don't want to explicitly specify the confidence level to use, if it corresponds to the default value. Hence, instead of printing the value with 'getRK', we fetch it silently using 'getRK_val' and assign it to a PHP-variable. We then check, whether that variable differs from "0.95" and if so print out an additional argument.
Finally, we leave PHP-mode again, print a last ')', and that's it for the calculate-function.
</para>
<programlisting>
	function printout () {
?&gt;rk.print (rk.temp);
&lt;?
	}
</programlisting>
<para>
And this was all there is to the printout function in most cases. rk.print utilizes the R2HTML package to provide HTML formatted output. You could also excert greater control over the generated output. For this, you'll generate an R syntax, that consists esp. of "cat ()" commands, piecing together an HTML output. If in doubt, just use rk.print (), and be done with.
</para>
<para>
Note: At the time of this writing, I plan to add an rk.print.header () function to print out some information about what kind of analysis was done, when, what parameters, etc. Check back with this document, soon.
</para>
<programlisting>
	function cleanup () {
?&gt;rm (rk.temp)
&lt;?
	}
?&gt;
</programlisting>
<para>
Finally, in the function cleanup we discard the temporary object(s) we left in the R-workspace. You should always clean up all objects created while running the plugin, except if the user explicitely requested otherwise.
</para>
<para>
Congratulations! You created your first plugin. Read on in the next chapters for more advanced concepts
</para>
</chapter>

<chapter id="logic">
<title>GUI logic</title>
<para>
All the basic concepts of creating a plugin for &kapp; have been described in the previous chapters. Those basic concepts should be sufficient for many - if not most - cases. However, sometimes you want more control over how your plugin's GUI behaves.
</para>
<para>
For instance, suppose you want to extend the t-test example used in this documentation to allow both: comparing a variable against another variable (as shown), and comparing a variable against a constant value. Now, one way of doing this would be to add a radio-control that switches between the two modes, and adding a spinbox to enter the constant value to compare against. Consider this simplified example:
</para>
<programlisting>
&lt;!DOCTYPE rkplugin&gt;
&lt;document&gt;
	&lt;code file="code.php"/&gt;

	&lt;dialog label="T-Test"&gt;
		&lt;row&gt;
			&lt;varselector id="vars"/&gt;
			&lt;column&gt;
				&lt;varslot id="x" type="numeric" source="vars" required="true" label="compare"/&gt;
				&lt;radio id="mode" label="Compare against"&gt;
					&lt;option value="variable" checked="true" label="another variable (select below)"/&gt;
					&lt;option value="constant" label="a constant value (set below)"/&gt;
				&lt;/radio&gt;
				&lt;varslot id="y" type="numeric" source="vars" required="true" label="variable"/&gt;
				&lt;spinbox id="constant" initial="0" label="constant" /&gt;
			&lt;/column&gt;
		&lt;/row&gt;
	&lt;/dialog&gt;
&lt;/document&gt;
</programlisting>
<para>
So far so good, but there are a number of problems with this GUI. First, both the varslot and the spinbox are always shown, whereas only one of the two is really used. Worse, the varslot always requires a valid selection, even if you compare against a constant. Obviously, if we create a multi-purpose GUI like this, we want more flexibility. Enter: the &lt;logic&gt;-section (inserted at the same level as &lt;code&gt;, &lt;dialog&gt;, or &lt;wizard&gt;).
</para>
<para>
<programlisting>
	[...]
	&lt;code file="code.php"/&gt;

	&lt;logic&gt;
		&lt;convert id="varmode" mode="equals" sources="mode.string" standard="variable" /&gt;
		&lt;convert id="constmode" mode="equals" sources="mode.string" standard="constant" /&gt;

		&lt;connect client="y.required" governor="varmode" /&gt;
		&lt;connect client="y.visible" governor="varmode" /&gt;

		&lt;connect client="constant.required" governor="constmode" /&gt;
		&lt;connect client="constant.visible" governor="constmode" /&gt;
	&lt;/logic&gt;

	&lt;dialog label="T-Test"&gt;
	[...]
</programlisting>
</para>
<para>
The first two lines inside the logic section are &lt;conver&gt; tags. Those basically provide two new boolean (on or off, true or false) properties, which can be used later on. The first property ("varmode") is true, whenever the upper radio-button is selected and the second whenever the lower radio-button is selected. How is this done?
</para>
<para>
First, under sources, the "source" properties to work on are listed (in this case only one each; you could list several as sources="mode.string;somethingelse", then varmode would only be true, if both mode.string and somethingelse are equal to the string "variable"). Note that in this case we don't just write "mode" (as we would in getRK("mode"), but "mode.string". This is actually the internal way a radio control works: It has a property "string", which holds its string value. getRK ("mode") is just a shorthand, and equivalent to getRK ("mode.string"). See the reference for all properties of the different GUI elements.
</para>
<para>
Second, we set the mode of conversion to mode="equals". This means, we want to check, whether the sources are equal to a certain value. Finally standard is the value to compare against, so with standard="variable", we check whether the property mode.string is equal to the string "variable" (the value of the upper radio option). If it is equal, then the property varmode is true, else it is false.
</para>
<para>
The next line is basically the same, but reversed. Here we define a property ("constmode") which becomes true, if the second radio option is selected.
</para>
<para>
Now to the real stuff: We &lt;connect&gt; the "varmode" property to two different properties. Firstly, to y.required. This specifies, whether the varslot "y" is required or not. Secondly, to y.visible, which controls whether the varslot "y" is shown or not. Hence, if the upper radio-option is selected, the varslot "y" is required, and visible. Else it is not required and hidden.
</para>
<para>
We do just the reverse for the spinbox. So in effect, either the varslot is shown and required, <emphasis>or</emphasis> the spinbox is shown and required - depending on which option is selected in the radio control. The GUI is changing itself according to the radio option. Try the example, if you like.
</para>
<para>
Once again, for a complete list of properties, refer to the <link linkend="reference">reference</link>. One more property, however, is special in that all GUI elements have it: "enabled". This is slightly less drastic that "visible". It does not show/hide the GUI element, but only enables/disables it. Disabled elements are typically shown grayed out, and do not react to user input.
</para>
</chapter>

<chapter id="embedding">
<title>Embedding Plugins into Plugins</title>
<para>
When writing plugins, you will often find that you're creating a number of plugins that only differ in some respects, but have a lot more in common. For instance, for plotting, there are a number of generic R options that can be used with mostly all types of plots. Should you create a GUI and PHP-template for those over and over again?
</para>
<para>
Obviously that would be quite a hassle. Fortunately, you don't have to do that. Rather you create the common functionality once, and later you can embed it into several plugins. In fact it is possible to embed any plugin into any other plugin, even if the original author of the embedded plugin never thought, somebody would want to embed their plugin into another one.
</para>
<section id="embedding_dialog">
<title>Embedding inside a dialog</title>
<para>
Ok, enough said. How does it work? Simple: Just use the &lt;embed&gt; tag. Here's a stripped down example:
</para>
<programlisting>
&lt;dialog&gt;
	&lt;tabbook&gt;
		&lt;tab [...]&gt;
			[...]
		&lt;/tab&gt;
		&lt;tab label="Plot Options"&gt;
			&lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
		&lt;/tab&gt;
		&lt;tab [...]&gt;
			[...]
		&lt;/tab&gt;
	&lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
<para>
What happens here, is that the entire GUI or the plot options plugin (except of course for the standard elements like submit-button, etc.) is embedded right into your plugin (try it!).
</para>
<para>
As you can see the syntax of the &lt;embed&gt;-tag is fairly simple. It takes an id as most elements. The parameter component specifies which plugin to embed, as defined in the <link linkend="pluginmap">.pluginmap</link> file ("rkward::plot_options" is the result of concatenating the namespace "rkward", a separator "::", and the name of the component "plot_options").
</para>
</section>
<section id="embedding_code">
<title>Code generation when embedding</title>
<para>
So far so good, but what about the generated code? How are the code for the embedding and embedded plugin merged? In the embedding plugin's PHP-code, simply write something like this:
</para>
<programlisting>
function printout () {
[...] ?&gt;
myplotfunction ([...]<? getRK ("plotoptions.code.printout"); ?>)
&lt;? [...]
}
</programlisting>
<para>
So essentially, we're fetching the code generated by the embedded plugin just like we're fetchting any other GUI setting. Here the string "plotoptions.code.printout" can be deparsed to: "The printout section of the generated code of the element with the id plotoptions" (plotoptions is the id we gave for the &lt;embed&gt;-tag above). And yes, if you want advanced control, you can even fetch the values of individual GUI elements inside the embedded plugin (but not the other way around, as the embedded plugin does not know anything about its surroundings).
</para>
</section>
<section id="embedding_wizard">
<title>Embedding inside a wizard</title>
<para>
If your plugin provides a wizard GUI, embedding works basically in the same way. You'll generally use:
</para>
<programlisting>
	&lt;wizard [...]&gt;
		[...]
		&lt;page id="page12"&gt;
			[...]
		&lt;/page&gt;
		&lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
		&lt;page id="page13"&gt;
			[...]
		&lt;/page&gt;
		[...]
	&lt;/wizard&gt;
</programlisting>
<para>
If the embedded plugin provides a wizard interface, its pages will be inserted right between page12 and page13 of your plugin. If the embedded plugin provides a dialog interface only, a single new page will be added between your pages page12 and page13. The user will never notice.
</para>
</section>
<section id="embedding_as_button">
<title>Less embedded embedding: Further options button</title>
<para>
While embedding is cool, you should be careful not to overdo it. To many functions inside a GUI just make it hard to find the relevant options. Of course, sometimes you may want to embed a great deal of options (like all the options to plot ()), but as those are really optional, you don't want them prominently in your GUI.
</para>
<para>
An alternative is to embed those options "as a button":
</para>
<programlisting>
&lt;dialog&gt;
	&lt;tabbook&gt;
		[...]
		&lt;tab label="Options"&gt;
			[...]
			&lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Specify plotting options"/&gt;
		&lt;/tab&gt;
		[...]
	&lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
<para>
In this case, a single push button will be added to your plugin, labelled "Specify plotting options". When you press that button, a separate dialog will come up, with all the options of the embedded plugin. Even while this embedded GUI is not visible most of the time, you can fetch its settings just as described <link linkend="embedding_code">above</link>.
</para>
<para>
<emphasis>Caution:</emphasis> Probably the "button" approach should only ever be used for plugins that can never be invalid (for missing/bad settings). Otherwise the user would not be able to submit the code, but might have a hard time finding out, the reason for that is hidden behind some button.
</para>
</section>
<section id="embedding_incomplete">
<title>Embedding/defining incomplete plugins</title>
<para>
Some plugins - and as a matter of fact, the plot_options used as an example above, is one of them - are not complete by themselves. They simply do not have the GUI elements to select some important values. They are meant to be used only embedded into other plugins.
</para>
</section>
</chapter>

<appendix id="reference">
<title>Reference</title>
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
