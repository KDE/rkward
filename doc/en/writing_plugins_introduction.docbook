<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1-Based Variant V1.0//EN" "dtd/kdex.dtd" [
  <!ENTITY rkward '<application>RKWard</application>'>
  <!ENTITY kapp "&rkward;"><!-- replace rkward here -->
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE"><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title>Introduction to Writing Plugins for RKWard</title>

<authorgroup>
<author>
<firstname>Thomas</firstname>
<surname>Friedrichsmeier</surname>
<affiliation>
<address><email>tfry AT users DOT sourceforge DOT net</email></address>
</affiliation>
</author>
</authorgroup>

<!-- TRANS:ROLES_OF_TRANSLATORS -->

<copyright>
<year>2006</year>
<holder>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice>&FDLNotice;</legalnotice>

<date>2006-03-21</date>
<releaseinfo>0.3.5.00</releaseinfo>

<abstract>
<para>
This is a guide to writing plugins for &rkward;.
</para>
</abstract>

<keywordset>
<keyword>KDE</keyword>
<keyword>R</keyword>
<keyword>rkward</keyword>
<keyword>plugins</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title>Introduction</title>

<para>
Documentation as of &kapp; release 0.3.5.
</para>
<para>
This document describes how to write your own plugins. Note, that at the time of this writing, none of the concepts are set it stone. Therefore, this document should be regarded as an introduction to the current approach, and as a basis for discussion. All sorts of comments are welcome.
</para>
<para>
For questions and comments, please write to the &kapp; development mailing list.
</para>
<para>
<emphasis>You do not need to read this in order to use &kapp;.</emphasis> This document is about extending &kapp;. It is targeted at advanced users, or people willing to help improve &kapp;.
</para>
<para>
Writing a standard plugin is basically a three-step process:
<itemizedlist>
<listitem><link linkend="pluginmap">Placing a new Action in the menu-hierarchy</link></listitem>
<listitem><link linkend="mainxml">Describing the looks and behavior of the plugin-GUI</link></listitem>
<listitem><link linkend="phptemplate">Defining, how R-code is to be generated from the settings, the user makes in the GUI</link></listitem>
</itemizedlist>
Those will be dealt with in turn.
</para>
<para>
Some advanced concepts may be used in those three steps, but are dealt with in separate chapters, to keep things simple:
<itemizedlist>
<listitem><link linkend="logic">GUI logic</link></listitem>
<listitem><link linkend="embedding">Embedding Plugins into Plugins</link></listitem>
</itemizedlist>
</para>
<para>
Also, none of the chapters shows all options, but rather only the basic concepts. A complete <link linkend="reference">reference</link> of options is provided separately.
</para>
</chapter>

<chapter id="whatareplugins">
<title>Preliminaries: What are plugins in &kapp;? How do they work?</title>
<para>
Of course the first question you might have is: What portions of &kapp; functionality is realized using plugins? Or: What can plugins do?
</para>
<para>
One way to answer this is: Deselect all .pluginmap-files under Settings->Configure &kapp;->Plugins, and see what's missing. A slightly more helpful answer: Most acutal statistics functions accessable via the GUI are realized using plugins. Also, you can create fairly flexible GUIs for all kinds of operations using plugins.
</para>
<para>
The basic paradigm behind &kapp; plugins is the one we'll walk you through in this document: An xml-file describes what the GUI looks like. An additional PHP-file is used to generate R syntax from the GUI settings. That is, plugins do not really have to perform any statistical calculations. Rather plugins generate the R syntax needed to run those calculations. The R syntax is then sent to the R backend for evaluation, and typically a result is shown in the output window.
</para>
<para>
Read on in the next chapters to see how this is done.
</para>
</chapter>

<chapter id="pluginmap">
<title>Creating menu entries</title>
<para>
When you create a new plugin, you need to tell &kapp; about it. So the first thing to do, is to write a .pluginmap-file (or modify an existing one). The format of .pluginmap is XML. I'll walk you through an example (also of course, be sure you have &kapp; configured to load your pluginmap â€“ Settings->Configure &kapp;->Plugins):
</para>
<programlisting>
&lt;!DOCTYPE rkpluginmap&gt;
</programlisting>
<para>
The doctype is not really interpreted, but set it to "rkpluginmap" anyway.
</para>
<programlisting>
&lt;document base_prefix="" namespace="rkward"&gt;
</programlisting>
<para>
The "base_prefix"-attribute can be used, if all your plugins reside in a common directory. Basically, then, you can omit that directory from the filenames specified below. As you will see below, all plugins get a unique identifier. The "namespace" is a way to organized those ids, and make it less likely to create a duplicate identifier accidentally. Internally, basically the namespace and then a "::" gets prepended to all the identifiers you specify below.
</para>
<programlisting>
	&lt;components&gt;
</programlisting>
<para>
Components? Aren't we talking about plugins? Yes, but in the future, plugins will be no more than a special class of components. What we do here, then, is to register all components/plugins with &kapp;. Let's look at an example entry:
</para>
<programlisting>
		&lt;component type="standard" id="independent_samples_t_test" file="means/ttests/independent_samples.xml" label="Independent Samples" /&gt;
</programlisting>
<para>
First the "type"-attribute: Leave this to "standard" for now. Further types are not yet implemented. The "id" I've already hinted at. Each component has to be given a unique (in its namespace) identifier. Pick one that is easily recognizable. Avoid spaces and any special characters. Those are not banned, so far, but might have special meanings. With the "file" attribute, you specify where the <link linkend="mainxml">description of the actual plugin itself</link> is located. This is relative to the directory the .pluginmap-file is in, and the "base_prefix" above. Finally, give the component a label. This label will be shown whereever the plugin is placed in the menu (or in the future perhaps in other places as well).
</para>
<para>
Typically a .pluginmap-file will contain several components, so here are a few more:
</para>
<programlisting>
		&lt;component type="standard" id="unimplemented_test" file="means/unimplemented.xml" /&gt;
		&lt;component type="standard" id="fictional_t_test" file="means/ttests/fictional.xml" label="This is a fictional t-test" /&gt;
		&lt;component type="standard" id="descriptive" file="descriptive.xml" label="Descriptive Statistics" /&gt;
		&lt;component type="standard" id="corr_matrix" file="corr_matrix.xml" label="Correlation Matrix" /&gt;
		&lt;component type="standard" id="simple_anova" file="simple_anova.xml" label="Simple Anova" /&gt;
	&lt;/components&gt;
</programlisting>
<para>
Ok, this was the first step. &kapp; now knows those plugins exist. But how to invoke them? They need to be placed in a menu-hierarchy:
</para>
<programlisting>
	&lt;hierarchy&gt;
		&lt;menu id="analysis" label="Analysis" index="4"&gt;
</programlisting>
<para>
Right below the &lt;hierarchy&gt;-tag, you start describing, in which menu, your plugins should go. With the above line, you basically say, that your plugin should be in the "Analysis" menu (not necessarily directly there, but in a submenu). The "Analysis" menu is standard in &kapp;, so it does not acutally have to be created from scratch. However, if it did not exist yet, using the "label"-attribute you'd give it its name. The "index" attribute says, that the menu (if newly created) should be placed at the fourth position in the menubar.
Finally, the "id" once again identifies this menu. This is needed, so several .pluginmap-files can place their plugins in the same menus. They do this by looking for a menu with the given "id". If the id does not yet exist, a new menu will be created. Otherwise the entries will be added to the existing menu.
</para>
<programlisting>
			&lt;menu id="means" label="Means" index="1"&gt;
</programlisting>
<para>
Basically the same thing here: Now we define a submenu to the "Analysis"-menu. It is to be called "Means".
</para>
<programlisting>
				&lt;menu id="ttests" label="T-Tests"&gt;
</programlisting>
<para>
And a final level in the menu-hierarchy: A sub-menu of the sub-menu "Means". Note, that if you omit the "index" parameter, the new entry will be placed below any already existing ones.
</para>
<programlisting>
					&lt;entry component="independent_samples_t_test" /&gt;
</programlisting>
<para>
Now, finally, this is the menu, we want to place the plugin in. The &lt;entry&gt;-tag signals, this actually is the real thing, instead of another submenu. The "component"-attribute refers to the "id" you gave the plugin/component above.
</para>
<programlisting>
					&lt;entry component="fictional_t_test" /&gt;
				&lt;/menu&gt;
				&lt;entry component="fictional_t_test" /&gt;
			&lt;/menu&gt;
			&lt;menu id="frequency" label="Frequency" index="2"/&gt;
</programlisting>
<para>
In case you have lost track: This is another submenu to the "Analysis" menu. See the screenshot below. We'll skip some of what's not visible, marked with [...].
</para>
<programlisting>
				[...]
			&lt;/menu&gt;
			&lt;entry component="corr_matrix" index="4"/&gt;
			&lt;entry component="descriptive" index="3"/&gt;
			&lt;entry component="simple_anova" index="5"/&gt;
		&lt;/menu&gt;
</programlisting>
<para>
These are the final entries visible in the screenshots below. Note, that you don't need to define the entries in the order they should have in the menu. Use the "index"-attribute instead.
</para>
<programlisting>
		&lt;menu id="plots" label="Plots" index="5"&gt;
			[...]
		&lt;/menu&gt;
</programlisting>
<para>
Of course you can also place your plugins in menus other than "Analysis".
</para>
<programlisting>
		&lt;menu id="file" label="File" index="0"&gt;
			[...]
		&lt;/menu&gt;
</programlisting>
<para>
Even in standard-menus such as "File". All you need is the correct "id".
</para>
<programlisting>
	&lt;/hierarchy&gt;	
&lt;/document&gt;
</programlisting>
<para>
That's how to do it. And this screenshot shows the result:
</para>
<screenshot>
<screeninfo>Menu hierarchy created by the code shown above</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>Menu hierarchy created by the code shown above</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
<para>
Confused? The easiest way to get started is probably taking some of the existing .plugin_map files shipped with the distribution, and modifying them to your needs. Also, if you need help, don't hesitate to write to the development mailing list.
</para>
</chapter>

<chapter id="mainxml">
<title>Defining the GUI</title>
<para>
In the <link linked="pluginmap">previous chapter</link> you've seen how to register a plugin with &kapp;. The most important ingredient was specifying the path to an XML file with a description of what the plugin actually looks like. In this chapter you'll learn how to create this XML file.
</para>
<para>
Once again we'll walk you through an example. The example is a (slightly simplified) version of the independent samples t-test.
</para>
<programlisting>
&lt;!DOCTYPE rkplugin&gt;
</programlisting>
<para>
The doctype is not really interpreted, yet. Set it to rkplugin, anyway.
</para>
<programlisting>
&lt;document&gt;
	&lt;code file="code.php"/&gt;
</programlisting>
<para>
All plugins generate some code. Currently the only way to do so is using PHP, as detailed in <link linkend="phptemplate">the next chapter</link>. This defines, where to look for the PHP-code. The filname is relative to the directory the plugin-xml is in.
</para>
<programlisting>
	&lt;dialog label="Independent Samples T-Test"&gt;
</programlisting>
<para>
As you know, plugins may have either a dialog or a wizard-interface or both. Here we start definining a dialog-interface. the label-attribute specifies the caption of the dialog.
</para>
<programlisting>
		&lt;tabbook&gt;
			&lt;tab label="Basic settings"&gt;
</programlisting>
<para>
GUI-elements can be organized using a tabbook. Here we define a tabbook as the first element in the dialog. Use &lt;tabbook&gt;[...]&lt;/tabbook&gt; to define the tabbook and then for each page in the tabbook use &lt;tab&gt;[...]&lt;/tab&gt;. The "label"-attribute in the &lt;tab&gt;-element allows you to specify a caption for that page of the tabbook.
</para>
<programlisting>
				&lt;row&gt;
</programlisting>
<para>
The &lt;row&gt; and &lt;column&gt; tags specify the layout of the GUI elements. Here you say, that you'd like to place some elements side-by-side (left to right) and the first of these elements is to be a:
</para>
<programlisting>
					&lt;varselector id="vars"/&gt;
</programlisting>
<para>
Using this simple tag you create a list from which the user can select variables. You have to specify an id for this element, so RKWard knows how to find it. Note that you may NOT use a dot (.) in the "id" string.
</para>
<programlisting>
					&lt;column&gt;
</programlisting>
<para>
Next, we nest a &lt;column&gt; inside the row. I.e. the following elements will be place above each other (top-to-bottom), and all will be to the right of the &lt;varselector&gt;.
</para>
<programlisting>
						&lt;varslot type="numeric" id="x" source="vars" required="true" label="compare"/&gt;
						&lt;varslot type="numeric" id="y" source="vars" required="true" label="against"/&gt;
</programlisting>
<para>
These elements are the counterpart to the &lt;varselector&gt;. They represent "slots" into which the user can put variables. You will note that the "source" is set to the same value as the "id" of the &lt;varselector&gt;. This means, the &lt;varslot&gt;s will each take their variables from the varselector. The &lt;varslot&gt;s also have to be given an "id". They may have a label, and they may be set to "required". This means that the submit-button will not be enabled until the &lt;varslot&gt; holds a valid value. Finally the "type"-attribute is not interpreted, yet, but it will be used to take care that only the correct types of variables will be allowed in the &lt;varslot&gt;.
</para>
<programlisting>
						&lt;radio id="hypothesis" label="using test hypothesis"&gt;
							&lt;option value="two.sided" label="Two-sided"/&gt;
							&lt;option value="greater" label="First is greater"/&gt;
							&lt;option value="less" label="Second is greater"/&gt;
						&lt;/radio&gt;
</programlisting>
<para>
Here, you define a group of &lt;radio&gt;-exclusive buttons. The group has a "label" and an "id". Each &lt;option&gt; (button) has a label and is assigned a value. This is the value the &lt;radio&gt;-element will return when the option is selected.
</para>
<programlisting>
					&lt;/column&gt;
				&lt;/row&gt;
			&lt;/tab&gt;
</programlisting>
<para>
Each tag has to be closed. We've put all the elements we wanted (the two &lt;varslots&gt; and the &lt;radio&gt;) in the &lt;column&gt;. We put all elements we wanted (the &lt;varselector&gt; and the &lt;column&gt; with those elements) in the &lt;row&gt;. And we've put all the elements we wanted into the first page in the &lt;tabbook&gt;. We're not yet done defining the &lt;tabbook&gt; (more pages to come) and of course there's more to come in the &lt;dialog&gt;, too. But this screenshot is basically what we've done so far:
</para>
<screenshot>
<screeninfo>T test plugin</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="t_test_plugin_example.png" format="PNG"/>
	  </imageobject>
	  <textobject>
	    <phrase>T test plugin</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
<para>
Note that we have not specified the "Submit", "Close", etc. buttons or the code-view. Those elements get generated automatically. But of course we still have to define the second page of the &lt;tabbook&gt;:
</para>
<programlisting>
			&lt;tab label="Options"&gt;
				&lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
</programlisting>
<para>
By default elements will be placed top-to-bottom like in a &lt;column&gt;. Since that is what we want here, we don't have to explicitly state a &lt;row&gt; or &lt;column&gt;-layout. The first element we define is a checkbox. Just like the &lt;radio&gt;&lt;option&gt;s, the checkbox has a "label" and a "value". The "value" is what gets returned, if the checkbox is checked. Of course the checkbox also needs an "id".
</para>
<programlisting>
				&lt;frame label="Confidence Interval"&gt;
</programlisting>
<para>
Here's yet another layout-element: In order to signal that the two elements below  belong together, we draw a &lt;frame&gt; (box). That frame may have a caption. Since the frame is just a passive layout-element, it does not need an "id".
</para>
<programlisting>
					&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
					&lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
				&lt;/frame&gt;
</programlisting>
<para>
Inside the &lt;frame&gt; we place another &lt;checkbox&gt; (using checked="true", we signal that checkbox should be checked by default), and a &lt;spinbox&gt;. The spinbox allows the user to select a value between "min" and "max" with the default/initial value "0.95". Setting the "type" to "real" signals that real number are accepted as opposed to type="integer" which would accept integers only.
</para>
<programlisting>
			&lt;/tab&gt;
		&lt;/tabbook&gt;
	&lt;/dialog&gt;
</programlisting>
<para>
That all for the second page of the &lt;tabbook&gt;, all pages in the &lt;tabbook&gt; and all elements in the &lt;dialog&gt;. We're finished defining what the dialog looks like. Actually we don't have to define an additional &lt;wizard&gt;-interface, but here's how that would be done. Things should be fairly self-explanatory be now, so I leave that part without comments:
</para>
<programlisting>
	&lt;wizard label="Independent Samples T-Test"&gt;
		&lt;page id="firstpage"&gt;
			&lt;text&gt;As a first step, select the two variables you want to compare against each other. And specify, which one you theorize to be greater. Select two-sided, if your theory does not tell you, which variable is greater.&lt;/text&gt;
			&lt;row&gt;
				&lt;column&gt;
					&lt;varselector id="vars"/&gt;
				&lt;/column&gt;
				&lt;column&gt;
					&lt;varslot type="numeric" id="x" source="vars" required="true" label="compare"/&gt;
					&lt;varslot type="numeric" id="y" source="vars" required="true" label="against"/&gt;
					&lt;radio id="hypothesis" label="using test hypothesis"&gt;
						&lt;option value="two.sided" label="Two-sided"/&gt;
						&lt;option value="greater" label="First is greater"/&gt;
						&lt;option value="less" label="Second is greater"/&gt;
					&lt;/radio&gt;
				&lt;/column&gt;
			&lt;/row&gt;
		&lt;/page&gt;
		&lt;page id="secondpage"&gt;
			&lt;text&gt;Below are some advanced options. It's generally safe not to assume the variables have equal variances. An appropriate correction will be applied then. Chosing "assume equal variances" may increase test-strength, however.&lt;/text&gt;
			&lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
			&lt;text&gt;Sometimes it's helpful to get an estimate of the confidence interval of the difference in means. Below you can specify whether one should be shown, and which confidence-level should be applied (95% corresponds to a 5% level of significance).&lt;/text&gt;
			&lt;frame label="Confidence Interval"&gt;
				&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
				&lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
			&lt;/frame&gt;
		&lt;/page&gt;
	&lt;/wizard&gt;
</programlisting>
<para>
As you see, all of this is mostly a duplication of what has been defined for the dialog-interface. You may of course make the wizard-interface look very different to the plain dialog. Be sure, however, to assign corresponding elements the same "id" in both interfaces. This is not only used to transfer settings from the dialog-interface to the wizard-interface and back, when the user switches interfaces (which does not yet happen in the current version of RKWard), but also simplifies writing your code-template (see below). 
</para>
<programlisting>
&lt;/document&gt;
</programlisting>
<para>
Finally we close the &lt;document&gt;-tag, and that's it. The GUI is defined. You can save the file now. But how does R-syntax get generated from the GUI-settings? I'll deal with that next.
</para>
</chapter>

<chapter id="phptemplate">
<title>Generating R code from GUI settings</title>
<para>
Now we have a GUI defined, but we still need to generate some R-code from that. For that, we need another text-file, "code.php", located in the same directory as the <link linkend="mainxml">description.xml</link>. You may or may not be familiar with PHP. Documentation on PHP can be found here: http://www.php.net. But for most purposes you will not need to know much about PHP at all, as we'll only use some very basic features..
</para>
<para>
For the independent samples t-test, the code.php file looks as follows (with comments in between):
</para>
<programlisting>
&lt;?
</programlisting>
<para>
This is a sort of opening tag in PHP. Everything between &lt;? and ?&gt; will be interpreted as PHP-code. Everything outside of these tags will simply be returned as plain text. See below for examples.
</para>
<programlisting>
	function preprocess () {
	}
</programlisting>
<para>
The PHP-file is organized into four separate functions: preprocess, calculate, printout and cleanup. This is because not all code is needed at all stages. Currently the preprocess-function is not really used.
</para>
<programlisting>
	function calculate () {
?&gt;rk.temp &lt;- t.test (&lt;? getRK ("x"); ?&gt;, &lt;? getRK ("y"); ?&gt;, "&lt;? getRK ("hypothesis"); ?&gt;"&lt;? getRK ("varequal"); if (($conflevel = getRK_val ("conflevel")) != "0.95") echo (", conf.level=" . $conflevel); ?&gt;)
&lt;?
	}
</programlisting>
<para>
This function generates the actual R-syntax to be run from the GUI-settings. Let's look at this in detail:
First we leave the PHP-mode (?&gt;) and hence return
</para>
<screen>
rk.temp &lt;- t.test (
</screen>
<para>
as plain text. Next we need to fill in the value, the user selected as the first variable. Hence we enter PHP-mode again (&lt;?) and call 'getRK ("x");'. This prints out the value of the GUI-element with id "x": our first &lt;varslot&gt;. Next we leave PHP-mode again, print a ', ', and do the same to fetch the value of the element "y" - the second &lt;varslot&gt;. For the hypothesis (the &lt;radio&gt;-group), and the equal variances-&lt;checkbox&gt;, the procedure is very similar.
</para>
<para>
It gets a little more tricky for the confidence level. For reasons of aestethics, we don't want to explicitly specify the confidence level to use, if it corresponds to the default value. Hence, instead of printing the value with 'getRK', we fetch it silently using 'getRK_val' and assign it to a PHP-variable. We then check, whether that variable differs from "0.95" and if so print out an additional argument.
Finally, we leave PHP-mode again, print a last ')', and that's it for the calculate-function.
</para>
<programlisting>
	function printout () {
?&gt;rk.print (rk.temp);
&lt;?
	}
</programlisting>
<para>
And this was all there is to the printout function in most cases. rk.print utilizes the R2HTML package to provide HTML formatted output. You could also excert greater control over the generated output. For this, you'll generate an R syntax, that consists esp. of "cat ()" commands, piecing together an HTML output. If in doubt, just use rk.print (), and be done with.
</para>
<para>
Note: At the time of this writing, I plan to add an rk.print.header () function to print out some information about what kind of analysis was done, when, what parameters, etc. Check back with this document, soon.
</para>
<programlisting>
	function cleanup () {
?&gt;rm (rk.temp)
&lt;?
	}
?&gt;
</programlisting>
<para>
Finally, in the function cleanup we discard the temporary object(s) we left in the R-workspace. You should always clean up all objects created while running the plugin, except if the user explicitely requested otherwise.
</para>
<para>
Congratulations! You created your first plugin. Read on in the next chapters for more advanced concepts
</para>
</chapter>

<chapter id="logic">
<title>GUI logic</title>
<para>
All the basic concepts of creating a plugin for &kapp; have been described in the previous chapters. Those basic concepts should be sufficient for many - if not most - cases. However, sometimes you want more control over how your plugin's GUI behaves.
</para>
<para>
For instance
</para>
</chapter>

<chapter id="embedding">
<title>Embedding Plugins</title>
<para>

</para>
</chapter>



<appendix id="reference">
<title>Reference</title>
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
