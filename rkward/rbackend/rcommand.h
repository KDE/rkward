/***************************************************************************
                          rcommand.h  -  description
                             -------------------
    begin                : Mon Nov 11 2002
    copyright            : (C) 2002 by Thomas Friedrichsmeier
    email                : tfry@users.sourceforge.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef RCOMMAND_H
#define RCOMMAND_H

#include <qfile.h>
#include <qstring.h>
#include <qobject.h>
#include <qptrlist.h>

class RCommandReceiver;

class RCommand;
class RChainOrCommand;
/// this struct is needed by the rthread.
class RCommandChain {
protected:
friend class RCommandStack;
	QPtrList<RChainOrCommand> commands;
	bool closed;
	RCommandChain *parent;
};

/** this struct is needed by the RCommandStrack. It is only a wrapper, which stores a pointer to _either_ a command _or_ a chain. Its sole purpose is to
be able to insert either a command or a chain using the same mechanism, easily. You don't want to use this class outside of RCommandStack (TODO: move it to rcommandstack.h, then!) */
class RChainOrCommand {
private:
friend class RCommandStack;
	RCommand *command;
	RCommandChain *chain;
};

/** this struct is used to pass on eval-requests (i.e. request for RKWard to do something, which may involve issuing further commands) from the
backend-thread to the main thread. Do not use outside the backend-classes. */
struct REvalRequest {
private:
friend class RInterface;
friend class RThread;
	char **call;
	int call_length;
	RCommandChain *in_chain;
};

/*
struct RGetValueRequest {
private:
friend class RInterface;
friend class RThread;
	char **call;
	int call_length;
};

struct RGetValueReply {
private:
friend class RInterface;
friend class RThread;
	char **reply;
	int reply_length;
};
*/

/** This class is used to encapsulate an R-command, so it can be easily identified
	in a chain of commands. It is needed, since communication with R is asynchronous
	and it is therefore not possible to get the result of an R-call right away.
	Instead, create an object of this class, specifying the RCommandReceiver that should
	be called when the command has finished. You can then retrieve all information
	on the command (including the reply) from the object that is passed to your handler.
	
	The type-parameter is used to indicate the type of command (e.g. direct User input vs. generated by a Plugin vs.
	command generated by the main application vs. command used merely to sync data back and forth), and also how the command
	should retrieve information (as a usual string, or as a data vector). @see RCommand::CommandTypes
	
	There are several ways to identify a command when it's finished (needed, if a single RCommandReceiver needs to handle the results of
	several different commands):
		- storing the id () (each command is automatically assigned a unique id, TODO: do we need this functionality? Maybe remove it for redundancy)
		- passing appropriate flags to know how to handle the command
		- keeping the pointer (CAUTION: don't use that pointer except to compare it with the pointer of an incoming command. Commands get deleted when they are finished, and maybe (in the future) if they become obsolete etc. Hence the pointers you keep may be invalid!)
		(- checking the command-string)
	Note that an RCommand carries a whole lot of information around. However, RCommands generally don't get
	kept around very long, so they should not be a memory issue.
  *@author Thomas Friedrichsmeier
  */
  
class RCommand {
public:
/** constructs an RCommand.
@param command The command (string) to be run in the backend. This may include newlines and ";". The command should be a complete statement. If it is an incomplete statement, the backend will not wait for the rest of the command to come in, but rather the command will fail with RCommand::errorIncomplete.
@param type An integer being the result of a bit-wise OR combination of the values in RCommand::CommandTypes, determining, how the command will be dealt with, and what type of output it will return.
@param rk_equiv Not yet used: a short descriptive string attached to the RCommand, that allows the user to make some sense of what this command is all about.
@param receiver The RCommandReceiver this command should be passed on to, when finished.
@param flags A freely assignable integer, that you can use to identify what the command was all about. Only the RCommandReceiver handling the results will have to know what exactly the flags mean.
*/
	RCommand(const QString &command, int type = 0, const QString &rk_equiv = "", RCommandReceiver *receiver=0, int flags=0);
	~RCommand();
/** @returns the type as specified in RCommand::RCommand */
	int type () { return _type; };
/** @returns the rk_equiv as specified in RCommand::RCommand */
	QString rkEquivalent () { return _rk_equiv; };
/** @returns the command string (i.e. the input) as specified in RCommand::RCommand */
	QString command () { return _command; };
/** Each RCommand is assigned a unique integer id (incrementing from 0 to integer overflow) upon creation. This returns this id. 
	@returns the unique id of this command */
	int id () { return _id; };
/** TODO: Adjust these two functions to allow re-getting of output and error-messages from logs */
	QString output () { return _output; };
	QString error () { return _error; };
/** Types of commands (potentially more to come), bitwise or-able,
	although partially exclusive. TODO: find out, why Canceled is in here, and document that fact. */
	enum CommandTypes {User=1, Plugin=2, PluginCom=4, App=8, Sync=16, EmptyCommand=32, GetIntVector=512, GetStringVector=1024, GetRealVector=2048, DirectToOutput=4096, Canceled=8192 };
	enum CommandStatus {WasTried=1, Failed=2, HasOutput=4, HasError=8, ErrorIncomplete=512, ErrorSyntax=1024, ErrorOther=2048};
	bool wasTried () { return (status & WasTried); };
	bool failed () { return (status & Failed); };
	bool succeeded () { return ((status & WasTried) && !(status & Failed)); };
	bool hasOutput () { return (status & HasOutput); };
	bool hasError () { return (status & HasError); };
	bool errorIncomplete () { return (status & ErrorIncomplete); };
	bool errorSyntax () { return (status & ErrorSyntax); };
	int stringVectorLength () { return (string_count); };
	int realVectorLength () { return (real_count); };
	int intVectorLength () { return (integer_count); };
	char **getStringVector () { return (string_data); };
	double *getRealVector () { return (real_data); };
	int *getIntVector () { return (integer_data); };
/// if you want to keep the data, use this function to detach it from the RCommand (after reading it), so it won't be deleted with the RCommand
	void detachStringVector () { string_data = 0; string_count = 0; };
/// if you want to keep the data, use this function to detach it from the RCommand (after reading it), so it won't be deleted with the RCommand
	void detachRealVector () { real_data = 0; real_count = 0; };
/// if you want to keep the data, use this function to detach it from the RCommand (after reading it), so it won't be deleted with the RCommand
	void detachIntVector () { integer_data = 0; integer_count = 0; };
	int getFlags () { return (_flags); };
private:
friend class REmbed;
friend class RInterface;
/// internal function will be called by the backend, as the command gets passed through. Takes care of sending this command (back) to its receiver
	void finished ();
	QString _output;
	QString _error;
	QString _command;
	char **string_data;
	int string_count;
	double *real_data;
	int real_count;
	int *integer_data;
	int integer_count;
	int _type;
	int _flags;
	int status;
	QString _rk_equiv;
	int _id;
	static int next_id;
	RCommandReceiver *receiver;
};

#endif
