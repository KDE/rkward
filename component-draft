RKComponent (and related classes) draft:

Key classes:

RKComponentSlot
something used as input, and output. Several types of this may exist, each offering different values. The more interesting application is using them as input-suppliers for components. RKComponentSlot should probably also do input verification. Basically, an RKComponentSlot is the GUI-independent portion of a GUI-settable value. Mockups:

class RKComponentSlotBase : public QObject {
public signals:
/** slot has changed its value. Any connected RKComponentSlots/RKComponents should update their state
@param slot A pointer to the changed slot for easy reference */
	void valueChanged (RKComponentSlotBase *slot);
public slots:
/** the (Qt-)slot in which (by default) the (RKComponent-)slot is notified, when a slot it depends on has changed. Generally you should reimplement this function to add special handling for the slots you know about. */
	virtual void governorValueChanged (RKComponentSlotBase *slot);
public:
	enum RKComponentSlotTypes {
		0: RKComponentSlotBase,
		1: RKComponentSlotBool,
		2: RKComponentSlotInt,
		3: RKComponentSlotDouble,
		4: RKComponentSlotRObject,
		5: RKComponentSlotRObjectList,
		1000: RKComponentSlotUser	/**< for user expansion */
	};
/** constructor. Pass a valid QObject as parent so the slot will be auto-destructed when no longer needed */
	RKComponentSlotBase (QObject *parent);
/** destructor */
	virtual ~RKComponentSlotBase ();
/** supplies the current value. Since more than one value may be supplied, modifier can be used to select a value. Default implementation only has  a single string, however. */
	virtual QString value (const QString &modifier=QString::null);
/** set the value in string form.
@returns false if the value is illegal (in the base class, all strings are legal) */
	virtual bool setValue (const QString &string);
/** do not set the value, only check, whether it is legal */
	virtual bool isValid (const QString &string);
/** current setting valid? */
	bool isValid ();
/** set to required: will only be satisfied if it holds a valid value. Else: satisfied if valid *or empty* */
	void setRequired ();
/** see setRequired () */
	bool isSatisfied ();
/** for RTTI. see RKComponentSlotTypes */
	virtual int type ();
/** connect this slot to a governor slot (given as argument). If reconcile_requirements, the requirements of both slots are reconciled to the lest common denominator. The dependent slot will be notified on all changes made in the governing slot, so it can update its value. 
Generally with few exceptions, you can only connect to slots that are either of the same class as this slot, or of an extended class. Maybe in the future we will add some sophisticated converters allowing to connect vastly different types of slots in a meaningful way.
If you specify a modifier, only the sub-value indicated by the modifier will be retrieved from the governing slot on governorValueChanged. In this case reconcile_requirements is ignored. */
	virtual void connectGovernor (RKComponentSlotBase *governor, const QString &modifier=QString::null, bool reconcile_requirements=true);
private:
	bool valid;
	bool required;
/** if we're only interested in a specific sub-information of the governor-slot, we need to remember the corresponding modifier */
	QString governor_modifier;
};

/** special type of RKComponentSlot, that is based on a bool setting */
class RKComponentSlotBool : public RKComponentSlotBase {
public:
/** param value_true string value if true/on
param value_false string value if false/off
param default value to use, if invalid string value was set */
	RKComponentSlotBool (const QString &value_true, const QString &value_false, bool default);
/** sets the bool value. Also takes care of notifying dependent components */
	void setValue (bool value);
/** current value as bool */
	bool boolValue ();
/** reimplemented from RKComponentSlotBase. Modifier "true" returns value if true. Modifier "false" returns value if false. Modifier QString::null returns current value. */
	QString value (const QString &modifier=QString::null);
/** reimplemented from RKComponentSlotBase to convert to bool value according to current settings */
	bool setValue (const QString &value);
/** reimplemented from RKComponentSlotBase to test whether conversion to bool value is possible according to current settings */
	bool isValid (const QString &value);
};

class RKComponentSlotInt;		// min, max
class RKComponentSlotDouble;		// min, max

/** special type of RKComponentSlot, that prepresents an RObject
//TODO: this slot should auto-connect to RKModificationTracker, to be safe when the object gets deleted/changed
class RKComponentSlotRObject : public RKComponentSlotBase {
public:
	void setClassFilter (const QString &classes);
	void setTypeFilter (const QString &types);
	void setDimensionFilter (int dimensionality, int min_length=-1, int max_length=-1);
	bool setValue (RObject *object);
	bool isValid (RObject *object);
	RObject *objectValue ();
/** reimplemented from RKComponentSlotBase. Modifier "label" returns label. Modifier "shortname" returns short name. Modifier QString::null returns full name. */
	QString value (const QString &modifier=QString::null);
/** reimplemented from RKComponentSlotBase to convert to RObject, if possible with current constraints */
	bool setValue (const QString &value);
/** reimplemented from RKComponentSlotBase to test whether conversion to RObject, is possible with current constraints */
	bool isValid (const QString &value);
};

/** extension of RKComponentSlotRObject, allowing to hold several RObjects at once. */
class RKComponentSlotRObjectList : public RKComponentSlotRObject {
public:
	void setListLength (int min_length, int min_length_if_any=-1, int max_length=-1);
	bool addValue (RObject *object);
	void removeValue (RObject *object);
	bool isValid (RObject *object);
/** reimplemented from RKComponentSlotBase to return the first RObject in the list */
	RObject *objectValue ();
	QValueList<RObject *> objectList ();
/** reimplemented from RKComponentSlotBase. Modifier "label" returns label. Modifier "shortname" returns short name. Modifier QString::null returns full name. */
	QString value (const QString &modifier=QString::null);
/** reimplemented from RKComponentSlotBase to convert to list of RObject, if possible with current constraints */
	bool setValue (const QString &value);
/** reimplemented from RKComponentSlotBase to test whether conversion to list of RObject, is possible with current constraints */
	bool isValid (const QString &value);
};

// Actually, I believe, we'd rather not have this one, but rather attach those function to the RKComponent class directly instead!
/** special type of RKComponentSlot used to contain R code. All stand-alone RKComponents have this */
class RKComponentSlotCode : public RKComponentSlotBase {
public:
/** the preprocess code */
	QString preprocess ();
/** the calculate code */
	QString calculate ();
/** the printout code */		// TODO, maybe we can abstract this away. A component should _either_ do calculation _or_ printout, hence it could all be calculate () only, as well.
	QString printout ();
/** the cleanup code */
	QString cleanup ();
};

RKComponentSlots are attached to and owned by RKComponents (those that use it as output)

/** abstract base class of all RKComponents, including component widgets */
class RKComponent : public QWidget {
public:
/** standard slot controlling visibility */
	RKComponentSlotBool *visibilitySlot ();
/** standard slot controlling enabledness */
	RKComponentSlotBool *enablednessSlot ();
/** standard slot controlling requiredness */
	RKComponentSlotBool *requirednessSlot ();

/** The parent of this component. Should be notified, whenever isSatisfied () or isReady ()-state changed. */
	RKComponent *parent ();
	bool isSatisfied ();
	bool isReady ();
private:
/** also notifies the parent, if applicable */
	void setSatisfied (bool satisfied);
	void setReady (bool ready);
};

/** "regular" components, described in XML format */
class RKStandardComponent : public RKComponent {
};

/** wrapper class for "external" components, i.e. components implemented in stand-alone applets */
class RKExternalComponent : public RKComponent {
};

// TODO: do we need this?
/** described the external interface provided by an RKComponent. This means a list of all slots that can be used as input for this component. Used for matching/mapping external RKComponentSlots to RKComponentSlots inside this component */
class RKComponentInterface {
};



Initialization steps in creating an RKComponent:
On top level: probably a call to setUpdatesEnabled (false) should be done!
	- create Subcomponents (depth first is important!)
		- ...
	- create RKComponentSlots
	- connect RKComponentSlots within this component and to subcomponents (those are already fully connected!)
	- initialize
		- set initial values in RKComponentSlots
			(- updates GUI)
			(- may trigger changes in subcomponents)
		- connect RKComponentSlots within this component and to subcomponents (those are already fully connected!)
			- connect
			- retrieve values from governing slots
				(- may trigger further changes in this, and subcomponents)
	- return to parent
On top level: probably a call to setUpdatesEnabled (true); update () should be done!
