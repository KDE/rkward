<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [
  <!ENTITY rkward '<application
>RKWard</application
>'>
  <!ENTITY R '<application
>R</application
>'>
  <!ENTITY javascript 'JavaScript'>
  <!ENTITY pluginmap '<literal role="extension"
>.pluginmap</literal
>'>
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Slovenian "INCLUDE"
><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!--- This file is part of the RKWard project (https://rkward.kde.org).
SPDX-FileCopyrightText: by Thomas Friedrichsmeier <thomas.friedrichsmeier@kdemail.net>
SPDX-FileCopyrightText: by Meik Michalke <meik.michalke@hhu.de>
SPDX-FileContributor: The RKWard Team <rkward-devel@kde.org>
SPDX-License-Identifier: GFDL-1.2-no-invariants-or-later OR GPL-2.0-or-later
-->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title
>Uvod v pisanje vtičnikov za &rkward;</title>

<authorgroup>
<author
><firstname
>Thomas</firstname
> <surname
>Friedrichsmeier</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>

<author
><firstname
>Meik</firstname
> <surname
>Michalke</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>
<!-- Additional authors go here -->

<othercredit role="translator"
><firstname
>Matjaž</firstname
><surname
>Jeran</surname
><affiliation
><address
><email
>matjaz.jeran@amis.net</email
></address
></affiliation
><contrib
>Prevod</contrib
></othercredit
> 
</authorgroup>



<copyright>
<year
>2006-2022</year>
<holder
>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice
>&FDLNotice;</legalnotice>

<date
>24.04.2022</date>
<releaseinfo
>0.7.4</releaseinfo>

<abstract>
<para
>To je vodnik za pisanje vtičnikov za &rkward;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>R</keyword>
<keyword
>rkward</keyword>
<keyword
>vtičniki</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title
>Uvod</title>

	<para
>Ta dokument opisuje, kako napisati svoje lastne vtičnike. Dokumentacija se je sčasoma precej povečala. Naj vas to ne prestraši. Priporočamo, da preberete štiri osnovne korake (kot je opisano spodaj), da dobite osnovno predstavo o tem, kako stvari delujejo. Po tem boste morda želeli preleteti kazalo, da vidite, katere napredne teme bi lahko bile za vas pomembne. </para>
	<para
>Za vprašanja in komentarje pišite na &rkward; razvojni poštni seznam. </para>
	<para
><emphasis
>Tega vam ni treba brati, če želite uporabljati &rkward;.</emphasis
> Ta dokument govori o razširitvi &rkward;. Namenjen je naprednim uporabnikom ali ljudem, ki so pripravljeni pomagati izboljšati &rkward;. </para>
	<para
>Pisanje standardnega vtičnika je v bistvu postopek v štirih korakih: </para>
		<itemizedlist>
			<listitem
><para
><link linkend="pluginmap"
>Umestitev novega dejanja v hierarhijo menija</link
></para
></listitem>
			<listitem
><para
><link linkend="mainxml"
>Opis videza in delovanja vtičnika &GUI;</link
></para
></listitem>
			<listitem
><para
><link linkend="jstemplate"
>Uporabnik določi, kako naj se generira koda R iz nastavitev &GUI;</link
></para
></listitem>
			<listitem
><para
><link linkend="pluginhelp"
>Dodajanje strani s pomočjo vašemu vtičniku</link
></para
></listitem>
		</itemizedlist>
	<para
>Ti se bodo obravnavali po vrsti. </para>
	<para
>Nekateri napredni koncepti se lahko uporabijo v teh štirih korakih, vendar so obravnavani v ločenih poglavjih, da bodo stvari preproste: <itemizedlist>
			<listitem
><para
><link linkend="logic"
>&GUI; logika</link
></para
></listitem>
			<listitem
><para
><link linkend="embedding"
>Vdelava vtičnikov v vtičnike</link
></para
></listitem>
			<listitem
><para
><link linkend="plugin_series"
>Uporabni koncepti za ustvarjanje številnih serij podobnih vtičnikov</link
></para
></listitem>
		</itemizedlist>
	</para>
	<para
>Prav tako nobeno od poglavij ne prikazuje vseh možnosti, temveč le osnovne pojme. Celoten <link linkend="reference"
>sklic</link
> možnosti je na voljo posebej. </para>
</chapter>

<chapter id="whatareplugins">
<title
>Uvod: kaj so vtičniki v &rkward;? Kako delujejo?</title>
	<para
>Seveda je prvo vprašanje, ki ga morda imate: kateri deli &rkward; funkcionalnosti je realizirana z vtičniki? Ali: kaj lahko storijo vtičniki? </para>
	<para
>Eden od načinov za odgovor na to je: prekličite izbiro vseh datotek &pluginmap; pod <menuchoice
><guimenu
>Nastavitve</guimenu
><guimenuitem
>Konfiguriraj &rkward;</guimenuitem
><guimenuitem
>Vtičnike</guimenuitem
></menuchoice
> in poglejte, kaj manjka. Nekoliko bolj koristen odgovor: večina dejanskih statističnih funkcij, dostopnih prek &GUI; so realizirani z uporabo vtičnikov. Z uporabo vtičnikov lahko ustvarite tudi dokaj prilagodljive &GUI;-je za vse vrste operacij. </para>
	<para
>Osnovna paradigma &rkward; vtičnikov je tisti, skozi katerega vas bomo vodili v tem dokumentu: datoteka &XML; opisuje, kako naj bo videti &GUI;. Dodatna datoteka &javascript; se uporablja za ustvarjanje &R; sintakse iz &GUI; nastavitev. To pomeni, da vtičnikom v resnici ni treba izvajati nobenih statističnih izračunov. Namesto tega vtičniki ustvarijo &R; sintakso, potrebno za izvajanje teh izračunov. &R; sintaksa se nato pošlje v &R; zaledje za ovrednotenje in običajno je rezultat prikazan v izhodnem oknu. </para>
	<para
>V naslednjih poglavjih preberite, kako se to naredi. </para>
</chapter>

<chapter id="pluginmap">
<title
>Ustvarjanje menijskih vnosov</title>
	<para
>Ko ustvarite nov vtičnik, morate povedati &rkward; o tem. Torej, prva stvar, ki jo morate narediti, je napisati datoteko &pluginmap; (ali spremenite obstoječo). Oblika zapisa &pluginmap; je &XML;. Vodil vas bom skozi primer (seveda se prepričajte, da imate &rkward; konfiguriran za nalaganje vašega &pluginmap; -- <menuchoice
><guimenu
>Nastavitve</guimenu
><guimenuitem
>Konfiguriraj &rkward;</guimenuitem
><guimenuitem
> Vtičniki</guimenuitem
></menuchoice
>): </para>
	<tip>
		<para
>Ko preberete to poglavje, si oglejte tudi <link linkend="rkwarddev"
> paket <application
>rkwarddev</application
></link
>. Zagotavlja nekaj &R; funkcij za ustvarjanje večine &rkward;-jevih &XML; oznak za vas. </para>
	</tip>
	<programlisting
>&lt;!DOCTYPE rkpluginmap&gt;
        </programlisting>
	<para
>Tip dokumenta se v resnici ne interpretira, vendar ga vseeno nastavite na <replaceable
>"rkpluginmap"</replaceable
>. </para>
	<programlisting
>&lt;document base_prefix="" namespace="myplugins" id="mypluginmap"&gt;
        </programlisting>
	<para
>Atribut <parameter
>base_prefix</parameter
> je mogoče uporabiti, če so vsi vaši vtičniki v skupnem imeniku. V bistvu lahko ta imenik izpustite iz spodaj navedenih imen datotek. To je varno pustiti pri <replaceable
>""</replaceable
>. </para
><para
>Kot boste videli spodaj, vsi vtičniki dobijo edinstven identifikator, <parameter
>id</parameter
>. <parameter
>imenski prostor</parameter
> je način za organiziranje teh ID-jev in zmanjšanje možnosti, da bi po nesreči ustvarili podvojeni identifikator. Interno se v bistvu imenski prostor in nato <quote
>::</quote
> doda pred vse identifikatorje, ki jih podate v tem &pluginmap;. Na splošno, če nameravate <link linkend="sect_external_plugins"
>distribuirati svoje vtičnike v paketu &R;</link
>, je dobro uporabiti ime paketa kot parameter <parameter
>namespace</parameter
>. Vtičniki, dobavljeni z uradno &rkward; distribucijo imajo <replaceable
>namespace="rkward"</replaceable
>. </para>
	<para
>Atribut <parameter
>id</parameter
> ni obvezen, vendar navedba ID-ja za vaš &pluginmap; drugim ljudem omogoča, da njihovi &pluginmap;-ji samodejno naložijo vaš &pluginmap; (glejte <link linkend="chapter_dependencies"
>razdelek o odvisnostih</link
>). </para>
	<programlisting
>&lt;komponente&gt;
        </programlisting>
	<para
>Komponente? Ali ne govorimo o vtičnikih? Da, vendar v prihodnosti vtičniki ne bodo nič več kot poseben razred komponent. Tukaj torej registriramo vse komponente/vtičnike pri &rkward;. Poglejmo primer vnosa: </para>
	<programlisting
>&lt;component type="standard" id="t_test_two_vars" file="t_test_two_vars.xml" label="t-test dveh spremenljivk" /&gt;
        </programlisting>
	<para
>Najprej atribut <parameter
>type</parameter
>: to za zdaj pustite na <replaceable
>»standard«</replaceable
>. Nadaljnje vrste še niso implementirane. <parameter
>id</parameter
>, ki smo ga že nakazali. Vsaka komponenta mora dobiti edinstven (v svojem imenskem prostoru) identifikator. Izberite tisto, ki je zlahka prepoznavna. Izogibajte se presledkom in kakršnim koli posebnim znakom. Ti zaenkrat niso prepovedani, vendar imajo lahko poseben pomen. Z atributom <parameter
>file</parameter
> določite, kje se nahaja <link linkend="mainxml"
>opis dejanskega vtičnika</link
>. To je glede na imenik datoteka &pluginmap; in <parameter
>base_prefix</parameter
> zgoraj. Na koncu dajte komponenti oznako. Ta oznaka bo prikazana povsod, kjer je vtičnik nameščen v meniju (ali v prihodnosti morda tudi na drugih mestih). </para>
	<para
>Običajno bo datoteka &pluginmap; vsebovala več komponent, zato je tukaj še nekaj: </para>
	<programlisting
>&lt;component type="standard" id="unimplemented_test" file="means/unimplemented.xml" /&gt;
                &lt;component type="standard" id="fictional_t_test" file="means/ttests/fictional.xml" label="This is a fictional t-test" /&gt;
                &lt;component type="standard" id="descriptive" file="descriptive.xml" label="Descriptive Statistics" /&gt;
                &lt;component type="standard" id="corr_matrix" file="corr_matrix.xml" label="Correlation Matrix" /&gt;
                &lt;component type="standard" id="simple_anova" file="simple_anova.xml" label="Simple Anova" /&gt;
        &lt;/components&gt;
        </programlisting>
	<para
>OK, to je bil prvi korak. &rkward; zdaj ve, da ti vtičniki obstajajo. Toda kako jih priklicati? Umestiti jih je treba v hierarhijo menijev: </para>
	<programlisting
>&lt;hierarchy&gt;
                &lt;menu id="analysis" label="Analysis"&gt;
        </programlisting>
	<para
>Takoj pod oznako <command
>&lt;hierarchy&gt;</command
> začnete opisovati, v kateri <command
>&lt;meni&gt;</command
> naj gredo vaši vtičniki. Z zgornjo vrstico v bistvu rečete, da mora biti vaš vtičnik v meniju <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> (ne nujno neposredno tam, ampak v podmeniju). Meni <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> je standarden v &rkward;, zato ga dejansko ni treba ustvariti od začetka. Če pa še ne bi obstajal, bi mu z uporabo atributa <parameter
>label</parameter
> dali njegovo ime. Končno, <parameter
>id</parameter
> ponovno identificira ta <command
>&lt;meni&gt;</command
>. To je potrebno, zato je več &pluginmap; datoteke lahko postavijo svoje vtičnike v iste menije. To storijo tako, da poiščejo <command
>&lt;meni&gt;</command
> z danim <parameter
>id</parameter
>. Če ID še ne obstaja, bo ustvarjen nov meni. V nasprotnem primeru bodo vnosi dodani v obstoječi meni. </para>
	<programlisting
>&lt;menu id="means" label="Means"&gt;
        </programlisting>
	<para
>Tu je v bistvu ista stvar: zdaj definiramo podmeni v meniju <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Imenoval se bo <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="ttests" label="t-tests"&gt;
        </programlisting>
	<para
>In zadnja raven v hierarhiji menijev: podmeni podmenija <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;entry component="t_test_two_vars" /&gt;
        </programlisting>
	<para
>Zdaj, končno, to je meni, v katerega želimo postaviti vtičnik. Oznaka <command
>&lt;entry&gt;</command
> signalizira, da je to pravzaprav prava stvar, namesto drugega podmenija. Atribut <parameter
>component</parameter
> se nanaša na <parameter
>id</parameter
>, ki ste ga dali zgornjemu vtičniku/komponenti. </para>
	<programlisting
>&lt;entry component="fictional_t_test" /&gt;
                                &lt;/menu&gt;
                                &lt;entry component="fictional_t_test" /&gt;
                        &lt;/menu&gt;
                        &lt;menu id="frequency" label="Frequency" index="2"/&gt;
        </programlisting>
	<para
>Če ste izgubili sled: To je še en podmeni v meniju <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Oglejte si spodnji posnetek zaslona. Nekaj nevidnega, označenega z [...], bomo preskočili. </para>
	<programlisting
>[...]
                        &lt;/menu&gt;
                        &lt;entry component="corr_matrix"/&gt;
                        &lt;entry component="descriptive"/&gt;
                        &lt;entry component="simple_anova"/&gt;
                &lt;/menu&gt;
        </programlisting>
	<para
>To so zadnji vnosi, vidni na spodnjih posnetkih zaslona. </para>
	<programlisting
>&lt;menu id="plots" label="Plots"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Seveda lahko svoje vtičnike postavite tudi v menije, ki niso <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="file" label="File"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Tudi v standardnih menijih, kot je <menuchoice
><guimenu
>Datoteka</guimenu
></menuchoice
>. Vse kar potrebujete je pravilen <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;/hierarchy&gt;        
&lt;/document&gt;
        </programlisting>
	<para
>Tako se to naredi. In ta posnetek zaslona prikazuje rezultat: </para>
	<screenshot>
	<screeninfo
>Menijska hierarhija, ustvarjena z zgoraj prikazano kodo</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Menijska hierarhija, ustvarjena z zgoraj prikazano kodo</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Zmedeni? Najlažji način za začetek je verjetno uporaba nekaterih obstoječih datotek&pluginmap;, ki so priložene distribuciji, in jih prilagodite svojim potrebam. Če potrebujete pomoč, ne oklevajte in pišite na poštni seznam za razvoj. </para>
	<sect1 id="pluginmap_grouping"
><title
>Nadzor vrstnega reda vnosov v meniju</title>
		<para
>Privzeto bodo vsi elementi (vnosi/podmeniji) znotraj menija samodejno razvrščeni po abecedi. V <emphasis
>nekaterih</emphasis
> primerih boste morda želeli več nadzora. V tem primeru lahko elemente združite na naslednji način:</para>
		<itemizedlist>
			<listitem>
				<para
>Skupine lahko določite znotraj katerega koli menija, kot je ta. Vsi elementi, ki pripadajo isti skupini, bodo združeni:</para>
				<programlisting
>&lt;group id="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
			<para
>Če želite, da je skupina vizualno ločena od drugih vnosov, uporabite:</para>
				<programlisting
>&lt;group id="somegroup" separated="true"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Vnose, menije in skupine je mogoče dodati določeni skupini z uporabo:</para>
				<programlisting
>&lt;entry component="..." group="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Pravzaprav je možno tudi implicitno definirati skupine (brez ločilnih črt):</para>
				<programlisting
>&lt;entry component="first" group="a"/&gt;
                &lt;entry component="third"/&gt;
                &lt;entry component="second" group="a"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Imena skupin so specifična za vsak meni. Skupina "a" v meniju "Data" na primer ni v nasprotju s skupino "a" v meniju "Analysis".</para>
			</listitem
><listitem>
				<para
>Najpogostejši primer uporabe je definiranje skupin na vrhu ali na dnu menija. Za to sta v vsakem meniju vnaprej določeni skupini "top" in "bottom".</para>
			</listitem
><listitem>
				<para
>Vnosi znotraj vsake skupine so razvrščeni po abecedi. Skupine se prikažejo po vrstnem redu deklaracije (razen če so dodane drugi skupini, seveda).</para>
			</listitem
><listitem>
				<para
>Meniji in vnosi brez specifikacije skupine prav tako logično tvorijo skupino ("").</para>
			</listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="mainxml">
<title
>Definiranje &GUI;</title>
<sect1 id="sect_defining_the_GUI"
><title
>Definiranje pogovornega okna</title>
	<para
>V <link linkend="pluginmap"
>prejšnjem poglavju</link
> ste videli, kako registrirati vtičnik v &rkward;. Najpomembnejša sestavina je bila določitev poti do &XML; datoteko z opisom, kako je vtičnik dejansko videti. V tem poglavju se boste naučili, kako ustvariti to &XML; datoteko. </para>
	<tip>
		<para
>Ko preberete to poglavje, si oglejte tudi <link linkend="rkwarddev"
> paket <application
>rkwarddev</application
></link
>. Zagotavlja nekaj &R; funkcij za ustvarjanje večine &rkward;-jevih &XML; oznak za vas. </para>
	</tip>
	<para
>Še enkrat vas bomo popeljali skozi primer. Primer je (nekoliko poenostavljena) različica t-testa z dvema spremenljivkama. </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
        </programlisting>
	<para
>Tip dokumenta še ni zares razložen. Vseeno ga nastavite na <replaceable
>rkplugin</replaceable
>. </para>
	<programlisting
>&lt;document&gt;
        &lt;code file="t_test_two_vars.js"/&gt;
        </programlisting>
	<para
>Vsi vtičniki ustvarijo neko kodo. Trenutno je edini način za to uporaba JS, kot je podrobno opisano v <link linkend="jstemplate"
>naslednjem poglavju</link
>. To določa, kje iskati kodo JS. Ime datoteke je relativno glede na imenik vtičnika &XML;. </para>
	<programlisting
>&lt;help file="t_test_two_vars.rkh"/&gt;
        </programlisting>
	<para
>Običajno je dobro, da za svoj vtičnik zagotovite tudi stran s pomočjo. Ime datoteke te strani s pomočjo je podano tukaj glede na imenik, vtičnik &XML; Pisanje strani s pomočjo je dokumentirano <link linkend="pluginhelp"
>tukaj</link
>. Če ne zagotovite datoteke pomoči, izpustite to vrstico. </para>
	<programlisting
>&lt;dialog label="Two Variable t-Test"&gt;
        </programlisting>
	<para
>Kot veste, imajo lahko vtičniki pogovorno okno ali vmesnik čarovnika ali oboje. Tukaj začnemo definirati pogovorni vmesnik. Atribut <parameter
>label</parameter
> določa napis pogovornega okna. </para>
	<programlisting
>&lt;tabbook&gt;
                        &lt;tab label="Basic settings"&gt;
        </programlisting>
	<para
>&GUI; elemente je mogoče organizirati s knjigo zavihkov (tabbook). Tukaj definiramo tabbook kot prvi element v pogovornem oknu. Uporabite <command
>&lt;tabbook&gt;</command
>[...]<command
>&lt;/tabbook&gt;</command
>, da definirate zavihek, nato pa za vsako stran v zavihku uporabite <command
>&lt;tab&gt;</command
>[...]<command
>&lt;/tab&gt;</command
>. Atribut <parameter
>label</parameter
> v elementu <command
>&lt;tab&gt;</command
> vam omogoča, da določite napis za to stran knjige zavihkov. </para>
	<programlisting
>&lt;row id="main_settings_row"&gt;
        </programlisting>
	<para
>Oznaki <command
>&lt;row&gt;</command
> in <command
>&lt;column&gt;</command
> določata postavitev &GUI; elementov. Tukaj pravite, da bi radi postavili nekaj elementov drug ob drugem (od leve proti desni). Atribut <parameter
>id</parameter
> ni nujno potreben, vendar ga bomo uporabili pozneje, ko bomo našemu vtičniku dodajali vmesnik čarovnika. Prvi element, ki ga postavite v vrstico, je: </para>
	<programlisting
>&lt;varselector id="vars"/&gt;
        </programlisting>
	<para
>S to preprosto oznako ustvarite seznam, s katerega lahko uporabnik izbere spremenljivke. Za ta element morate določiti <parameter
>id</parameter
>, zato &rkward; ve, kako ga najti. </para>
	<warning>
		<para
>V nizu <parameter
>id</parameter
> NE smete uporabiti pike (.). </para>
	</warning>
	<programlisting
>&lt;column&gt;
        </programlisting>
	<para
>Nato v vrstico ugnezdimo <command
>&lt;column&gt;</command
>. To pomeni, da bodo naslednji elementi postavljeni drug nad drugim (od zgoraj navzdol) in vsi bodo desno od <command
>&lt;varselector&gt;</command
>. </para>
	<programlisting
>&lt;varslot types="number" id="x" source="vars" required="true" label="compare"/&gt;
                                                &lt;varslot types="number" id="y" source="vars" required="true" label="against" i18n_context="compare against"/&gt;
        </programlisting>
	<para
>Ti elementi so protipostavka <command
>&lt;varselector&gt;</command
>. Predstavljajo <quote
>reže (slots)</quote
>, v katere lahko uporabnik vstavi spremenljivke. Opazili boste, da je <parameter
>source</parameter
> nastavljen na isto vrednost kot <parameter
>id</parameter
> <command
>&lt;varselector&gt;</command
>. To pomeni, da bo vsak <command
>&lt;varslot&gt;</command
> prevzel svojo spremenljivko iz izbirnika spremenljivk. <command
>&lt;varslot&gt;</command
> morajo prav tako dobiti <parameter
>id</parameter
>. Lahko imajo <parameter
>label</parameter
> in so lahko nastavljeni na <parameter
>required</parameter
>. To pomeni, da gumb <guibutton
>Pošlji</guibutton
> ne bo omogočen, dokler <command
>&lt;varslot&gt;</command
> ne vsebuje veljavne vrednosti. Končno atribut <parameter
>type</parameter
> še ni interpretiran, vendar bo uporabljen za zagotavljanje, da bodo v <command
>&lt;varslot&gt;</command
> dovoljeni samo pravilni tipi spremenljivk. </para>
	<para
>Če se sprašujete o atributu <parameter
>i18n_context</parameter
>: To zagotavlja kontekst za pomoč pri pravilnem prevodu besede "against", ki se uporablja kot <command
>&lt;varslot&gt;</command
>' s oznako, vendar ne vpliva neposredno na funkcionalnost vtičnika. Več o tem v <link linkend="i18n_general"
>ločenem poglavju</link
>. </para>
	<programlisting
>&lt;radio id="hypothesis" label="using test hypothesis"&gt;
                                                        &lt;option value="two.sided" label="Two-sided"/&gt;
                                                        &lt;option value="greater" label="First is greater"/&gt;
                                                        &lt;option value="less" label="Second is greater"/&gt;
                                                &lt;/radio&gt;
        </programlisting>
	<para
>Tukaj določite skupino ekskluzivnih gumbov <command
>&lt;radio&gt;</command
>. Skupina ima <parameter
>label</parameter
> in <parameter
>id</parameter
>. Vsak <command
>&lt;option&gt;</command
> (gumb) ima <parameter
>oznako</parameter
> in mu je dodeljena <parameter
>vrednost</parameter
>. To je vrednost, ki jo element <command
>&lt;radio&gt;</command
> vrne, ko je izbrana možnost. </para>
	<programlisting
>&lt;/column&gt;
                                &lt;/row&gt;
                        &lt;/tab&gt;
        </programlisting>
	<para
>Vsako oznako je treba zapreti. Vse elemente, ki smo jih želeli (dva <command
>&lt;varslots&gt;</command
> in <command
>&lt;radio&gt;</command
>) smo postavili v <command
>&lt;column&gt;</command
>. Vse želene elemente (<command
>&lt;varselector&gt;</command
> in <command
>&lt;column&gt;</command
> s temi elementi) postavimo v <command
>&lt;row&gt;</command
>. Vse elemente, ki smo jih želeli, smo postavili na prvo stran v <command
>&lt;tabbook&gt;</command
>. Nismo še končali z definiranjem <command
>&lt;tabbook&gt;</command
> (prihaja več strani), seveda pa je še več v <command
>&lt;pogovornem oknu&gt;</command
>. Toda ta posnetek zaslona je v bistvu to, kar smo naredili do zdaj: </para>
	<screenshot>
	<screeninfo
>t-Test plugin</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="t_test_plugin_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>t-Test plugin</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Upoštevajte, da nismo določili <guibutton
>Pošlji</guibutton
>,<guibutton
>Zapri</guibutton
> &etc; gumbi ali pogled kode. Ti elementi seustvarijo samodejno. Seveda pa moramo še definiratidrugo stran <command
>&lt;tabbook&gt;</command
>: </para>
	<programlisting
>&lt;tab label="Options"&gt;
                                &lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
        </programlisting>
	<para
>Elementi bodo privzeto postavljeni od zgoraj navzdol kot v <command
>&lt;column&gt;</command
>. Ker je to tisto, kar želimo tukaj, nam ni treba izrecno navesti postavitve <command
>&lt;row&gt;</command
> ali <command
>&lt;column&gt;</command
>. Prvi element, ki ga definiramo, je potrditveno polje. Tako kot <command
>&lt;radio&gt;</command
><command
>&lt;option&gt;</command
> ima potrditveno polje <parameter
>oznako</parameter
> in <parameter
>vrednost</parameter
>. <parameter
>vrednost</parameter
> je tisto, kar se vrne, če je potrditveno polje potrjeno. Seveda potrditveno polje potrebuje tudi <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;frame label="Confidence Interval" id="frame_conf_int"&gt;
        </programlisting>
	<para
>Tukaj je še en element postavitve: Da bi signalizirali, da spodnja elementa spadata skupaj, narišemo <command
>&lt;frame&gt;</command
> (polje). Ta okvir ima lahko <parameter
>oznako</parameter
> (napis). Ker je okvir samo pasivni element postavitve, ne potrebuje <parameter
>id</parameter
>, vseeno pa ga definiramo tukaj, saj se bomo nanj sklicevali kasneje, ko bomo definirali dodatni vmesnik čarovnika. </para>
	<programlisting
>&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
                                        &lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
                                &lt;/frame&gt;
        </programlisting>
	<para
>Znotraj <command
>&lt;frame&gt;</command
> postavimo še en <command
>&lt;checkbox&gt;</command
> (z uporabo <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, znak, da mora biti potrditveno polje privzeto potrjeno), in <command
>&lt;spinbox&gt;</command
>. Spinbox uporabniku omogoča izbiro vrednosti med <replaceable
>"min"</replaceable
> in <replaceable
>"max"</replaceable
> s privzeto/začetno vrednostjo <replaceable
>"0,95"</replaceable
>. Nastavitev <parameter
>type</parameter
> na <replaceable
>"real"</replaceable
> signalizira, da so realna števila sprejeta v nasprotju s <parameter
>type=</parameter
><replaceable
>"integer"</replaceable
>, ki bi sprejel samo cela števila. </para>
	<note
><para
>Prav tako je mogoče in pogosto bolje, da se omogoči preverjanje samega <command
>&lt;frame&gt;</command
>, namesto dodajanja <command
>&lt;checkbox&gt;</command
> znotraj. Za podrobnosti si oglejte referenco. To tukaj ni storjeno zaradi ponazoritve. </para
></note>
	<programlisting
>&lt;/tab&gt;
                &lt;/tabbook&gt;
        &lt;/dialog&gt;
        </programlisting>
	<para
>To je vse za drugo stran <command
>&lt;tabbook&gt;</command
>, vse strani v <command
>&lt;tabbook&gt;</command
> in vse elemente v <command
>&lt;pogovornem oknu&gt;</command
>. Končali smo z definiranjem, kako je videti pogovorno okno. </para>
	<programlisting
>&lt;/document&gt;
        </programlisting>
	<para
>Na koncu zapremo oznako <command
>&lt;document&gt;</command
> in to je to. &GUI; je definiran. Zdaj lahko shranite datoteko. Kako pa se &R; sintaksa ustvari iz &GUI; nastavitve? S tem se bomo ukvarjali v <link linkend="jstemplate"
>naslednjem poglavju</link
>. Najprej pa si bomo ogledali dodajanje vmesnika čarovnika in nekaj splošnih premislekov. </para>
</sect1>

<sect1 id="wizard_interface">
	<title
>Dodajanje vmesnika čarovnika</title>
	<para
>Pravzaprav nam ni treba definirati dodatnega vmesnika <command
>&lt;wizard&gt;</command
>, toda tukaj je in tako bi to naredili. Če želite dodati vmesnik čarovnika, boste dodali oznako <command
>&lt;wizard&gt;</command
> na isti ravni kot oznako <command
>&lt;dialog&gt;</command
>: </para>
	<programlisting
>&lt;wizard label="Two Variable t-Test"&gt;
                        &lt;page id="firstpage"&gt;
                                &lt;text&gt;As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater.&lt;/text&gt;
                                &lt;copy id="main_settings_row"/&gt;
                        &lt;/page&gt;
        </programlisting>
	<para
>Nekaj od tega je precej razumljivo: dodamo oznako <command
>&lt;wizard&gt;</command
> z <parameter
>label</parameter
> za čarovnika. Ker lahko čarovnik vsebuje več strani, ki so prikazane ena za drugo, nato definiramo prvo <command
>&lt;page&gt;</command
> in vanjo dodamo razlagalno opombo <command
>&lt;text&gt;</command
>. Nato uporabimo oznako <command
>&lt;copy&gt;</command
>. Kaj to stori, je, da nam res prihrani ponovno definiranje, kar smo že napisali za <command
>&lt;dialog&gt;</command
>: Oznaka za kopiranje išče drugo oznako z enakim <parameter
>id</parameter 
> prej v &XML;. To je definirano v razdelku <command
>&lt;dialog&gt;</command
> in je <command
>&lt;row&gt;</command
>, v kateri je <command
>&lt;varselector&gt;</command
> , <command
>&lt;varslots&gt;</command
> in nadzor <quote
>hypothesis</quote
> <command
>&lt;radio&gt;</command
>. Vse to je kopirano 1:1 in vstavljeno tik ob element <command
>&lt;copy&gt;</command
>. </para>
	<para
>Zdaj pa na drugo stran: </para>
	<programlisting
>&lt;page id="secondpage"&gt;
                                &lt;text&gt;Below are some advanced options. It is generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing "assume equal variances" may increase test-strength, however.&lt;/text&gt;
                                &lt;copy id="varequal"/&gt;
                                &lt;text&gt;Sometimes it is helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance).&lt;/text&gt;
                                &lt;copy id="frame_conf_int"/&gt;
                        &lt;/page&gt;
                &lt;/wizard&gt;
        </programlisting>
	<para
>Tukaj je skoraj isto. Dodamo nekaj besedil in vmes ta <command
>&lt;copy&gt;</command
> nadaljnje razdelke iz pogovornega vmesnika. </para>
	<para
>Seveda lahko naredite, da je vmesnik čarovnika zelo drugačen od navadnega pogovornega okna in sploh ne uporabite oznake <command
>&lt;copy&gt;</command
>. Vendar se prepričajte, da ustreznim elementom dodelite isti <parameter
>id</parameter
> v obeh vmesnikih. To se ne uporablja le za prenos nastavitev iz pogovornega vmesnika v vmesnik čarovnika in nazaj, ko uporabnik zamenja vmesnik (kar se v trenutni različici &rkward; še ne zgodi), ampak tudi poenostavi pisanje predloge kode (glejte spodaj) . </para>
</sect1>

<sect1 id="mainxmltips">
	<title
>Nekaj pomislekov o &GUI; oblikovanju</title>
	<para
>Ta razdelek vsebuje nekaj splošnih premislekov, na podlagi katerih &GUI; elementov za uporabo kje. Če je to vaš prvi poskus ustvarjanja vtičnika, lahko ta razdelek preskočite, saj ni pomemben za pridobitev osnovnega &GUI; delovanja. Pozneje se vrnite sem, da vidite, ali lahko izboljšate svoj &GUI; tako ali drugače. </para>
	
	<sect2 id="radio_vs_checkbox_vs_dropdown">
		<title
>&lt;radio&gt; v primerjavi s &lt;checkbox&gt; v primerjavi s &lt;dropdown&gt;</title>
		<para
>Vsi trije elementi <command
>&lt;radio&gt;</command
>, <command
>&lt;checkbox&gt;</command
>, <command
>&lt;dropdown&gt;</command
> imajo podobno funkcijo: za izbiro enega izmed več možnosti. Očitno potrditveno polje omogoča izbiro le med dvema možnostma: potrjeno ali nepotrjeno, zato ga ne morete uporabiti, če lahko izbirate med več kot dvema možnostma. Toda kdaj uporabiti katerega od elementov? Nekaj osnovnih pravil: </para>
		<para
>Če ugotovite, da ustvarjate <command
>&lt;radio&gt;</command
> ali <command
>&lt;dropdown&gt;</command
> s samo dvema možnostma, se vprašajte, ali je vprašanje v bistvu tip vprašanja da/ne. Npr. izbira med <quote
>prilagodi rezultate</quote
> in <quote
>ne prilagodi rezultatov</quote
> ali med <quote
>odstrani manjkajoče vrednosti</quote
> in <quote
>ohrani manjkajoče vrednosti</quote
>. V tem primeru je <command
>&lt;checkbox&gt;</command
> najboljša izbira: porabi malo prostora, ima najmanj besed oznak in ga uporabnik najlažje prebere. Obstaja zelo malo situacij, ko bi morali izbrati <command
>&lt;radio&gt;</command
> namesto <command
>&lt;potrditveno polje&gt;</command
>, ko sta na voljo samo dve možnosti. Primer tega je lahko: <quote
>Metoda izračuna: 'pearson'/'spearman'</quote
>. Tu si lahko predstavljamo več metod, ki v resnici ne tvorijo para nasprotij. </para>
		<para
>Izbira med <command
>&lt;radio&gt;</command
> in <command
>&lt;dropdown&gt;</command
> je večinoma vprašanje prostora. <command
>&lt;dropdown&gt;</command
> ima prednost, ker zavzame malo prostora, tudi če lahko izbirate med številnimi možnostmi. Po drugi strani pa ima <command
>&lt;radio&gt;</command
> to prednost, da so vse možne izbire vidne uporabniku hkrati, brez klikanja na spustno puščico. Na splošno, če lahko izbirate med šestimi ali več možnostmi, je bolje uporabiti <command
>&lt;dropdown&gt;</command
>. Če obstaja pet ali manj možnosti, je <command
>&lt;radio&gt;</command
> boljša izbira. </para>
	</sect2>
</sect1>
</chapter>

<chapter id="jstemplate">
<title
>Ustvarjanje &R; kode iz nastavitve &GUI;</title>
<sect1 id="sect_generating_R_code"
><title
>Uporaba &javascript; v &rkward; vtičnikih</title>
	<para
>Zdaj imamo &GUI; definiran, vendar moramo še vedno ustvariti nekaj &R; kode iz tega. Za to potrebujemo drugo besedilno datoteko, <filename
>code.js</filename
>, ki se nahaja v istem imeniku kot <link linkend="mainxml"
><filename
>description.xml</filename
></link
>. Morda poznate &javascript; (ali če smo tehnično natančni: ECMA-script). Dokumentacijo o JS je mogoče najti v izobilju, tako v tiskani obliki kot na internetu (&eg;: <ulink url="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide"
>https://developer. mozilla.org/en/Core_JavaScript_1.5_Guide</ulink
>). Toda za večino namenov vam sploh ne bo treba vedeti veliko o JS, saj bomo uporabljali le nekatere zelo osnovne funkcije. </para>
	<tip>
		<para
>Ko preberete to poglavje, si oglejte tudi <link linkend="rkwarddev"
><application
>rkwarddev</application
> paket</link
>. Zagotavlja nekaj &R; funkcij za ustvarjanje &javascript; kode, ki se pogosto uporablja v &rkward;. Prav tako lahko samodejno zazna spremenljivke, uporabljene v vtičniku &XML; datoteko in ustvarite osnovni &javascript; kodo iz tega, s katero lahko začnete. </para>
	</tip>
	<note>
		<para
>Predpostavlja se, da so datoteke vtičnika <literal role="extension"
>.js</literal
> kodirane z UTF-8. Ne pozabite preveriti kodiranja urejevalnika, če uporabljate znake, ki niso ascii. </para>
	</note>
	<para
>Za t-test z dvema spremenljivkama je datoteka <filename
>code.js</filename
> videti takole (z vmesnimi komentarji): </para>
	<sect2 id="sect_JS_preprocess"
><title
>preprocess()</title>
		<programlisting
>function preprocess () {
}
                </programlisting>
		<para
>Datoteka JS je organizirana v tri ločene funkcije: <function
>preprocess()</function
>, <function
>calculate()</function
> in <function
>printout()</function
>. To je zato, ker ni potrebna vsa koda na vseh stopnjah. Trenutno se funkcija predprocesa na mnogih mestih res ne uporablja (običajno jo boste v celoti izpustili). </para>
	</sect2>
	<sect2 id="sect_JS_calculate"
><title
>calculate()</title>
		<programlisting
>function calculate () {
        echo ('res &lt;- t.test (x=' + getString ("x") + ', y=' + getString ("y") + ', hypothesis="' + getString ("hypothesis") + '"' + getString ("varequal"));
        var conflevel = getString ("conflevel");
        if (conflevel != "0.95") echo (', conf.level=' + conflevel);
        echo (')\n');
}
                </programlisting>
		<para
>Ta funkcija ustvari dejansko &R; sintakso, ki se izvaja iz &GUI; nastavitev. Oglejmo si to podrobno: Koda, ki jo je treba uporabiti, je ustvarjena s stavkom <function
>echo()</function
>. Če pogledamo stavek <function
>echo()</function
> korak za korakom, je prvi del tega </para>
		<screen
>res &lt;- t.test (
                </screen>
		<para
>kot golo besedilo. Nato moramo izpolniti vrednost, uporabnika, izbranega kot prvo spremenljivko. To pridobimo s pomočjo <function
>getString ("x")</function
> in ga dodamo nizu, ki ga odmevamo <quote
>echoed</quote
>. To natisne vrednost &GUI;-elementa z <parameter
>id=</parameter
><replaceable
>"x"</replaceable
>: naš prvi <command
>&lt;checkbox&gt;</command
>. Nato dodamo ', ' in naredimo isto, da pridobimo vrednost elementa <replaceable
>"y"</replaceable
> - drugi <command
>&lt;checkbox&gt;</command
>. Za hipotezo (skupina <command
>&lt;radio&gt;</command
>) in enake variance <command
>&lt;checkbox&gt;</command
> je postopek zelo podoben. </para>
		<para
>Upoštevajte, da lahko namesto združevanja izhodnih izrezkov s <quote
>+</quote
> uporabite tudi več stavkov <function
>echo()</function
>. Vse je natisnjeno v eni vrstici. Če želite ustvariti prelom vrstice v ustvarjeni kodi, vstavite <replaceable
>"\n"</replaceable
> v odmevani niz. Teoretično lahko ustvarite celo veliko vrstic z enim stavkom echo, vendar naj bo le ena vrstica (ali manj) generirane kode na <function
>echo()</function
>. </para>
		<note>
			<para
>Poleg <function
>getString()</function
> obstajajo tudi funkcije <function
>getBoolean()</function
>, ki bodo poskušale vrniti vrednost kot logično (primerno za uporabo v <function
>if()</function
>-statement) in <function
>getList()</function
>, ki bo poskušal vrniti seznamom podobne podatke v JS <function
>Array()</function
>. Kasneje bomo pokazali primere teh.</para>
			<para
>Ko si ogledujete obstoječe vtičnike, boste našli tudi veliko vtičnikov, ki uporabljajo <function
>getValue()</function
> namesto <function
>getString()</function
> in dejansko sta <emphasis
>skoraj</emphasis
> enaka. Vendar je uporaba <function
>getString()</function
>, <function
>getBoolean()</function
> in <function
>getList()</function
> priporočena praksa od različice 0.6.1. </para>
		</note>
		<para
>Za raven zaupanja postane malo bolj težavno. Zaradi estetike ne želimo izrecno določiti stopnje zaupanja, ki naj se uporabi, če ustreza privzeti vrednosti. Zato namesto brezpogojnega tiskanja vrednosti najprej pridobimo v spremenljivki. Nato preverimo, ali se ta spremenljivka razlikuje od <replaceable
>"0,95"</replaceable
>, in če se, natisnemo dodatni argument. Nazadnje ponovimo zaključni oklepaj in prelom vrstice: <replaceable
>")\n"</replaceable
>. To je vse za funkcijo izračuna. </para>
	</sect2>
	<sect2 id="sect_JS_printout"
><title
>printout()</title>
		<programlisting
>function printout () {
        echo ('rk.header (' + i18n ("Two Variable t-Test") + ')\n');
        echo ('rk.print (res)\n');
}
                </programlisting>
		<para
>In to je bilo v večini primerov vse, kar je pri funkciji tiskanja. <function
>rk.header()</function
> natisne standardni naslov za rezultate. Upoštevajte, da morate v datotekah <literal role="extension"
>.js</literal
> ročno označiti vse nize, ki jih je mogoče prevesti, z uporabo <command
>i18n()</command
> ali nekaterih drugih ukazov. Več o tem v <link linkend="i18n_js"
>poglavju o internacionalizaciji</link
>. Temu lahko dodate še nekaj informacij, če želite, &eg;: </para>
		<programlisting
>function printout () {
        new Header (i18n ("Two Variable t-Test"))
                  .addFromUI ("varequal")
                  .add (i18n ("Confidence level"), getString ("conflevel"))  // Note: written like this for illustration purposes. More automatic:
        //        .addFromUI ("conflevel")
                  .print ();
echo ('rk.print (res)\n');
}
                </programlisting>
		<para
><function
>rk.print()</function
> uporablja paket R2HTML za zagotavljanje &HTML; formatiranega izhoda. Druga koristna funkcija je <function
>rk.results()</function
>, ki lahko izpiše tudi različne vrste tabel rezultatov. Če ste v dvomih, preprosto uporabite <function
>rk.print()</function
> in zaključite. Razred JS <function
>Header</function
> je pomočnik na ravni JS za generiranje klica <function
>rk.header()</function
> (samo poglejte ustvarjeno kodo &R;). V nekaterih primerih boste morda želeli neposredno poklicati <function
>echo ('rk.header (...)')</function
>, da natisnete glavo za vaš izhod. </para>
		<para
>Upoštevajte, da je interno izhod le navaden &HTML; dokument v tem trenutku. Zato vas bo morda zamikalo dodati &HTML; z uporabo <function
>rk.cat.output()</function
>. Čeprav bo to delovalo, tega ne počnite. Izhodni format se lahko v prihodnosti spremeni (&eg; v ODF), zato je najbolje, da &HTML; določeno kodo. Raje poenostavite stvari s <function
>rk.header()</function
>, <function
>rk.print()</function
>, <function
>rk.results()</function
> in - če je potrebno - - <function
>rk.print.literal()</function
>. Če se zdi, da ne izpolnjujejo vaših potreb po oblikovanju, se za pomoč obrnite na nas na poštnem seznamu. </para>
		<para
>čestitke! Ustvarili ste svoj prvi vtičnik. Preberite v naslednjih poglavjih za naprednejše koncepte. </para>
	</sect2>
</sect1>

<sect1 id="jsconventions">
<title
>Konvencije, politike in ozadje</title>
	<para
>Obstaja veliko načinov za pisanje &R; kode za določeno nalogo in obstaja še več načinov za ustvarjanje te &R; kode iz JS. Kako točno boste to storili, je prepuščeno vam. Kljub temu morate upoštevati številne vidike in osnovne informacije, ki jih morate razumeti. </para>

	<sect2 id="policylocal">
	<title
>Razumevanje okolja <function
>local()</function
></title>
		<para
>Pogosteje boste morali ustvariti enega ali več začasnih &R; predmetov v kodi, ki jo ustvari vaš vtičnik. Običajno ne želite, da so postavljeni v delovni prostor uporabnika, saj lahko celo prepišejo uporabniške spremenljivke. Zato se vsa koda, ustvarjena z vtičnikom, izvaja v okolju <function
>local()</function
> (glejte &R; stran s pomočjo za funkcijo <function
>local()</function
>). To pomeni, da so vse spremenljivke, ki jih ustvarite, začasne in ne bodo trajno shranjene. </para>
		<para
>Če uporabnik izrecno zahteva shranjevanje spremenljivke, boste morali temu objektu dodeliti z uporabo <function
>.GlobalEnv$objectname &lt;- value</function
>. Na splošno ne uporabljajte operatorja <function
>&lt;&lt;-</function
>. Ni nujno, da bo dodelil v .GlobalEnv. </para>
		<para
>Ena pomembna past je uporaba <function
>eval()</function
>. Tukaj morate upoštevati, da bo eval privzeto uporabil trenutno okolje za vrednotenje, &ie; lokalnega. To bo večinoma dobro delovalo, vendar ne vedno. Torej, če morate uporabiti <function
>eval()</function
>, boste verjetno želeli podati parameter <parameter
>envir</parameter
>: <function
>eval(..., envir=globalenv()</function
>). </para>
	</sect2>

	<sect2 id="policyformatting">
	<title
>Oblikovanje kode</title>
		<para
>Najpomembnejša stvar je za vaše ustvarjene &R; kode za delo, vendar mora biti tudi enostavna za branje. Zato bodite pozorni tudi na oblikovanje. Nekaj premislekov: </para>
		<para
>Normalna najvišja raven &R; stavki morajo biti levo poravnani. </para>
		<para
>Stavki v spodnjem bloku morajo biti zamaknjeni z enim tabulatorjem (glejte primer spodaj). </para>
		<para
>Če delate zelo zapletene izračune, tu in tam dodajte komentar, npr. za označevanje logičnih odsekov. Upoštevajte, da obstaja posebna funkcija <command
>comment()</command
> za vstavljanje prevedljivih komentarjev v ustvarjeno kodo. </para>
		<para
>Na primer, ustvarjena koda je lahko videti takole. Enako kodo brez zamikov ali komentarjev bi bilo precej težko brati, kljub skromni zapletenosti: </para>
		<programlisting
># first determine the wobble and rotation
my.wobble &lt;- wobble (x, y)
my.rotation &lt;- wobble.rotation (my.wobble, z)

# boggling method needs to be chosen according to rotation
if (my.rotation &gt; wobble.rotation.limit (x)) {
        method &lt;- "foo"
        result &lt;- boggle.foo (my.wobble, my.rotation)
} else {
        method &lt;- "bar"
        result &lt;- boggle.bar (my.wobble, my.rotation)
}
                </programlisting>
	</sect2>

	<sect2 id="policysimplicity">
	<title
>Ukvarjanje s kompleksnimi možnostmi</title>
		<para
>Številni vtičniki lahko naredijo več kot eno stvar. Na primer, vtičnik <quote
>Descriptive Statistics</quote
> lahko izračuna povprečje, obseg, vsoto, produkt, mediano, dolžino &etc;. Vendar pa se bo uporabnik običajno odločil, da izvede le nekatere od teh izračunov. V tem primeru poskusite ohraniti ustvarjeno kodo čim bolj preprosto. Vsebovati mora samo dele, ki so pomembni za možnosti, ki so dejansko izbrane. Da bi to dosegli, je tukaj primer običajnih oblikovalskih vzorcev, kot bi jih uporabili (v JS; tukaj bi bili »domean«, »domedian« in »dosd« elementi &lt;checkbox&gt;): </para>
		<programlisting
>function calculate () {
        echo ('x &lt;- &lt;' + getString ("x") + ')\n');
        echo ('results &lt;- list ()\n');

        if (getBoolean ("domean.state")) echo ("results$" + i18n ("Mean value") + " &lt;- mean (x)\n");
        if (getBoolean ("domedian.state")) echo ("results$" + i18n ("Median") + " &lt;- median (x)\n");
        if (getBoolean ("dosd.state")) echo ("results$" + i18n ("Standard deviation") + " &lt;- sd (x)\n");
        //...
}
                </programlisting>
	</sect2>
</sect1>

<sect1 id="jstips">
<title
>Namigi in triki</title>
	<para
>Tukaj je nekaj izbranih trikov, s katerimi bo pisanje vtičnikov manj dolgočasno: </para>
	<para
>Če potrebujete vrednost &GUI; nastavitev na več mestih v vašem vtičnikukodo, razmislite o dodelitvi spremenljivki v JS in uporabi tega namestopridobivanje vedno znova z <function
>getString()/getBoolean()/getList()</function
>. To je hitreje,bolj berljivo in hkrati manj tipkanja: </para>
	<programlisting
>function calculate () {
        var narm = "";        // na.rm=FALSE is the default in all functions below
        if (getBoolean ("remove_nas")) {
                $narm = ", na.rm=TRUE";
        }
        // ...
        echo ("results$foo &lt;- foo (x" + narm + ")\n");
        echo ("results$bar &lt;- bar (x" + narm + ")\n");
        echo ("results$foobar &lt;- foobar (x" + narm "\n");
        // ...
}
        </programlisting>
	<para
>Preprosta pomožna funkcija <function
>makeOption()</function
> lahko to stori tako, da je v mnogih primerih lažje izpustiti parametre, ki so na privzeti vrednosti,  </para>
	<programlisting
>function calculate () {
        var options
        //...
        // This will do nothing, if VALUE is 0.95 (the default). Otherwise it will append ', conf.int=VALUE' to options.
        options += makeOption ("conf.int", getString ("confint"), "0.95");
        //...
}
        </programlisting>
</sect1>
</chapter>

<chapter id="pluginhelp">
	<title
>Pisanje strani s pomočjo</title>
	<para
>Ko vaš vtičnik v bistvu deluje, je prišel čas, da zagotovite stran s pomočjo.Čeprav običajno ne boste želeli razložiti vseh temeljnih konceptov vglobino, boste morda želeli dodati še kakšno razlago za nekatere možnosti,in povezavo do povezanih vtičnikov in &R; funkcije. </para>
	<tip>
		<para
>Ko preberete to poglavje, si oglejte <link linkend="rkwarddev"
><application
>rkwarddev</application
> paket</link
> tudi. Zagotavlja nekaj &R; funkcij za ustvarjanje večine &rkward;-jevih &XML; oznake za vas. Prav tako lahko ustvari osnovno okostje datoteke pomoči iz obstoječega vtičnika &XML; datoteke, s katerimi lahko začnete. </para>
	</tip>
	<para
>Morda se spomnite, da ste to vstavili v svoj vtičnik &XML; (če niste dali to notri, naredite to zdaj): </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;help file="filename.rkh" /&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>Kjer bi očitno zamenjali <filename
>ime datoteke</filename
> z bolj primernim imenom. Zdaj je čas, da ustvarite to <literal role="extension"
>.rkh</literal
>. Tukaj je samoopisni primer: </para>
	<programlisting
>&lt;!DOCTYPE rkhelp&gt;
&lt;document&gt;
        &lt;summary&gt;
In this section, you will put some short, very basic information about what the plugin does.
This section will always show up on the very top of the help page.
        &lt;/summary&gt;

        &lt;usage&gt;
The usage section may contain a little more practical information. It does not explain all
the settings in detail (that is done in the "settings" section), however.

To start a new paragraph, insert an empty line, as shown above.
This line, in contrast, will be in the same paragraph.

In all sections you can insert some simple HTML code, such as &lt;b&gt;bold&lt;/b&gt; or
&lt;i&gt;italic&lt;/i&gt; text. Please keep formatting to the minimum needed, however.

The usage section is always the second section shown in a help page.
        &lt;/usage&gt;

        &lt;section id="sectionid" title="Generic section" short_title="Generic"&gt;
If you need to, you can add additional sections between the usage and settings sections.
However, usually, you will not need this while documenting plugins. The "id"-attribute
provides an anchor point to jump to this section from the navigation menu. The "short_title"
attribute provides a short title to use in the navigation bar. This is optional, by default
the main "title" will be used both as a heading to the section, and as the link name in the
navigation bar.

In any section you may want to insert links to further information. You do this by adding

&lt;link href="URL"&gt;link name&lt;/link&gt;

Where URL could be an external link such as https://rkward.kde.org .
Several special URLs are supported in the help pages:

&lt;link href="rkward://page/path/page_id"/&gt;

This links to a top level rkward help page (not for a plugin).

&lt;link href="rkward://component/[namespace/]component_id"/&gt;

This links to the help page of another plugin. The [namespace/] part may be omitted
(in this case, rkward is assumed as the standard namespace, e.g.:
&lt;link href="rkward://component/import_spss"/&gt; or
&lt;link href="rkward://component/rkward/import_spss"/&gt; are equivalent).
The component_id is the same that you specified in the <link linkend="pluginmap"
>&pluginmap;</link
>.

&lt;link href="rkward://rhelp/rfunction"/&gt;

Links to the &R; help page on "rfunction".

Note that the link names will be generated automatically for these types of links.
        &lt;/section&gt;

        &lt;settings&gt;
                &lt;caption id="id_of_tab_or_frame"/&gt;
                &lt;setting id="id_of_element"&gt;
Description of the GUI element identified by the given id
                &lt;/setting&gt;
                &lt;setting id="id_of_elementb" title="description"&gt;
Usually the title of the GUI element will be extracted from the
<link linkend="mainxml"
>&XML; definition of the plugin</link
>, automatically. However,
for some GUI elements, this description may not be enough to identify them, reliably.
In this case, you can add an explicit title using the "title" attribute.
                &lt;/setting&gt;
                &lt;setting id="id_of_elementc"&gt;
Description of the GUI element identified by "id_of_elementc"
                &lt;/setting&gt;
                [...]
        &lt;/settings&gt;

        &lt;related&gt;
The related section typically just contains some links, such as:

&lt;ul&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/mean"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/median"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://component/related_component"/&gt;&lt;/li&gt;
&lt;/ul&gt;
        &lt;/related&gt;

        &lt;technical&gt;
The technical section (optional, always last) may contain some technical details of the plugin
implementation, which are of interest only to RKWard developers. This is particularly relevant
for plugins that are designed to be embedded in many other plugins, and could detail, which
options are available to customize the embedded plugin, and which code sections contain which
R code.
        &lt;/technical&gt;
&lt;/document&gt;
        </programlisting>
</chapter>


<chapter id="logic">
<title
>Logične interakcije med &GUI; elementi</title>
<sect1 id="sect_GUI_logic"
><title
>&GUI; logic</title>
	<para
>Vsi osnovni koncepti ustvarjanja vtičnika za &rkward; so bili opisani v prejšnjih poglavjih. Ti osnovni koncepti bi morali zadoščati za številne - če ne večino - primerov. Vendar včasih želite več nadzora nad tem, kako se obnaša &GUI; vašega vtičnika; </para>
	<para
>Na primer, recimo, da želite razširiti primer t-testa, uporabljen v tej dokumentaciji, da omogočite oboje: primerjavo spremenljivke z drugo spremenljivko (kot je prikazano) in primerjavo spremenljivke s konstantno vrednostjo. Eden od načinov za to bi bil dodati radijsko krmiljenje, ki preklaplja med obema načinoma, in dodajanje vrtilnega polja za vnos konstantne vrednosti za primerjavo. Razmislite o tem poenostavljenem primeru: </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
&lt;document&gt;
        &lt;code file="code.js"/&gt;

        &lt;dialog label="T-Test"&gt;
                &lt;row&gt;
                        &lt;varselector id="vars"/&gt;
                        &lt;column&gt;
                                &lt;varslot id="x" types="number" source="vars" required="true" label="compare"/&gt;
                                &lt;radio id="mode" label="Compare against"&gt;
                                        &lt;option value="variable" checked="true" label="another variable (select below)"/&gt;
                                        &lt;option value="constant" label="a constant value (set below)"/&gt;
                                &lt;/radio&gt;
                                &lt;varslot id="y" types="number" source="vars" required="true" label="variable" i18n_context="Noun; a variable"/&gt;
                                &lt;spinbox id="constant" initial="0" label="constant" i18n_context="Noun; a constant"/&gt;
                        &lt;/column&gt;
                &lt;/row&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Zaenkrat je vse v redu, vendar obstajajo številne težave s tem &GUI;. Prvič, tako varslot kot spinbox sta vedno prikazana, medtem ko je samo eden od obeh resnično uporabljen. Še huje, varslot vedno zahteva veljavno izbiro, tudi če primerjate s konstanto. Očitno, če ustvarimo večnamenski &GUI; kot je ta, želimo več prilagodljivosti. Vnesite: razdelek <command
>&lt;logic&gt;</command
> (vstavljen na isti ravni kot <command
>&lt;code&gt;</command
>, <command
>&lt;dialog&gt;</command
> ali <command
> &lt;wizard&gt;</command
>). </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;

        &lt;logic&gt;
                &lt;convert id="varmode" mode="equals" sources="mode.string" standard="variable" /&gt;

                &lt;connect client="y.visible" governor="varmode" /&gt;
                &lt;connect client="constant.visible" governor="varmode.not" /&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>Prva vrstica znotraj logičnega razdelka je oznaka <command
>&lt;convert&gt;</command
>. V bistvu to zagotavlja novo logično (vklopljeno ali izklopljeno, resnično ali napačno) lastnost, ki jo je mogoče uporabiti pozneje. Ta lastnost (<replaceable
>"varmode"</replaceable
>) je resnična, kadar je izbran zgornji izbirni gumb, in napačna, ko je izbran spodnji izbirni gumb. Kako se to naredi? </para>
	<para
>Najprej so pod <parameter
>sources</parameter
> navedene lastnosti vira, na katerih je treba delati (v tem primeru vsaka samo po ena; navedete jih lahko več kot <parameter
>sources=</parameter
><replaceable
>"mode.string; somethingelse"</replaceable
>, potem bi bil <replaceable
>"varmode"</replaceable
> resničen le, če sta oba <replaceable
>"mode.string"</replaceable
> in <replaceable
>"somethingelse"</replaceable
> enaka na niz <replaceable
>"variable"</replaceable
>). Upoštevajte, da v tem primeru ne pišemo le <replaceable
>"mode"</replaceable
> (kot bi v <function
>getString("mode")</function
>), ampak <replaceable
>"mode.string"</replaceable
>. To je pravzaprav interni način delovanja radijskega krmilnika: ima lastnost <quote
>string</quote
>, ki hrani svojo vrednost niza. <function
>getString("mode")</function
> je samo okrajšava in enakovredno <function
>getString("mode.string")</function
>. Oglejte si referenco za vse lastnosti različnih &GUI; elementi. </para>
	<para
>Drugič, način pretvorbe nastavimo na <parameter
>mode=</parameter
><replaceable
>"equals"</replaceable
>. To pomeni, da želimo preveriti, ali je vir(i) enak(i) določeni vrednosti. Končno je standard vrednost za primerjavo, zato s <parameter
>standard=</parameter
><replaceable
>"variable"</replaceable
> preverimo, ali je lastnost <replaceable
>"mode.string"</replaceable
> enaka na niz <replaceable
>"variable"</replaceable
> (vrednost zgornje radijske možnosti). Če je enako, potem je lastnost varmode resnična, drugače je napačna. </para>
	<para
>Zdaj pa k pravim stvarem: <command
>&lt;connect&gt;</command
> lastnost <replaceable
>"varmode"</replaceable
> povežemo z y.visible, ki nadzira, ali varslot <replaceable
>"y"</replaceable
> je prikazan ali ne. Upoštevajte, da kateri koli element, ki je neviden, implicitno ni potreben. Torej, če je izbrana zgornja radijska možnost, je varslot <replaceable
>"y"</replaceable
> zahtevan in viden. Sicer ni zahtevana in skrita. </para>
	<para
>Za spinbox želimo ravno obratno. Na srečo za to ne potrebujemo drugega <command
>&lt;convert&gt;</command
>: logične lastnosti je mogoče zelo enostavno zanikati z dodajanjem modifikatorja <replaceable
>"not"</replaceable
>, zato <command
>&lt;connect&gt;</command
> <replaceable
>"varmode.not"</replaceable
> z lastnostjo vidnosti spinboxa. V bistvu je bodisi varslot prikazan in zahtevan, <emphasis
>ali</emphasis
> spinbox je prikazan in zahtevan - odvisno od tega, katera možnost je izbrana v radijskem nadzoru. &GUI; se spreminja glede na možnost radia. Poskusite primer, če želite. </para>
	<para
>Za celoten seznam lastnosti glejte <link linkend="reference"
>referenco</link
>. Še ena lastnost pa je posebna v tem, da vsi &GUI; elementi imajo to: <quote
>omogočeno</quote
>. To je nekoliko manj drastično kot <quote
>vidno</quote
>. Ne prikaže/skrije &GUI; element, ampak ga samo omogoči/onemogoči. Onemogočeni elementi so običajno prikazani sivo in se ne odzivajo na uporabniški vnos. </para>
	<note>
		<para
>Poleg <command
>&lt;convert&gt;</command
> in <command
>&lt;connect&gt;</command
> obstaja več dodatnih elementov za uporabo v razdelku <command
>&lt;logic&gt;</command
>. Npr. pogojne konstrukcije je mogoče implementirati tudi z uporabo elementa <command
>&lt;switch&gt;</command
>. Za podrobnosti glejte <link linkend="logicelements"
>referenco o logičnih elementih</link
>.</para>
	</note>
</sect1>
<sect1 id="logic_scripted">
<title
>Skriptirana &GUI; logika</title>
	<para
>Medtem ko je povezovanje lastnosti, kot je opisano zgoraj, pogosto dovolj, je včasih bolj prilagodljivo ali bolj priročno uporabiti JS za skript &GUI; logiko. Na ta način bi lahko zgornji primer prepisali kot: </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;
'
        &lt;logic&gt;
                &lt;script&gt;&lt;![CDATA[
                        // ECMAScript code in this block
                        // the top-level statement is only called once
                        gui.addChangeCommand ("mode.string", "modeChanged ()");

                        // this function is called whenever the "mode" was changed
                        modeChanged = function () {
                                var varmode = (gui.getString ("mode.string") == "variable");
                                gui.setValue ("y.enabled", varmode);
                                gui.setValue ("constant.enabled", !varmode);
                        }
                ]]&gt;&lt;/script&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>Prva vrstica kode pove &rkward; za klic funkcije <function
>modeChanged()</function
> vsakič, ko se spremeni vrednost izbirnega polja <parameter
>id=</parameter
><replaceable
>"mode"</replaceable
>. Znotraj te funkcije definiramo pomožno spremenljivko <replaceable
>"varmode"</replaceable
>, ki je true, ko je način <replaceable
>"variable"</replaceable
>, false, ker je <replaceable
>"constant"</replaceable
>. Nato uporabimo <function
>gui.setValue()</function
> za nastavitev <quote
>omogočenih</quote
> lastnosti <replaceable
>"y"</replaceable
> in <replaceable
>"constant"</replaceable
>, na povsem enak način, kot smo to storili prej z uporabo stavkov <command
>&lt;connect&gt;</command
>. </para>
	<para
>Skriptni pristop k &GUI; logika postane še posebej uporabna, ko želite spremeniti razpoložljivo možnost glede na vrsto predmeta, ki ga je izbral uporabnik. Oglejte si <link linkend="guilogic_functions"
>referenco</link
> za razpoložljive funkcije. </para>
	<para
>Upoštevajte, da je skriptni pristop k &GUI; logiko lahko zmešate s stavki <command
>&lt;connect&gt;</command
> in <command
>&lt;convert&gt;</command
>, če želite. Upoštevajte tudi, da oznaka <command
>&lt;script&gt;</command
> omogoča podajanje imena datoteke skripta poleg ali kot alternativo vstavljanju kode skripta. Običajno pa je najbolj priročna vdelava kode skripta, kot je prikazano zgoraj. </para>
</sect1>
</chapter>

<chapter id="embedding">
<title
>Vdelava vtičnikov v vtičnike</title>
<sect1 id="sect_embedding"
><title
>Primeri uporabe za vdelavo</title>
	<para
>Ko pišete vtičnike, boste pogosto ugotovili, da ustvarjate več vtičnikov, ki se razlikujejo le v nekaterih pogledih, vendar imajo veliko več skupnega. Na primer, za risanje obstaja več generičnih &R; možnosti, ki jih je mogoče uporabiti pri skoraj vseh vrstah grafikonov. Če ustvarite &GUI; in predloga JS za tiste vedno znova? </para>
	<para
>Očitno bi bilo to precej težav. Na srečo vam tega ni treba storiti. Namesto tega ustvarite skupno funkcionalnost enkrat, kasneje pa jo lahko vdelate v več vtičnikov. Pravzaprav je mogoče kateri koli vtičnik vdelati v kateri koli drug vtičnik, tudi če izvirni avtor vdelanega vtičnika nikoli ni pomislil, da bi nekdo želel svoj vtičnik vdelati v drugega. </para>
</sect1>
<sect1 id="embedding_dialog">
<title
>Vdelava znotraj pogovornega okna</title>
	<para
>OK, dovolj povedano. Kako deluje? Preprosto: preprosto uporabite oznako <command
>&lt;embed&gt;</command
>. Tukaj je skrajšan primer: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
                &lt;tab label="Plot Options" i18n_context="Options concerning the plot"&gt;
                        &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;/tab&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
        &lt;/tabbook&gt;
&lt;/dialog&gt;
        </programlisting>
	<para
>Tukaj se zgodi, da celoten &GUI; ali pa je vtičnik možnosti izrisa (seveda razen standardnih elementov, kot je gumb <guibutton
>Pošlji</guibutton
>  &etc;) vdelan neposredno v vaš vtičnik (poskusite!). </para>
	<para
>Kot lahko vidite, je sintaksa oznake <command
>&lt;embed&gt;</command
> dokaj preprosta. Kot večina elementov potrebuje <parameter
>id</parameter
>. Komponenta parametra določa, kateri vtičnik je treba vdelati, kot je definirano v mapi &pluginmap; datoteka (<replaceable
>"rkward::plot_options"</replaceable
> je rezultat veriženja imenskega prostora <quote
>rkward</quote
>, ločila <quote
>::</quote
> in imena komponente <quote
>plot_options</quote
>). </para>
</sect1>
<sect1 id="embedding_code">
<title
>Generiranje kode pri vdelavi</title>
	<para
>Zaenkrat je vse v redu, kaj pa ustvarjena koda? Kako sta koda za vdelavo in vdelani vtičnik združena? V kodo JS vtičnika za vdelavo preprosto napišite nekaj takega: </para>
	<programlisting
>function printout () {
        // ...
        echo ("myplotfunction ([...]" + getString ("plotoptions.code.printout"); + ")\n");
        // ...
}
        </programlisting>
	<para
>Torej v bistvu pridobivamo kodo, ki jo ustvari vdelani vtičnik, tako kot pridobivamo kateri koli drug &GUI; nastavitev. Tukaj lahko niz <replaceable
>"plotoptions.code.printout"</replaceable
> razčlenimo na: <quote
>Oddelek za izpis ustvarjene kode elementa z <parameter
>id</parameter
> plotoptions</quote
> (plotoptions je ID, ki smo ga dali za oznako <command
>&lt;embed&gt;</command
> zgoraj). In ja, če želite napreden nadzor, lahko celo pridobite vrednosti posameznih &GUI; elementov znotraj vdelanega vtičnika (vendar ne obratno, saj vdelani vtičnik ne ve ničesar o svoji okolici). </para>
</sect1>
<sect1 id="embedding_wizard">
<title
>Vdelava znotraj čarovnika</title>
	<para
>Če vaš vtičnik ponuja čarovnika &GUI;, vdelava v osnovi deluje na enak način. Na splošno boste uporabili: </para>
	<programlisting
>&lt;wizard [...]&gt;
                [...]
                &lt;page id="page12"&gt;
                        [...]
                &lt;/page&gt;
                &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;page id="page13"&gt;
                        [...]
                &lt;/page&gt;
                [...]
        &lt;/wizard&gt;
        </programlisting>
	<para
>Če vdelani vtičnik ponuja vmesnik čarovnika, bodo njegove strani vstavljene neposredno med <replaceable
>"page12"</replaceable
> in <replaceable
>"page13"</replaceable
> vašega vtičnika. Če vdelani vtičnik ponuja samo pogovorni vmesnik, bo med vašima stranema <replaceable
>"page12"</replaceable
> in <replaceable
>"page13"</replaceable
> dodana ena nova stran. Uporabnik ne bo nikoli opazil. </para>
</sect1>
<sect1 id="embedding_as_button">
<title
>Manj vdelana vdelava: gumb za nadaljnje možnosti</title>
	<para
>Čeprav je vdelava kul, pazite, da ne pretiravate. Preveč funkcij znotraj &GUI; le težko je najti ustrezne možnosti. Seveda boste včasih morda želeli vdelati veliko možnosti (kot so vse možnosti za <function
>plot()</function
>), a ker so te res izbirne, jih ne želite izpostaviti v svojem &GUI;. </para>
	<para
>Druga možnost je vdelava teh možnosti <quote
>kot gumb</quote
>: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                [...]
                &lt;tab label="Options"&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Specify plotting options"/&gt;
                &lt;/tab&gt;
                [...]
        &lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
	<para
>V tem primeru bo vašemu vtičniku dodan en sam gumb z oznako <guibutton
>Določi možnosti izrisa</guibutton
>. Ko pritisnete ta gumb, se prikaže ločeno pogovorno okno z vsemi možnostmi vdelanega vtičnika. Čeprav ta vdelani &GUI; večino časa ni viden, lahko njegove nastavitve pridobite tako, kot je opisano <link linkend="embedding_code"
>zgoraj</link
>. </para>
	<para>
		<caution>
			<para
>Verjetno bi se moral pristop <quote
>gumba</quote
> uporabljati le za vtičnike, ki nikoli ne morejo biti neveljavni (za manjkajoče/slabe nastavitve). Sicer uporabnik ne bi mogel oddati kode, ampak bi jo težko ugotovil, saj se vzrok za to skriva za nekim gumbom. </para
>	
		</caution>
	</para>
</sect1>
<sect1 id="embedding_incomplete">
<title
>Vdelava/definiranje nepopolnih vtičnikov</title>
	<para
>Nekateri vtičniki – in pravzaprav je plot_options, uporabljen kot zgornji primer, eden izmed njih – sami po sebi niso popolni. Preprosto nimajo &GUI; elementov za izbiro nekaterih pomembnih vrednosti. Namenjeni so samo uporabi kot vdelani v druge vtičnike. </para>
	<para
>V kolikšni meri je vtičnik plot_options nepopoln? No, za nekatere nastavitve možnosti mora poznati imena predmetov/izrazov za osi x in y (pravzaprav bo v redu, če ima samo eno od obeh, vendar za pravilno delovanje potrebuje vsaj enega). Vendar pa nima mehanizma za izbiro teh predmetov ali vnos na kakršen koli drug način. Kako torej ve zanje? </para>
	<para
>V logičnem razdelku vtičnika plot_options sta dve dodatni vrstici, ki še nista zajeti: </para>
	<programlisting
>&lt;logic&gt;
                &lt;external id="xvar" /&gt;
                &lt;external id="yvar" /&gt;

                [...]
        &lt;/logic&gt;
        </programlisting>
	<para
>To definira dve dodatni lastnosti v vtičniku plot_options, katerih edini namen je povezava z nekaterimi (še neznanimi) lastnostmi vtičnika za vdelavo. V vtičniku plot_options se ti dve lastnosti preprosto uporabljata kot vse druge in na primer obstajajo klici <function
>getString("xvar")</function
> v predlogi plot_options JS. </para>
	<para
>Zdaj za nepopoln vtičnik ni mogoče vedeti, kam bo vdelan in kako se bodo imenovale ustrezne nastavitve v vtičniku za vdelavo. Zato moramo dodati tudi dve dodatni vrstici v logičnem razdelku vtičnika za vdelavo: </para>
	<programlisting
>&lt;logic&gt;
                [...]

                &lt;connect client="plotoptions.xvar" governor="xvarslot.available" /&gt;
                &lt;connect client="plotoptions.yvar" governor="yvarslot.available" /&gt;
        &lt;/logic&gt;
        </programlisting>
	<para
>To načeloma ni nič novega, obravnavali smo stavke <command
>&lt;connect&gt;</command
> v <link linkend="logic"
>poglavju &GUI; logika</link
>. Preprosto povežete vrednosti v dveh varlotih (imenovanih <replaceable
>"xvarslot"</replaceable
> in <replaceable
>"yvarslot"</replaceable
> v tem primeru) s sprejemnimi <quote
>zunanjimi</quote
> lastnostmi vdelanega vključiti. To je to. Za vse ostalo je samodejno poskrbljeno. </para>
</sect1>
</chapter>

<chapter id="plugin_series">
<title
>Ukvarjanje s številnimi podobnimi vtičniki</title>
<sect1 id="sect_similar_plugins"
><title
>Pregled različnih pristopov</title>
	<para
>Včasih boste morda želeli razviti vtičnike za vrsto podobnih funkcij. Kot primer upoštevajte distribucijske ploskve. Ti generirajo precej podobno kodo, seveda pa je zaželeno, da so grafični vmesniki med seboj podobni. Končno so lahko veliki deli datotek pomoči enaki. Le nekaj parametrov se razlikuje za vsak vtičnik. </para>
	<para
>Naiven pristop k temu je razviti en vtičnik, nato pa kopirati in prilepiti celotno vsebino <literal role="extension"
>.js</literal
>, <literal role="extension"
>.xml</literal
> in <literal role="extension"
>.rkh</literal
>, nato spremenite nekaj delov, ki se razlikujejo. Kaj pa, če čez nekaj časa najdete napako v črkovanju, ki je bila kopirana in prilepljena v vse vtičnike? Kaj pa, če želite dodati podporo za novo funkcijo? Ponovno bi morali obiskati vse vtičnike in spremeniti vsakega posebej. Utrujajoč in dolgočasen proces. </para>
	<para
>Drugi pristop bi bil uporaba <link linkend="embedding"
>vdelave</link
>. Vendar v nekaterih primerih to ni primerno za obravnavano težavo, večinoma zato, ker so <quote
>kosi</quote
>, ki jih lahko vdelate, včasih preveliki, da bi bili uporabni, in postavlja nekatere omejitve na postavitev. Za te primere so koncepti <link linkend="include_js"
>vključno z datotekami <literal role="extension"
>.js</literal
></link
>, <link linkend="include_xml"
>vključno z <literal role="extension"
>.xml</literal
></link
> in <link linkend="snippets"
>delčki</link
> so lahko zelo uporabni (vendar si oglejte <link linkend="include_snippets_vs_embedding"
>razmišljanja o tem, kdaj je bolje uporabi vdelavo</link
>). </para>
	<para
>Ena beseda previdnosti, preden začnete z branjem: ti koncepti lahko pomagajo poenostaviti delo s številnimi podobnimi vtičniki in lahko izboljšajo vzdržljivost in berljivost teh vtičnikov. Vendar lahko pretiravanje zlahka privede do nasprotnega učinka. Uporabljajte z nekaj previdnosti. </para>
</sect1>
<sect1 id="include_js">
<title
>Uporaba stavka JS include</title>
	<para
>Eno skriptno datoteko lahko preprosto vključite v druge &rkward; vtičnike. Vrednost tega postane takoj očitna, če so nekateri deli vaše kode JS podobni med vtičniki. Te razdelke lahko preprosto definirate v ločeni datoteki <literal role="extension"
>.js</literal
> in to vključite v vse datoteke <literal role="extension"
>.js</literal
> vtičnika. Na primer kot v: </para>
	<programlisting
>// this is a file called "common_functions.js"

function doCommonStuff () {
        // perhaps fetch some options, etc.
        // ...
        comment ("This is R code you want in several different plugins\n");
        // ...
}
        </programlisting>
	<programlisting
>// this is one of your regular plugin <literal role="extension"
>.js</literal
> files

// include the common functions
include ("common_functions.js");

function calculate () {
        // do something
        // ...

        // insert the common code
        doCommonStuff ();
}
        </programlisting>
	<para
>Upoštevajte, da je včasih še bolj uporabno to obrniti in definirati <quote
>skelet</quote
> <function
>preprocess()</function
>, <function
>calculate()</function
> in <function
> funkcije printout()</function
> je običajna datoteka in naredi te povratne klice za tiste dele, ki se med vtičniki razlikujejo. Npr.:  </para>
	<programlisting
>// this is a file called "common_functions.js"

function calculate () {
        // do some things which are the same in all plugins
        // ...

        // add in something that is different across plugins
        getSpecifics ();

        // ...
}
        </programlisting>
	<programlisting
>// this is one of your regular plugin <literal role="extension"
>.js</literal
> files

// include the common functions
include ("common_functions.js");

// note: no calculate() function is defined in here.
// it in the common_functions.js, instead.

function getSpecifics () {
        // print some R code
}
        </programlisting>
	<para
>Ena težava, ki se je morate zavedati pri uporabi te tehnike, je obseg spremenljivk. Oglejte si priročnik JS o obsegih spremenljivk. </para>
	<para
>Ta tehnika se pogosto uporablja v vtičnikih za distribucijo CLT plot, zato boste morda želeli tam pogledati primere. </para>
</sect1>

<sect1 id="include_xml">
<title
>Vključno z datotekami <literal role="extension"
>.xml</literal
></title>
	<para
>V bistvu je ista funkcija vključevanja datotek na voljo tudi za uporabo v <literal role="extension"
>.xml</literal
>, &pluginmap; in datoteke <literal role="extension"
>.rkh</literal
>. Na katero koli mesto v teh datotekah lahko postavite oznako <command
>&lt;include&gt;</command
>, kot je prikazano spodaj. Učinek je, da celotna vsebina tega &XML; datoteka (če smo natančni: vse v oznaki <command
>&lt;document&gt;</command
> te datoteke) je vključeno dobesedno na tej točki v datoteki. Upoštevajte, da lahko vključite samo drugo datoteko&XML;. </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;include file="another_xml_file.xml"/&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>Atribut <parameter
>file</parameter
> je ime datoteke glede na imenik, v katerem se nahaja trenutna datoteka. </para>
</sect1>

<sect1 id="snippets">
<title
>Uporaba &lt;snippets&gt;</title>
	<para
>Medtem ko je vključevanje datotek, kot je prikazano v <link linkend="include_xml"
>prejšnjem razdelku</link
>, precej zmogljivo, postane najbolj uporabno, če se uporablja v kombinaciji z <command
>&lt;snippets&gt;</command
>. Izrezki so res manjši odseki, ki jih lahko vstavite na drugo mesto v datoteki. To najbolje ponazarja primer: </para>
	<programlisting
>&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;frame&gt;
                                &lt;text&gt;
                This will be inserted at two places in the GUI
                                &lt;/text&gt;
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;
        &lt;dialog label="test"&gt;
                &lt;column&gt;
                        &lt;insert snippet="note"/&gt;
                        [...]
                        &lt;insert snippet="note"/&gt;
                &lt;/column&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Zato delček definirate na enem mestu na vrhu datoteke &XML; datoteko in jo nato <command
>&lt;insert&gt;</command
> na poljubnem mestu(-ih). </para>
	<para
>Čeprav ta primer sam po sebi ni preveč uporaben, razmislite o kombinaciji z datoteko <command
>&lt;include&gt;</command
>d <literal role="extension"
>.xml</literal
>. Upoštevajte, da lahko v isto datoteko postavite tudi delčke za datoteko <literal role="extension"
>.rkh</literal
>. Tja bi preprosto <command
>&lt;include&gt;</command
> tudi datoteko in <command
>&lt;insert&gt;</command
> ustrezni snippet (delček): </para>
	<programlisting
>&lt;!-- This is a file called "common_snippets.xml" --&gt;
&lt;document&gt;
        &lt;snippet id="common_options"&gt;
                &lt;spinbox id="something" [...]/&gt;
                [...]
        &lt;/snippet&gt;
        &lt;snippet id="common_note"&gt;
                &lt;text&gt;An important note for this type of plugin&lt;/text&gt;
        &lt;/snippet&gt;

        &lt;snippet id="common_help"&gt;
                &lt;setting id="something"&gt;This does something&lt;/setting&gt;
                [...]
        &lt;/snippet&gt;
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- This is the .xml file of the plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;!-- Import the common snippets --&gt;
                &lt;include file="common_snippets.xml"/&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test2"&gt;
                &lt;insert snippet="common_note"/&gt;
                &lt;spinbox id="something_plugin_specific" [...] /&gt;
                &lt;insert snippet="common_options"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Podobno kot <link linkend="include_js"
>vključitev v JS</link
> je obratni pristop pogosto celo bolj uporaben: </para>
	<programlisting
>&lt;!-- This is a file called "common_layout.xml" --&gt;
&lt;document&gt;
        &lt;column&gt;
                &lt;insert snippet="note"&gt;
                [...]
                &lt;insert snippet="plugin_parameters"&gt;
        &lt;/column&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- This is the .xml file of the plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;text&gt;The note used for this specific plugin&lt;/text&gt;
                &lt;/snippet&gt;

                &lt;snippet id="plugin_parameters"&gt;
                        &lt;frame label="Parameters specific to this plugin"&gt;
                                [...]
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test3"&gt;
                &lt;include file="common_layout.xml"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Končno je možno tudi delčke <command
>&lt;insert&gt;</command
> v druge delčke, če: a) obstaja samo ena raven gnezdenja in b) ukaz <command
>&lt;snippets&gt;</command
> razdelek je postavljen na vrh datoteke (preden se vstavi ugnezdeni delček); to je zato, ker se stavki <command
>&lt;insert&gt;</command
> razrešijo od zgoraj navzdol. </para>
</sect1>

<sect1 id="include_snippets_vs_embedding">
<title
>&lt;include&gt; in &lt;snippets&gt; v primerjavi z &lt;embed&gt;</title>
	<para
>Na prvi pogled <command
>&lt;include&gt;</command
> in <command
>&lt;snippets&gt;</command
> nudita funkcionalnost, ki je precej podobna <link linkend="embedding"
>vdelavi</link
>: omogoča ponovno uporabo nekatere dele kode v vtičnikih. Kakšna je torej razlika med temi pristopi in kdaj bi morali uporabiti katerega? </para>
	<para
>Ključna razlika med tema pojmoma je, da so vgradljivi vtičniki bolj tesen sveženj. Združujejo celotno kodo &GUI; za ustvarjanje &R; kodo iz tega in stran s pomočjo. Nasprotno pa vključitev in vstavljanje omogočata veliko bolj natančen nadzor, vendar za ceno manjše modularnosti. </para>
	<para
>To pomeni, da vtičnik, ki vgrajuje drug vtičnik, običajno ne potrebuje veliko informacij o notranjih podrobnostih vdelanega vtičnika. Glavni primer je vtičnik plot_options. Vtičnikom, ki želijo to vdelati, ni nujno, da poznajo vse ponujene možnosti ali kako so na voljo. To je dobra stvar, saj bo sicer zaradi spremembe vtičnika plot_options morda treba prilagoditi vse vtičnike, ki to vdelujejo (veliko). Nasprotno pa vključi in vstavi resnično razkrije vse notranje podrobnosti in vtičniki, ki to uporabljajo, bodo na primer morali poznati natančne ID-je in morda celo vrsto uporabljenih elementov. </para>
	<para
>Zato velja pravilo naslednje: vključi in vstavi sta odlična, če sta ustrezni možnosti potrebni le za jasno omejeno skupino vtičnikov. Vgrajeni vtičniki so boljši, če skupina vtičnikov, za katere bi lahko bili koristni, ni jasno definirana in če je funkcionalnost mogoče enostavno modularizirati. Še eno pravilo: Če lahko skupne dele postavite v en sam <quote
>kos</quote
>, potem to storite in uporabite vdelavo. Če potrebujete veliko majhnih izrezkov za definiranje skupnih delov -- no, uporabite <command
>&lt;snippets&gt;</command
>. Končni pogled na to: če vsi vtičniki zagotavljajo <emphasis
>zelo</emphasis
> podobno funkcionalnost, sta vključitev in vstavljanje verjetno dobra ideja. Če si delita le enega ali dva skupna <quote
>modula</quote
>, je vdelava verjetno boljša. </para>
</sect1>
</chapter>

<chapter id="specialized_plugins">
<title
>Koncepti za uporabo v specializiranih vtičnikih</title>
<para
>To poglavje vsebuje informacije o nekaterih temah, ki so uporabne samo za določene razrede vtičnikov. </para>

<sect1 id="specialized_plugins_plots">
	<title
>Vtičniki, ki ustvarijo grafikon</title>
	<para
>Ustvarjanje grafikona iz vtičnika je preprosto. Vendar pa obstaja nekaj subtilnih težav, ki se jim morate izogniti, in tudi nekaj odličnih splošnih funkcij, ki se jih morate zavedati. Ta razdelek prikazuje osnovne koncepte in se zaključi s kanoničnim primerom, ki ga morate upoštevati pri ustvarjanju vtičnikov za grafikon. </para>
	<sect2 id="rk_graph_on">
		<title
>Risanje grafikona v izhodno okno</title>
		<para
>Če želite narisati grafikon v izhodno okno, uporabite <function
>rk.graph.on()</function
> neposredno pred ustvarjanjem grafa in <function
>rk.graph.off()</function
> neposredno zatem . To je podobno kot &eg; klic <function
>postscript()</function
> in <function
>dev.off()</function
> v navadni &R; seji. </para>
		<para
>Pomembno pa je, da morate <emphasis
>vedno</emphasis
> poklicati <function
>rk.graph.off()</function
> po klicu <function
>rk.graph.on()</function
>. V nasprotnem primeru bo izhodna datoteka ostala v pokvarjenem stanju. Če želite zagotoviti, da bo <function
>rk.graph.off()</function
> res klican, bi morali zaviti <emphasis
>vse</emphasis
> &R; ukaze med obema klicema v stavku <function
>try()</function
>. Še nikoli slišali za to? Brez skrbi, enostavno je. Vse kar morate storiti je, da sledite vzorcu, prikazanemu v <link linkend="plot_plugin_example"
>primeru</link
> spodaj. </para>
	</sect2>
	<sect2 id="preview_plots">
		<title
>Dodajanje funkcije predogleda</title>
		<note
><para
>Ta razdelek obravnava dodajanje funkcije predogleda vtičnikom, ki ustvarjajo grafikone. Obstajajo ločeni razdelki o <link linkend="preview_output"
>predogledih (&HTML;) izpisa</link
>, <link linkend="preview_data"
>predogledih (uvoženih) podatkov</link
> in <link linkend=" preview_custom"
>predogledi po meri</link
>. Vendar je priporočljivo, da najprej preberete ta razdelek, saj je pristop v vsakem primeru podoben.</para
></note>
		<para
>Zelo uporabna funkcija za vse vtičnike, ki ustvarjajo risbo/graf, je zagotoviti samodejno posodabljanje predogleda. Če želite to narediti, boste potrebovali dve stvari: dodati potrditveno polje <command
>&lt;preview&gt;</command
> v <link linkend="mainxml"
>&GUI; definicija</link
> in prilagajanje <link linkend="jstemplate"
>generirane kode</link
> za predogled. </para>
		<para
>Dodajanje potrditvenega polja <command
>&lt;preview&gt;</command
> je preprosto. Preprosto postavite naslednje nekam v &GUI;. Poskrbel bo za vso čarovnijo v zakulisju ustvarjanja naprave za predogled, posodabljanja predogleda vsakič, ko se spremenijo nastavitve &etc; Primer: </para>
		<note
><para
>Začenši z različico 0.6.5 &rkward; so elementi predogleda <command
>&lt;preview&gt;</command
> v pogovornih oknih vtičnikov (ne čarovnikov) označeni s posebnimi črkami: postavljeni bodo v stolpec z gumbi, ne glede na to, kje točno so definirani v uporabniškem vmesniku. Še vedno je dobra ideja, da jih definirate na smiselnem mestu v postavitvi zaradi združljivosti za nazaj. </para
></note>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;dialog [...]&gt;
                        [...]
                        &lt;preview id="preview"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>In to je to za &GUI; definicija. </para>
		<para
>Prilagajanje predloge JS je le malo več dela, tukaj se boste morali prepričati, da je ustvarjen samo sam grafikon in prikazan v napravi na zaslonu, namesto da bi bil usmerjen na izhod. tj. brez tiskanja glav, <function
>rk.graphics.on()</function
> ali podobnih klicev. Da bi vam pri tem pomagal, &rkward; bo poklical funkcije <function
>preprocess()</function
>, <function
>calculate()</function
> in <function
>printout()</function
> z dodatnim parametrom, ki je nastavljen na <parameter
>true</parameter
> pri generiranju kode za predogled. (Pri generiranju končne kode je parameter izpuščen. V javascriptu bo to ovrednoteno kot <parameter
>false</parameter
>, če bo uporabljeno znotraj stavka <function
>if</function
>.) Glejte <link linkend="plot_plugin_example" 
>primer</link
> spodaj za tipičen vzorec, ki ga boste uporabili. </para>
		<para
>Če pa potrebujete več nadzora, lahko namesto tega dodate novo funkcijo, imenovano <function
>preview()</function
>, v svojo predlogo JS in tam ustvarite kodo, potrebno za predogled (verjetno vsaj delno, spet s klicem <function
>calculate()</function
> itd.). </para>
	</sect2>
	<sect2 id="plot_options">
		<title
>Splošne možnosti grafikona</title>
		<para
>Opazili ste, da večina vtičnikov za risanje v &rkward; ponuja širok nabor generičnih možnosti &etc; za prilagajanje naslovov osi ali robov figur. Dodajanje teh možnosti v vaš vtičnik je enostavno. Zagotavlja jih vtičnik <link linkend="embedding"
>embeddable</link
>, imenovan <command
>rkward::plot_options</command
>. To vdelajte v uporabniški vmesnik vtičnika tako: </para>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;logic [...]&gt;
                        &lt;connect client="plotoptions.xvar" governor="x.available"/&gt;
                        &lt;set id="plotoptions.allow_type" to="true"/&gt;
                        &lt;set id="plotoptions.allow_ylim" to="true"/&gt;
                        &lt;set id="plotoptions.allow_xlim" to="false"/&gt;
                        &lt;set id="plotoptions.allow_log" to="false"/&gt;
                        &lt;set id="plotoptions.allow_grid" to="true"/&gt;
                &lt;/logic&gt;
                &lt;dialog [...]&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Plot Options"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>S tem boste v uporabniški vmesnik dodali gumb za prikaz okna z možnostmi grafikona.Logični del je samo primer. Omogoča vam določen nadzor nad vtičnik možnosti risanja. Preberite več na strani s pomočjo vtičnika plot_options (povezava na strani s pomočjo katerega koli vtičnika, ki ponuja splošne možnosti). </para>
		<para
>Nato se morate prepričati, da koda, ki ustreza vašim možnostim grafikona, doda ustvarjeno kodo za vaš  grafikon. Če želite to narediti, pridobite lastnosti<command
>code.preprocess</command
>, <command
>code.printout</command
> in<command
>code.calculate</command
> iz vdelanega vtičnika možnosti izrisa invstavite jih v svojo kodo, kot je prikazano v <link linkend="plot_plugin_example"
>primer</link
> spodaj. </para>
	</sect2>
	<sect2 id="plot_plugin_example">
		<title
>Kanonični primer</title>
		<para
>Tukaj je primer datoteke .JS, ki bi jo morali uporabiti kot predlogo, kadar koli ustvarite vtičnik za risanje: </para>
		<programlisting
>function preprocess () {
    // the "somepackage" is needed to create the plot
    echo ("require (somepackage)\n");
  }
  
  function printout (is_preview) {
    // If "is_preview" is set to false/undefined, it generates the full code, including headers.
    // If "is_preview" is set to true, only the essentials will be generated.

    if (!is_preview) {
      echo ('rk.header (' + i18n ("An example plot") + ')\n\n');
      echo ('rk.graph.on ()\n');
    }
    // only the following section will be generated for is_preview==true

    // remember: everything between rk.graph.on() and rk.graph.off() should be wrapped inside a try() statement:
    echo ('try ({\n');
    // insert any option-setting code that should be run before the actual plotting commands.
    // The code itself is provided by the embedded plot options plugin. printIndentedUnlessEmpty() takes care of pretty formatting.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.preprocess"), '', '\n');

    // create the actual plot. plotoptions.code.printout provides the part of the generic plot options
    // that have to be added to the plotting call, itself.
    echo ('plot (5, 5' + getString ("plotoptions.code.printout") + ')\n');

    // insert any option-setting code that should be run after the actual plot.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.calculate"), '\n');
    echo ('})'\n);  // the closure of the try() statement

    if (!is_preview) {
      echo ('rk.graph.off ()\n');
    }
  }
                </programlisting>
	</sect2>
</sect1>
<sect1>
	<title
>Predogled podatkov, izpisov in drugih rezultatov</title>
	<sect2 id="preview_output">
		<title
>Predogled (HTML) izhoda</title>
		<note
><para
>Ta razdelek obravnava dodajanje funkcije predogleda vtičnikom, ki ustvarjajo izpise/izpise HTML. Priporočamo, da pred tem razdelkom preberete ločen razdelek o <link linkend="preview_plots"
>predogledih ploskev</link
>.</para
></note>
		<para
>Ustvarjanje predogleda izpisa HTML je skoraj enak postopek kot ustvarjanje predogleda grafikona. V tem primeru se preprosto prepričajte, da <command
>preview()</command
> ustvari ustrezne ukaze <command
>rk.print()/rk.results()</command
>. Vendar pa je na splošno dobro izpustiti izjave glave v predogledu. Tukaj je skrajšan primer: </para>
		<programlisting
>&lt;!-- In the plugin's XML file --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" mode="output"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Upoštevajte specifikacijo <parameter
>mode="output"</parameter
> v elementu <command
>&lt;preview&gt;</command
>. ​ </para>
		<programlisting
>// In the plugin's JS file
        function preview () {
                // generates the code used for preview
                printout (true);
        }

        function printout (is_preview) {
                // only generates a header if is_preview==false
                if (!is_preview) {
                        new Header ("This is a caption").print ();
                }
                echo ('rk.print (result)');
        }
                </programlisting>
	</sect2>
	<sect2 id="preview_data">
		<title
>Predogledi (uvoženih) podatkov</title>
		<note
><para
>Ta razdelek obravnava dodajanje funkcije predogleda vtičnikom, ki ustvarjajo (uvažajo) podatke. Priporočamo, da pred tem razdelkom preberete ločen razdelek o <link linkend="preview_plots"
>predogledih grafikonov</link
>.</para
></note>
		<para
>Ustvarjanje predogleda uvoženih podatkov (katere koli vrste podatkov, ki jih lahko obdeluje <command
>rk.edit()</command
>) je zelo podobno ustvarjanju <link linkend="preview_plots"
>predogleda grafikona</link
>. Naslednji skrajšani primer bi moral pomagati ponazoriti, kako ustvariti predogled podatkov: </para>
		<programlisting
>&lt;!-- In the plugin's XML file --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" active="true" mode="data"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Upoštevajte, da element <command
>&lt;preview&gt;</command
> tokrat določa <parameter
>mode="data"</parameter
>. <parameter
>active="true"</parameter
> preprosto naredi predogled privzeto aktiven.  </para>
		<programlisting
>// In the plugin's JS file
        function preview () {
                // generates the code used for preview
                calculate (true);
        }

        function calculate (is_preview) {
                echo ('imported &lt;- read.csv (file="' + getString ("file") /* [+ options] */);
                if (is_preview) {
                        echo ('preview_data &lt;- imported\n');
                } else {
                        echo ('.GlobalEnv$' + getString ("name") + ' &gt;- imported\n');
                }
        }

        function printout () {
                // [...]
        }
                </programlisting>
		<para
>Spet funkcija <command
>preview()</command
> ustvari skoraj enako&R; kodo kot funkcijo <command
>calculate()</command
>, tako da ustvarimo apomožno funkcijo <command
>doCalcuate()</command
> za izločanje skupnih delov. Najpomembnejša stvar, ki jo morate upoštevati, je, da boste morali dodeliti uvožene podatke v objekt, imenovan <parameter
>preview_data</parameter
> (znotraj trenutnega – lokalnega – okolja). <emphasis
>Vse ostalo se bo zgodilo samodejno</emphasis
> (grobo rečeno, bo &rkward; poklical <command
>rk.edit(preview_data)</command
>, zavit v klic <command
>.rk.with.window.hints()</command
>). </para>
		<note
><para
>Čeprav so predogledi odlična funkcija, porabljajo vire. V primeru predogledov podatkov, lahko pride do primerov, ko lahko predogledi povzročijo znatne težave z zmogljivostjo. To je lahko za uvoz ogromnih naborov podatkov (ki so preprosto preveliki, da bi ga odprli za urejanje v oknu urejevalnika &rkward;), vendar tudi "običajni" nabori podatkov bi lahko bili napačno uvoženi, kar bi povzročilo ogromno številovrstic ali stolpcev. <emphasis
>Zelo priporočljivo je, da omejite <parameter
>preview_data</parameter
></emphasis
> v dimenzijo, ki zagotavlja uporaben predogled, brez nevarnosti ustvarjanja opazne zmogljivostitežave (&eg; 50 vrstic s 50 stolpci bi moralo biti v večini primerov več kot dovolj). </para
></note>
	</sect2>
	<sect2 id="preview_custom">
		<title
>Predogledi po meri</title>
		<para
>Ukaz <command
>&lt;preview&gt;</command
> element lahko uporabite za ustvarjanjepredogledov za katero koli vrsto okna "dokumenta", ki ga je mogoče pripeti na &rkward;njegovo delovno mesto. Poleg <link linkend="preview_plots"
>grafov</link
>in <link linkend="preview_data"
>podatkovnih oken</link
>, to vključuje HTMLdatoteke, &R; skripte in okna s povzetkom objektov. Za slednje tibo moral uporabiti <command
>&lt;preview mode="custom"&gt;</command
>. </para>
		<para
>Če ste prebrali razdelke, ki opisujejo predogled izrisa in predogled podatkov, stebi morali imeti splošno predstavo o postopku, vendar so potrebni predogledi po merinekoliko več ročnega dela v zakulisju. Najpomembnejša &R; funkcija za ogled je <command
>rk.assign.preview.data()</command
>, tukaj. Naslednji kratek seznam prikazuje, kaj ste ustvarili (predogled) &R; koda bi lahko videti kot za vtičnik, ki ustvarja izhod besedilne datoteke: </para>
		<programlisting
>## To be generated in the preview() code section of a plugin
        pdata &lt;- rk.get.preview.data("SOMEID")
        if (is.null (pdata)) {
                outfile &lt;- rk.get.tempfile.name(prefix="preview", extension=".txt")
                pdata &lt;- list(filename=outfile, on.delete=function (id) {
                        unlink(rk.get.preview.data(id)$filename)
                })
                rk.assign.preview.data("SOMEID", pdata)
        }
        try ({
                cat ("This is a test", pdata$filename)
                rk.edit.files(file=pdata$filename)
        })
                </programlisting>
		<para
>Tukaj bi morali pridobiti vrednost <parameter
>SOMEID</parameter
> iz lastnosti <parameter
>id</parameter
> elementa <command
>&lt;preview&gt;</command
>. tj. z uporabo <command
>getString ("preview.id")</command
> v datoteki .js vtičnika. </para>
	</sect2>
</sect1>

<sect1 id="contextualized_plugins">
	<title
>Kontekstno odvisni vtičniki</title>
	<para
>Doslej smo domnevali, da so vsi vtičniki vedno smiselni in vsi nameščeni v glavnem meniju. Vendar so nekateri vtičniki smiselni samo (ali dodatno) v določenem kontekstu. Na primer vtičnik za izvoz vsebine datoteke &R; Grafična naprava X11 je očitno najbolj uporabna, če jo postavite v meni naprave X11, ne v glavno menijsko vrstico. Prav tako mora tak vtičnik vedeti za številko naprave, na kateri naj deluje, ne da bi o tem vprašal uporabnika. </para>
	<para
>Takim vtičnikom pravimo, da so odvisni od konteksta. Skladno s tem v <link linkend="pluginmap"
>&pluginmap; datoteko</link
>, niso (ali ne samo) postavljeni v glavno <command
>&lt;hierarchy&gt;</command
>, temveč v element <command
>&lt;context&gt;</command
>. Zaenkrat sta podprta samo dva različna konteksta (več jih bo na voljo pozneje): x11 in uvoz datotek. Te bomo obravnavali po vrsti. Tudi če vas zanima le uvozni kontekst, preberite tudi razdelek o kontekstu x11, saj je nekoliko bolj dodelan. </para>

	<sect2 id="context_x11">
		<title
>Kontekst naprave X11</title>
		<para
>Če želite uporabiti vtičnik v kontekstu naprave x11 – to pomeni, da ga postavite v menijsko vrstico okna, ki se prikaže, ko pokličete <function
>x11()</function
> v konzoli, ga najprej deklarirajte kot običajno v <link linkend="pluginmap"
>&pluginmap; datoteki</link
>: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_x11_plugin" file="my_x11_plugin.xml" label="An X11 context plugin"/&gt;
                [...]
        &lt;/components&gt;
                </programlisting>
		<para
>Vendar vam ga ni treba definirati v hierarhiji (lahko, če jesmiseln tudi kot vtičnik najvišje ravni): </para>
		<programlisting
>&lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
                </programlisting>
		<para
>Namesto tega dodajte definicijo konteksta "x11" in jo dodajte v menije tja: </para>
		<programlisting
>&lt;context id="x11"&gt;
                [...]
                &lt;menu id="edit"&gt;
                        [...]
                        &lt;entry id="my_x11_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
&lt;/document&gt;
                </programlisting>
		<para
>V <link linkend="logic"
>logičnem razdelku vtičnika xml</link
> lahko zdaj deklarirate dve lastnosti <command
>&lt;external&gt;</command
>: <parameter
>devnum</parameter
> in <parameter 
>context</parameter
>. <parameter
>context</parameter
> (če je deklariran) bo nastavljen na <replaceable
>»x11«</replaceable
>, ko bo vtičnik priklican v tem kontekstu. <parameter
>devnum</parameter
> bo nastavljen na številko grafične naprave za delovanje. In to je vse. </para>
	</sect2>

	<sect2 id="context_import">
		<title
>Uvoz konteksta podatkov</title>
		<para
>Preden preberete ta razdelek, obvezno preberite razdelek o <link linkend="context_x11"
>kontekstu naprave X11</link
>, saj pojasnjuje osnovne pojme. </para>
		<para
>Kontekst <replaceable
>»import«</replaceable
> se uporablja za deklaracijo vtičnikov filtrov za uvoz datotek. Preprosto jih postavite v kontekst z <parameter
>id=</parameter
><replaceable
>"import"</replaceable
> v datoteko &pluginmap;. Vendar pa je pri deklaraciji teh vtičnikov še en dodaten zasuk: če želite ponuditi poenoteno pogovorno okno za izbiro datotek za vse podprte vrste datotek, morate deklarirati en dodaten bit informacij o svoji komponenti: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_xyz_import_plugin" file="my_xyz_import_plugin.xml" label="Import XYZ files"&gt;
                        &lt;attribute id="format" value="*.xyz *.zyx" label="XYZ data files"/&gt;
                &lt;/component&gt;
                [...]
        &lt;/components&gt;
        &lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
        &lt;context id="import"&gt;
                [...]
                &lt;menu id="import"&gt;
                        [...]
                        &lt;entry id="my_xyz_import_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
        [...]
&lt;/document&gt;
                </programlisting>
		<para
>Vrstica atributa preprosto pravi, da so povezane pripone imena datotek za datoteke XYZ <literal role="extension"
>*.xyz</literal
> ali <literal role="extension"
>*.zyx</literal
> in da filter naj bo v pogovornem oknu za izbiro datoteke označen z <quote
>Podatkovne datoteke XYZ</quote
>. </para>
		<para
>V svojem vtičniku lahko deklarirate dve lastnosti <command
>&lt;external&gt;</command
>. <parameter
>filename</parameter
> bo nastavljen na izbrano ime datoteke, <parameter
>context</parameter
> pa bo nastavljen na <replaceable
>"import"</replaceable
>. </para>
	</sect2>
</sect1>

<sect1 id="querying_r_for_info">
<title
>Poizvedovanje &R; za informacijo</title>
	<para
>V nekaterih primerih boste morda želeli pridobiti dodatne informacije iz &R;, ki bodo predstavljene v uporabniškem vmesniku vašega vtičnika. Na primer, morda boste želeli ponuditi izbor ravni faktorja, ki ga je uporabnik izbral za analizo. Od različice 0.6.2 &rkward; to je mogoče storiti. Preden začnemo, je pomembno, da se zavedate nekaterih opozoril:</para>
	<para
>Koda R, ki se izvaja znotraj logike uporabniškega vmesnika vtičnika, se ovrednoti v zanki dogodkov R, kar pomeni, da se lahko izvaja <emphasis
>medtem, ko</emphasis
> se izvajajo drugi izračuni. S tem zagotovimo, da bo uporabniški vmesnik vašega vtičnika uporaben, tudi ko &R; je zaposlen z drugimi stvarmi. Vendar je zaradi tega zelo pomembno, da vaša koda nima stranskih učinkov. Še posebej:</para>
	<itemizedlist>
		<listitem
><para
><emphasis
>Ne</emphasis
> izvaja nobenih dodelitev v .GlobalEnv ali katerem koli drugem nelokalnem okolju.</para
></listitem>
		<listitem
><para
><emphasis
>Ne</emphasis
> natisne ničesar v izhodno datoteko.</para
></listitem>
		<listitem
><para
><emphasis
>Ne</emphasis
> riše ničesar na zaslon.</para
></listitem>
		<listitem
><para
>Na splošno <emphasis
>ne</emphasis
> počne ničesar, kar ima stranske učinke. Vaša koda lahko <emphasis
>bere informacije</emphasis
>, ne pa "<emphasis
>naredi</emphasis
>" česar koli.</para
></listitem>
	</itemizedlist>
	<para
>S tem v mislih je tukaj splošni vzorec. To boste uporabili v razdelku <link linkend="logic_scripted"
>skriptirane logike uporabniškega vmesnika</link
>:</para>
	<programlisting
>&lt;script&gt;&lt;![CDATA[
                                last_command_id = -1;
                                gui.addChangeCommand ("variable", "update ()");
                                update = function () {
                                        gui.setValue ("selector.enabled", 0);
                                        variable = gui.getValue ("variable");
                                        if (variable == "") return;

                                        last_command_id = doRCommand ('levels (' + variable + ')', "commandFinished");
                                }

                                commandFinished = function (result, id) {
                                        if (id != last_command_id) return;  // another result is about to arrive
                                        if (typeof (result) == "undefined") {
                                                gui.setListValue ("selector.available", Array ("ERROR"));
                                                return;
                                        }
                                        gui.setValue ("selector.enabled", 1);
                                        gui.setListValue ("selector.available", result);
                                }
                ]]&gt;&lt;/script&gt;
        </programlisting>
	<para
>Tu je <parameter
>variable</parameter
> lastnost, ki vsebuje ime predmeta (&eg; znotraj <command
>&lt;varslot&gt;</command
>). Kadarkoli se to spremeni, boste želeli posodobiti prikaz ravni znotraj <command
>&lt;valueselector&gt;</command
>, imenovanega <parameter
>selector</parameter
>. Ključna funkcija tukaj je <command
>doRCommand()</command
>, ki kot prvi parameter vzame ukazni niz, ki ga je treba zagnati, in kot drugi parameter ime funkcije, ki jo je treba poklicati, ko je ukaz končan. Upoštevajte, da se ukaz izvaja asinhrono, zaradi česar so stvari nekoliko bolj zapletene. Kot eno stvar se želite prepričati, da vaš <command
>&lt;valueselector&gt;</command
> ostane onemogočen, medtem ko ne vsebuje posodobljenih informacij. Druga stvar je, da ste morda v čakalno vrsto postavili več kot en ukaz, preden dobite prve rezultate. Zato je vsakemu ukazu dodeljen "id", ki ga shranimo v <parameter
>last_command_id</parameter
> za kasnejšo uporabo.</para>
	  <para
>Ko je ukaz končan, se prikliče navedeni povratni klic (<parameter
>commandFinished</parameter
>, v tem primeru) z dvema parametroma: samim rezultatom in ID-jem ustreznega ukaza. Rezultat bo vrste, ki spominja na predstavitev v &R;, &ie; številski niz, če je rezultat številski, &etc; Lahko je celo &R; <command
>list()</command
>, vendar bo v tem primeru predstavljen kot JS <command
>Array()</command
> brez imen.</para>
	  <para
>Upoštevajte, da je tudi ta primer nekoliko poenostavljen. V resnici bi morali sprejeti dodatne previdnostne ukrepe, &etc;, da se izognete vstavljanju prevelikega števila stopenj v izbirnik. Dobra novica je, da vam verjetno ni treba storiti vsega tega sami. Zgornji primer je na primer vzet iz vtičnika <command
>rkward::level_select</command
>, ki ga lahko preprosto <link linkend="embedding"
>vdelate</link
> v svoj vtičnik. To vam celo omogoča, da določite drugačen izraz za izvajanje namesto <command
>levels()</command
>.</para>
</sect1>

<sect1 id="current_object">
<title
>Sklicevanje na trenutni predmet ali trenutno datoteko</title>
	<para
>Za mnoge vtičnike je zaželeno, da delajo na <quote
>trenutnem</quote
> objektu. Na primer, vtičnik <quote
>sort</quote
> lahko vnaprej izbere data.frame, ki se trenutno ureja za razvrščanje. Ime trenutnega predmeta je na voljo vtičnikom kot vnaprej določena lastnost, imenovana <parameter
>current_object</parameter
>. S to nepremičnino se lahko povežete na običajen način. Če noben objekt ni trenuten, je lastnost enaka praznemu nizu. Podobno &URL; trenutne datoteke skripta je dostopen kot vnaprej določena lastnost, imenovana <parameter
>current_filename</parameter
>. Ta lastnost je prazna, če se trenutno ne ureja nobena skriptna datoteka ali če skriptna datoteka še ni bila shranjena. </para>
	<para
>Trenutno je lahko <parameter
>current_object</parameter
> samo razreda <function
>data.frame</function
>, vendar se ne zanašajte na to, saj bo to v prihodnosti razširjeno na druge vrste podatkov. Če vas zanimajo samo objekti <function
>data.frame</function
>, se raje povežite z lastnostjo <parameter
>current_dataframe</parameter
>. Zahteve glede vrste lahko uveljavite tudi z uporabo ustreznih omejitev na vaših <command
>&lt;varslot&gt;</command
> ali z uporabo <link linkend="logic_scripted"
>&GUI; logično skriptiranje</link
>. </para>
</sect1>

<sect1 id="optionset">
	<title
>Ponavljanje (niz) možnosti</title>
	<para
>Včasih želite ponoviti nabor možnosti za poljubno število elementov. Npr. Recimo, da želite implementirati vtičnik za razvrščanje data.frame. Morda boste želeli dovoliti razvrščanje po poljubnem številu stolpcev (v primeru izenačenja med prvimi stolpci). To bi lahko preprosto realizirali tako, da bi uporabniku omogočili izbiro več spremenljivk v <command
>&lt;varslot&gt;</command
> s <parameter
>multi="true"</parameter
>. Če pa želite to razširiti, &eg; omogoča uporabniku, da za vsako spremenljivko določi, ali naj se pretvori v znakovno/številsko ali naj bo razvrščanje naraščajoče ali padajoče, potrebujete več prilagodljivosti. Drugi primeri bi bili risanje več črt v enem izrisu (ki omogoča izbiro predmeta, sloga črte, barve črte &etc; za vsako črto) ali določanje preslikave za ponovno kodiranje iz niza starih vrednosti v nove vrednosti. </para>
	<para
>Vnesite <command
>&lt;optionset&gt;</command
>. Najprej si poglejmo preprost primer: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        &lt;row&gt;
                                &lt;input id="firstname" label="Given name(s)" size="small"&gt;
                                &lt;input id="lastname" label="Family name" size="small"&gt;
                                &lt;radio id="gender" label="Gender"&gt;
                                        &lt;optioncolumn label="Male" value="m"/&gt;
                                        &lt;optioncolumn label="Female" value="f"/&gt;
                                &lt;/radio&gt;
                        &lt;/row&gt;
                &lt;/content&gt;

                &lt;optioncolumn id="firstnames" label="Given name(s)" connect="firstname.text"&gt;
                &lt;optioncolumn id="lastnames" label="Family name" connect="lastname.text"&gt;
                &lt;optioncolumn id="gender" connect="gender.string"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Tukaj smo ustvarili uporabniški vmesnik za določanje števila oseb (&eg; avtorjev). Uporabniški vmesnik zahteva vsaj en vnos (<parameter
>min_rows="1"</parameter
>). Znotraj elementa <command
>&lt;optionset&gt;</command
> začnemo z določitvijo <command
>&lt;content&gt;</command
>, &ie; tiste elemente, ki pripadajo naboru možnosti. Seznanjeni boste z večino elementov znotraj <command
>&lt;content&gt;</command
>. </para
><para
>Nato določimo zanimive spremenljivke, ki jih bomo želeli prebrati iz nabora možnosti v naši datoteki JS. Ker bomo imeli opravka s poljubnim številom postavk, ne moremo samo brati <function
>getString ("ime")</function
> v JS. Namesto tega za vsako vrednost, ki nas zanima, določimo <command
>&lt;optioncolumn&gt;</command
>. Za prvi stolpec možnosti v primeru <command
>&lt;connect="firstname.text"&gt;</command
> pomeni, da se vsebina elementa <command
>&lt;input&gt;</command
> bere za vsak predmet. <command
>&lt;optioncolumn&gt;</command
>, za katere je podana <parameter
>label</parameter
>, bodo prikazani na zaslonu v stolpcu s to oznako. V JS lahko zdaj pridobimo imena za vse avtorje z uporabo <function
>getList("set.firstname")</function
>, <function
>getList("set.lastnames")</function
> za družinska imena, in <function
>getList("set.gender")</function
> za matriko nizov "m"/"f". </para>
	<para
>Upoštevajte, da ni nobenih omejitev glede tega, kaj lahko postavite znotraj <command
>&lt;optionset&gt;</command
>. Uporabite lahko celo <link linkend="embedding"
>vdelane</link
> komponente. Tako kot pri katerem koli drugem elementu je vse, kar morate storiti, zbrati izhodne spremenljivke, ki vas zanimajo, v specifikaciji <command
>&lt;optioncolumn&gt;</command
>. V primeru vdelanih vtičnikov je to pogosto del lastnosti "code". Npr.: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Seveda lahko uporabite tudi <link linkend="logic"
>logiko uporabniškega vmesnika</link
> znotrajnabora možnosti. Obstajata dve možnosti za to: To lahko storite tako, da nareditepovezavo (ali skript) v glavnem <command
>&lt;logic&gt;</command
>razdelku vtičnika, kot običajno. Vendar boste dostopali do elementov uporabniškega vmesnikav območju vsebine kot (&eg;) "set.contents.firstname.XYZ". Upoštevajtepredpono "set" (<parameter
>id</parameter
>, ki ste ga dodelili nizuin "vsebina"). Lahko pa dodate ločeno <command
>&lt;logic&gt;</command
> kot podrejeni element vašega nabora <command
>&lt;optionset&gt;</command
>. V tem primeru bodo <parameter
>id</parameter
> bodo naslovljeni glede na področje vsebine, &eg; "firstname.XYZ". Samo element <command
>&lt;script&gt;</command
> ni dovoljeno v logičnem delu nabora možnosti. Če želite uporabiti skripte, boste morali uporabiti razdelek glavne <command
>&lt;logike&gt;</command
> vtičnika. </para>
	<note>
		<para
>Pri skriptni logiki v naboru možnosti je vse, kar lahko storite, dostop do trenutne <emphasis
>current</emphasis
> regije vsebine. Tako je običajno samosmiselno povezati elemente znotraj območja vsebine med seboj.Povezovanje lastnosti zunaj <command
>&lt;optionset&gt;</command
> aznotraj področja vsebine, je lahko uporabna za inicializacijo.Vendar bo spreminjanje območja vsebine po inicializaciji<emphasis
>ne</emphasis
> velja za postavke, ki jih je uporabnik že definiral.Samo na trenutno izbrani artikel v zbirki.​ </para>
	</note>
	<sect2 id="optionset_driven">
		<title
>Poganjane zbirke možnosti</title>
		<para
>Doslej smo obravnavali <command
>&lt;optionset&gt;</command
>, kiponuja gumbe za dodajanje/odstranjevanje elementov. Vendar v nekaterih primerih jeveliko bolj naravno izbiranje elementov zunaj <command
>&lt;optionset&gt;</command
> in nudijo le možnosti za prilagajanje nekaterih vidikov vsakega elementav <command
>&lt;optionset&gt;</command
>. Npr. recimo, da želite dovolitiuporabnik izriše več objektov znotraj ene ploskve. Za vsak predmet uporabnikmora imeti možnost določiti barvo črte. To bi <emphasis
>lahko</emphasis
> rešili tako, da postavite <command
>&lt;varselector&gt;</command
> in <command
>&lt;varslot&gt;</command
> znotraj <command
>&lt;content&gt;</command
> območja, ki uporabniku omogoča izbiro enega elementa naenkrat. Vendar pa bi pomenilo veliko manj klikov za uporabnika, če uporabite <command
>&lt;varslotmulti="true"&gt;</command
> <emphasis
>zunaj</emphasis
>Namesto tega <command
>&lt;optionset&gt;</command
>. Potem boste to povezaliizbiranje predmetov v tako imenovanem "pognanem" naboru možnosti. Takole: </para>
		<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;connect client="set.vars" governor="vars.available"/&gt;
                &lt;connect client="set.varnames" governor="vars.available.shortname"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;varselector id="varsel"/&gt;
        &lt;varslot id="vars" label="Objects to plot"/&gt;
        &lt;optionset id="set" keycolumn="var"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Line color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="vars" external="true"&gt;
                &lt;optioncolumn id="varnames" external="true" label="Variable"&gt;
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
		<para
>Začeli bomo gledati primer na dnu. Opazili boste, da dvaSpecifikacije <command
>&lt;optioncolumn&gt;</command
> imajo<parameter
>external="true"</parameter
>. To pove &rkward; da so te možnosti  <command
>&lt;optionset&gt;</command
> nadzorovane od zunaj. Tukaj je edini namen stolpca z možnostmi "varnames" zagotoviti enostavno branje oznake na zaslonu nabora možnosti (povezan je s "kratkim imenom" modifikatorjem lastnosti, ki vsebuje izbrane predmete). Namen"vars"-optioncolumn naj služi kot "ključni" stolpec, kot določa<command
>&lt;optionset keycolumn="vars"...&gt;</command
>. To pomeni da bo za vsak vnos na tem seznamu nabor ponudil en nabor možnosti in možnosti so logično povezane s temi vnosi. Ta stolpec je povezan z lastnostjo, ki vsebuje izbrane predmete v <command
>&lt;varslot&gt;</command
>. To je za vsak predmet, ki je tam izbran,<command
>&lt;optionset&gt;</command
> omogoča določitev barve črte. </para>
		<note>
			<para
>Zunanji stolpec je mogoče tudi <parameter
>povezati</parameter
>z lastnostmiznotraj območja <command
>&lt;content&gt;</command
>. Vendar pa jepomembno je omeniti, da se stolpce možnosti deklarirane <parameter
>external="true"</parameter
> nikoli ne sme spreminjati znotraj <command
>&lt;optionset&gt;</command
> in deklarirani stolpci možnosti <parameter
>external="false"</parameter
> (privzeto) nikoli ne smejo bitispremenjeni zunaj <command
>&lt;optionset&gt;</command
>. </para>
		</note>
	</sect2>
	<sect2 id="optionset_alternatives">
		<title
>Alternative: Kdaj ne uporabljati naborov možnosti</title>
		<para
>Nabori možnosti (optionsets) so močno orodje, vendar lahko včasih naredijo več škode kotkoristi, saj dodajajo precejšnjo kompleksnost, tako z vidika razvijalca vtičnika kot z vidika uporabnika. Torej dvakrat premislite pri njihovi uporabi. Tukaj je nekaj nasvetov: </para>
		<itemizedlist>
			<listitem
><para
>Za nekatere preproste primere lahko element <command
>&lt;matrix&gt;</command
> nudi uporabno lahkotno alternativo.</para
></listitem>
			<listitem
><para
>Naj vaš vtičnik ne naredi preveč. Navedli smo primer uporabe za nabor možnosti za vtičnik za risanje več črt znotraj ene risbe. Ampak na splošno ni dobra ideja ustvariti vtičnika, ki bo ustvaril posamezne ploskveza vsak element v naboru možnosti. Raje naj vtičnik ustvari eno ploskev in uporabnik ga lahko pokliče večkrat. </para
></listitem>
			<listitem
><para
>Če ne pričakujete več kot dva ali tri predmete v kompletu, razmislite o ponavljanju možnosti, namesto tega kar ročno.</para
></listitem>
		</itemizedlist>
	</sect2>
</sect1>

</chapter>

<chapter id="chapter_dependencies">
<title
>Ravnanje z odvisnostmi in težavami z združljivostjo</title>
<sect1 id="sect_dependencies_rkward_version"
><title
>&rkward; združljivost različic</title>
	<para
>Po najboljših močeh se trudimo zagotoviti, da bodo vtičniki razviti za staro različico &rkward; ostali  funkcionalni v kasnejših različicah &rkward;. Vendar pa obratno ni vedno res, saj so dodane nove funkcije. Ker vsi uporabniki ne uporabljajo najnovejše različice &rkward;, to pomeni, da lahko vaš vtičnikne deluje za vsakogar.</para>
	<para
>Kadar se zavedate takšnih težav z združljivostjo, se morate dokumentirati to dejstvo v svoji datoteki &pluginmap; z uporabo elementa <command
>&lt;dependencies&gt;</command
>. Ukaz <command
>&lt;dependencies&gt;</command
> je mogoče določiti kot neposrednega naslednika &lt;dokumenta&gt; &pluginmap; ali kot podrejenega elementa posameznih definicij <command
>&lt;component&gt;</command
>. V prvi odvisnosti veljajo za <emphasis
>vse</emphasis
> vtičnike v mapi. V slednjem primeru samo posamezni<command
>&lt;komponenti&gt;</command
>(-e). Lahko tudi mešate top "global" in"posebne" odvisnosti. V tem primeru so "globalne" odvisnostidodani tistim iz posamezne komponente.</para>
	<para
>Poglejmo majhen primer:</para>
	<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c" /&gt;
        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
        </programlisting>
	<para
>V tem primeru je znano, da vsi vtičniki zahtevajo vsaj različico 0.5.0c &rkward;. En vtičnik z <replaceable
>id="myplugin"</replaceable
> je na voljo v dveh alternativnih različicah. Prva, okleščena različica se da uporabiti za &rkward; različice pred 0.6.1. Slednja uporablja funkcije ki so nove v &rkward; 0.6.1 in se bo uporabljal samo od &rkward; 0.6.1 naprej.</para>
	<para
>Zagotavljanje alternativnih različic, kot je ta, je zelo uporabniku prijazen načinuporabe novih funkcij, medtem ko še vedno ohranja podporo za prejšnje različice&rkward;. Alternativne različice morajo imeti isti <parameter
>id</parameter
> (v nasprotnem primeru bodo prikazana opozorila) in se jih lahko samo definira<emphasis
>znotraj iste</emphasis
> &pluginmap; mape.</para>
	<para
>Vtičnik, ki ni združljiv z delujočo različico &rkward;, inki ne prihaja z alternativno različico, bo prezrt z opozorilom.</para>
	<note
><para
>Pravzaprav &rkward; 0.6.1 je prva različica, ki razlaga odvisnosti - inporoča o napakah odvisnosti – sploh. Torej, v nasprotju s tem, kar lahko primerpredlaga, navedba kakršnih koli prejšnjih različic v odvisnostih ne bo imelakakršnega koli neposrednega učinka (vendar je morda še vedno dobra ideja za namene dokumentacije).</para
></note>
	<para
><emphasis
>Včasih</emphasis
> bo mogoče težave z nezdružljivostjo različic celo obravnavati <emphasis
>znotraj</emphasis
> ene same datoteke &pluginmap; z uporabo elementa <command
>&lt;dependency_check&gt;</command
> opisane v naslednjem razdelku.</para>
</sect1>
<sect1 id="sect_dependencies_r_version"
><title
>&R; združljivost različice</title>
	<para
>Podobno kot <parameter
>rkward_min_version</parameter
> in <parameter
>rkward_max_version</parameter
> element <command
>&lt;dependencies&gt;</command
> omogoča specifikacijo atributov <parameter
>R_min_version</parameter
> in <parameter
> R_max_version</parameter
>. Vendar pa obstajajo naslednje razlike:</para>
	<itemizedlist>
		<listitem
><para
>Vtičniki, ki ne izpolnjujejo &R; zahteve za različico <emphasis
>niso</emphasis
> trenutno preskočeni pri branju datoteke &pluginmap;. Uporabnik lahkoše vedno kliče vtičnik in ne bo videl nobenega takojšnjega opozorila (v prihodnjih različicah, bo verjetno prikazano opozorilno sporočilo)</para
></listitem>
		<listitem
><para
>Posledično tudi <emphasis
>ni</emphasis
> mogoče definirati alternativnih različic vtičnika glede na različico &R;</para
></listitem>
		<listitem
><para
>Vendar pa je pogosto enostavno doseči združljivost za nazaj, kot je prikazano spodaj.Če poznate &R; težave z združljivostjo, razmislite o uporabi teganamesto definiranja odvisnosti od določene različice &R;.</para
></listitem>
	</itemizedlist>
	<para
>V mnogih primerih je enostavno zagotoviti zmanjšano funkcionalnost, če določena funkcija ni na voljo v delujoči različici &R;. Upoštevajte naslednji kratek primer vtičnika <literal role="extension"
>.xml</literal
> datoteke:</para>
	<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;dependency_check id="ris210" R_min_version="2.10.0"/&gt;
                &lt;connect client="compression.xz.enabled" governor="ris210"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;radio id="compression" label="Compression method"&gt;
                &lt;option label="None" value=""&gt;
                &lt;option label="gzip" value="gzip"&gt;
                &lt;option id="xz" label="xz" value="xz"&gt;
        &lt;/radio&gt;
        [...]
&lt;/dialog&gt;
        </programlisting>
	<para
>V tem primeru bo možnost stiskanja "xz" preprosto onemogočena, ko&R; različica izvajalnega okolja je starejša od 2.10.0 (ki ni podpirala xzstiskanja). Element <command
>&lt;dependency_check&gt;</command
>podpira iste atribute kot <command
>&lt;dependencies&gt;</command
>element v datoteki &pluginmap;. Ustvari logično lastnost, kar je true, če so podane odvisnosti izpolnjene, sicer pa false.</para>
</sect1>
<sect1 id="sect_dependencies_r_packages"
><title
>Odvisnosti od &R; paketov</title>
<para
>Odvisnosti od posebnih &R; pakete je mogoče definirati, vendar od &rkward; 0.6.1 te odvisnosti niso niti preverjene niti nameščene/naložene samodejno. So prikazani v datotekah pomoči vtičnika. Tukaj jeprimer definicije:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<note
><para
>Vedno se prepričajte, da dodate ustrezne klice <function
>require()</function
>, čevaš vtičnik potrebuje za nalaganje določenih paketov.</para
></note>
<note
><para
>Če <link linkend="external_plugins"
>distribuirate svoj &pluginmap; kot&R; paket</link
> in so vsi vtičniki odvisni od določenega paketa, potem morate definirati to odvisnost od &R; na ravni paketa. Definiranjeodvisnosti od &R; paketi na ravni &rkward; &pluginmap; jenajbolj uporabno, če le nekateri vaši vtičniki potrebujejo odvisnost, jeodvisnost ni na voljo pri CRAN ali vaš &pluginmap; nidistribuiran kot &R; paket.</para
></note>
</sect1>
<sect1 id="sect_dependencies_other_pluginmaps"
><title
>Odvisnosti od drugih datotek &rkward; &pluginmap;</title>
	<para
>Če so vaši vtičniki odvisni od vtičnikov, definiranih v drugem &pluginmap; (to je <emphasis
>ni</emphasis
> del vašega paketa) lahko definirate to odvisnost takole:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<para
>Trenutno ne bo niti naložil, niti namestil, niti ne bo opozoril na manjkajoče datoteke &pluginmap;, ampak vsaj informacije o odvisnostih (in kje jih dobiti) bodo prikazani na strani s pomočjo vtičnika. Ni vam treba (in ne smete) navesti odvisnosti od datotek &pluginmap;, ki so dobavljene z uradne &rkward; distribucije ali na datotekah &pluginmap;, ki so znotraj vašega paketa. Nadalje, če je zahtevana datoteka &pluginmap; <link linkend="external_plugins"
>distribuirana kot &R; paket</link
>, deklarirajte odvisnosti od paketa (kot je prikazano v prejšnjem razdelku), namesto od mape.</para>
	<para
>Če želite zagotoviti, da so zahtevani datoteke &pluginmap; dejansko naložene, uporabite<command
>&lt;require&gt;</command
>-oznako (glejte <link linkend="pluginmapelements"
>referenca</link
> za podrobnosti).</para>
</sect1>
<sect1 id="sect_dependencies_example"
><title
>Primer</title>
	<para
>Za pojasnitev, kako se lahko mešajo definicije odvisnosti, je tukaj kombinirani primer:</para>
<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c"&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
                &lt;package 
                        name="DreamsOfPi"
                        min_version="0.2"
                /&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;dependencies&gt;

        &lt;require map="heisenberg::heisenberg_plugins"/&gt;

        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
</programlisting>
</sect1>
</chapter>

<chapter id="i18n">
	<title
>Prevodi vtičnikov</title>
	<para
>Doslej smo uporabili nekaj konceptov v zvezi s prevodi ali "i18n" (kar je na kratko za "internacionalizacijo", ki ima 18 znakov med i in n). V tem poglavju podajamo bolj poglobljeno poročilo o tem, kaj je i18nfunkcionalno za &rkward; vtičnike. Večinoma <emphasis
>ne</emphasis
> potrebujete vse to v svojih vtičnikih. Vendar je morda dobra idejaprebrati to poglavje v celoti, saj bi vam razumevanje teh konceptov moralo pomagati pri ustvarjanju vtičnikov, ki so popolnoma prevedljivi in omogočajo visoko kakovost prevodov. </para>
	<sect1 id="i18n_general"
><title
>Splošni premisleki</title>
		<para
>V nasprotju s tem je treba razumeti eno pomembno točko o prevodih programske opremev nasprotju s prevodi drugih besedilnih gradiv, je, da prevajalci pogosto precej težko dobijo popolno sliko <emphasis
>kar</emphasis
> prevajajo. Prevodi programske opreme nujno temeljijo na precejkratkih fragmentih besedila: vsaka oznaka, ki jo daste <command
>&lt;option&gt;</command
> v <command
>&lt;radio&gt;</command
>, vsak niz, ki ga označiteza prevajanje v klicu funkcije <command
>i18n()</command
>, bo oblikoval ločeno "prevajalska enota". V bistvu bo vsak tak fragment predstavljen prevajalcu ločeno. No, ne popolna izolacija, kot poskušamo prevajalcu zagotoviti čim več smiselnega konteksta ekstrahirano, samodejno. Toda na nekaterih točkah bodo potrebni prevajalci dodaten kontekst za razumevanje niza, zlasti tam, kjer so nizi kratki. </para>
	</sect1>
	<sect1 id="i18n_xml"
><title
>i18n v xml datotekah &rkward;</title>
		<para
>Pri &rkward; &XML; datotekah, bo i18n večinoma kar deloval. Če pišetevaš lasten <command
>.pluginmap</command
> (&eg; za <link linkend="external_plugins"
>zunanji vtičnik</link
>), boste morali podati <replaceable
>po_id</replaceable
> poleg <replaceable
>id-ja datoteke pluginmap vtičnika </replaceable
>. To definira »katalog sporočil« za uporabo. Na splošno to mora biti nastavljen tako, kot je <replaceable
>id</replaceable
> vašega<command
>.pluginmap</command
>, vendar če podate več povezanih <command
>.pluginmap</command
> v enem paketu, boste verjetno želeli določitiskupni <replaceable
>po_id</replaceable
> v vaših mapah. <replaceable
>po_id</replaceable
> datoteke <command
>.pluginmap</command
> podedujejo vsi vtičniki, ki so deklarirani v njem, razen če to izjavi drugače <replaceable
>po_id</replaceable
>. </para>
		<para
>Za vtičnike in strani s pomočjo vam ni treba povedati &rkward; katere nize je treba prevesti, ker je to na splošno razvidno iz njihove rabe. Vendar, kot je razloženo zgoraj, morate biti pozorni na nize, ki bi lahkobiti dvoumni ali potrebujejo razlago, da bi bili pravilno prevedeni. Za nize, ki bi lahko imeli različne pomene, navedite <replaceable
>i18n_context</replaceable
> takole: </para>
		<programlisting
>&lt;checkbox id="scale" label="Scale" i18n_context="Prikaži merilo"/&gt; &lt;checkbox id="scale" label="Scale" i18n_context="Umeri risbo"/&gt;
                </programlisting>
		<para
>Zagotavljanje <replaceable
>i18n_context</replaceable
> bo povzročilo dva nizaprevedena ločeno. Sicer bi si delila en sam prevod. Poleg tega je kontekst prikazan prevajalcu. <replaceable
>i18n_context</replaceable
>-atribut je podprt na vsehelementih, ki imajo lahko prevedljive nize, nekje, vključno z elementi, ki vsebujejo besedilo (npr.<command
>&lt;text&gt;</command
>-elementi). </para>
		<para
>V drugih primerih ima niz za prevod en sam nedvoumen pomen, vendar bo morda še vedno potrebno nekaj razlage. V tem primeru lahko dodate komentar, ki bo prikazan prevajalcem. Primeri lahko vključujejo: </para>
		<programlisting
>&lt;!-- i18n: No, this is not a typo for screen plot! --&gt;
&lt;component id="scree_plot" label="Scree plot"/&gt;

&lt;!-- i18n: If you can, please make this string short. Having more than some 15 chars
looks really ugly at this point, and the meaning should be mostly self-evident to the
user (selection from a list of values shown next to this element) --&gt;
&lt;valueslot id="selected" label="Pick one"/&gt;
                </programlisting>
		<para
>Upoštevajte, da morajo biti taki komentarji pred elementom, na katerega se nanašajo, in se morajozačeti z "i18n:" ali "TRANSLATORS:". </para>
		<para
>Nazadnje, v redkih primerih boste morda želeli izključiti določene nize iz prevoda. To je morda smiselno, če na primer ponudite izbiro med več &R; imeni funkcij v kontrolniku <command
>&lt;radio&gt;</command
>.Potem ne želite, da se prevajajo (vendar odvisno od konteksta, raje razmislite o opisni oznaki): </para>
		<programlisting
>&lt;radio id="transformation" label="R function to apply"&gt;
  &lt;option id="as.list" noi18n_label="as.list()"/&gt;
  &lt;option id="as.vector" noi18n_label="as.vector()"/&gt;
  [...]
&lt;/radio&gt;
                </programlisting>
		<para
>Upoštevajte, da boste izpustili atribut <replaceable
>label</replaceable
>,nato in namesto tega podajte <replaceable
>noi18n_label</replaceable
>. tudiupoštevajte, da v nasprotju z <replaceable
>i18n_context</replaceable
> inkomentarjev, bo uporaba <replaceable
>noi18n_label</replaceable
> vašvtičnik ni združljiv z različicami &rkward; pred 0.6.3. </para>
	</sect1>
	<sect1 id="i18n_js"
><title
>i18n v &rkward; datotekah in razdelkih js</title>
		<para
>V nasprotju z datotekami <literal role="extension"
>.xml</literal
> ustvarjanjedatoteke <literal role="extension"
>.js</literal
> vtičnika, ki ga je mogoče prevestizahteva več dela po meri. Ključna razlika je v tem, da ni spodobnega samodejnega načina ugotavljanja, ali naj bo niz prikazan kot človeku berljiv niz ali kot del kode. Torej morate to označiti vi. Ves čas smo že kazali primere tega. Tukaj je bolj popoln opis funkcij i18n, ki so na voljo v kodi js, in nekaj namigov za bolj zapletene primere: </para>
<variablelist>
<varlistentry>
	<term
><command
>i18n (msgid, [...])</command
></term>
	<listitem
><para
>Najpomembnejša funkcija. Označi niz za prevod. Niz (ne glede na to, ali je preveden ali ne) je vrnjen označen z dvojnimi narekovaji ('"'). V nizu lahko uporabite poljubno število ograd, kot je prikazano spodaj.Uporaba takšnih nadomestnih mest namesto veriženja majhnih podnizov je veliko lažja za prevajalce:</para>
		<programlisting
>i18n ("Compare objects %1 and %2", getString ('x'), getString ('y'));
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18nc (msgctxt, msgid, [...])</command
></term>
	<listitem
><para
>Enako kot <command
>i18n()</command
>, a dodatno nudi kontekst sporočila:</para>
		<programlisting
>i18nc ("proper name, not state of mind", "Mood test");
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18np (msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
>Enako kot <command
>i18n()</command
>, vendar za sporočila, ki se lahko razlikujejo v edninski ali množinski obliki (in nekateri jeziki razlikujejo še več številskih oblik). Upoštevajte, da tako kot pri <command
>i18n()</command
>, lahko uporabite poljubno število zamenjav, vendar prva ('%1') jeobvezna in mora biti celo število.</para>
		<programlisting
>i18np ("Comparing a single pair", "Comparing %1 distinct pairs", n_pairs);
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18ncp (msgctxt, msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
><command
>i18np()</command
> z dodanim kontekstom sporočila.</para
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>comment (comment, [indentation])</command
></term>
	<listitem
><para
>Odmeva komentar kode, označen za prevod. V nasprotju z drugimi i18n() funkcijami, to ni v narekovajih, vendar je v vsako vrstico komentarja dodano '#'.</para>
		<programlisting
>comment ("Transpose the matrix");
                        echo ('x &lt;- t (x)\n');
                </programlisting
></listitem>
</varlistentry>
</variablelist>
	<para
>Za dodajanje komentarjev prevajalcem (glejte <link linkend="i18n_xml"
>zgoraj</link
> za razpravo o razlikah med komentarjem in kontekstom), dodajte komentar, ki se začne z "i18n:" ali "translators:" neposredno nad<command
>i18n()</command
>-pokliči za komentiranje. Npr.:​ </para>
	<programlisting
>// i18n: Spelling is correct: Scree plot.
                echo ('rk.header (' + i18n ("Scree plot") + ')\n');
        </programlisting>

		<sect2 id="i18n_js_quoting"
><title
>i18n in citati</title>
			<para
>Večinoma vam ne bo treba skrbeti za vedenje i18n() glede spoštovanja do citatov. Ker so običajno prevedljivi nizi nizovni literali, njihovo citiranje je prava stvar in vam prihrani nekaj tipkanja. V funkcijah, kot je <command
>makeHeaderCode()/Header()</command
>, ki običajno citirate njihove argumente, so nizi v i18n() zaščiteni pred podvajanjem citiranja. V bistvu to deluje tako, da se najprej pošlje prevedeni niz skozi <command
>quote()</command
> (da bo citiran), nato skozi<command
>noquote()</command
> (za zaščito pred dodatnim citiranjem). Če potrebujete prevedljiv niz, ki ni v narekovajih, uporabite <command
>i18n(noquote ("Moje sporočilo"))</command
>. Če potrebujete prevodniza, ki ga želite navesti, ga drugič pošljite prek <command
>quote()</command
>, <emphasis
>dvakrat</emphasis
>. </para>
			<para
>Kljub temu na splošno ni dobra ideja, da bi imena funkcij ali spremenljivk poimenovali tako, di bi bili prevedljivi. Prvič, &R;, je programski jezik, po naravi v angleščini in ni internacionalizacije samega jezika. Komentarji kode so drugačna stvar, vendar bi morali za to uporabitifunkcijo <command
>comment()</command
>. Drugič, izdelavasintaktično relevantnega dela ustvarjene kode prevedljivo pomeni, daprevodi lahko dejansko pokvarijo vaš vtičnik. Npr. če nič hudega slutečprevajalnik prevede niz, ki je mišljen kot ime spremenljivke, v dva različni besedi s presledkom vmes. </para>
		</sect2>
	</sect1>
	<sect1 id="i18n_workflow"
><title
>Vzdrževanje prevoda</title>
		<para
>Zdaj, ko ste svoj vtičnik naredili prevedljivega, kako ga dejansko dobite prevedenega? Na splošno vas mora to skrbeti le, ko razvijate <link linkend="external_plugins"
> zunanji vtičnik</link
>. Za vtičnike vglavnem skladišču &rkward;, je vsa čarovnija narejena namesto vas. Tukaj je osnovapotek dela za zunanje vtičnike. Upoštevajte, da potrebujete nameščena orodja "gettext": </para>
		<itemizedlist>
			<listitem
><para
>Označite vse nize, po potrebi zagotovite kontekst in komentarje</para
></listitem>
			<listitem
><para
>Zaženite <command
>python3 scripts/update_plugin_messages.py --extract-only /path/to/my.pluginmap</command
>. scripts/update_plugin_messages.py trenutno ni del izvornih izdaj, a se ga da najti v izvleku repozitorija.</para
></listitem>
			<listitem
><para
>Distribuiraj dobljeni <command
>rkward__<replaceable
>POID</replaceable
>.pot</command
> vašim prevajalcem. Za zunanje vtičnike priporočamo, da ga postavite v podmapo "po" v inst/rkward.</para
></listitem>
			<listitem
><para
>Prevajalec odpre datoteko v prevajalskem orodju, kot je <command
>lokalize</command
>. Pravzaprav, tudi če ne boste pripravili nobenega prevoda,sami, poskusite ta korak sami. Brskajte po izvlečenih nizi, da poiščete morebitne težave / dvoumnosti.</para
></listitem>
			<listitem
><para
>Prevajalec shrani prevod kot <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> (kjer je <replaceable
>xx</replaceable
> koda jezika) in pošlje nazaj k vam.</para
></listitem>
			<listitem
><para
>Kopirajte <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> v svoje vire poleg<command
>rkward__<replaceable
>POID</replaceable
>.pot</command
>. Poženite <command
>python3 scripts/update_plugin_messages.py /path/to/my.pluginmap</command
> (Opomba: tokrat brez <replaceable
>--extract-only</replaceable
>). To bo združilo prevod z vsemi vmesnimi spremembami niza, prevediteprevod in ga namestite v<command
><replaceable
>DIR_OF_PLUGINMAP</replaceable
>/po/<replaceable
>xx</replaceable
>/LC_MESSAGES/rkward__<replaceable
>POID</replaceable
>.mo</command
> (kjer <replaceable
>xx</replaceable
> je spet koda jezika).</para
></listitem>
			<listitem
><para
>Prav tako morate vključiti neprevedeni prevod (&ie; <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
>) v svojo distribucijo v podimeniku »po«. .</para
></listitem>
			<listitem
><para
>Za vsako posodobitev vtičnika zaženite <command
>skripte python3/update_plugin_messages.py /path/to/my.pluginmap</command
> za posodobitev .potdatoteko, temveč tudi obstoječe datoteke .po in prevedene kataloge sporočil.</para
></listitem>
		</itemizedlist>
	</sect1>
	<sect1 id="i18n_translators"
><title
>Pisanje prevodov vtičnikov</title>
		<para
>Predvidevamo, da poznate svoj prevajalski poklic ali pa ste pripravljeni prebrati to, drugje. Nekaj besed posebej o prevodih &rkward; dodatkov pa: </para>
		<itemizedlist>
			<listitem
><para
>&rkward; vtičnikov ni bilo mogoče prevajati do različice 0.6.3 in večinomaprej niso bili napisani z i18n v mislih. Tako se boste srečaliprecej več dvoumnih nizov in drugih i18n težav kot v drugih zrelih projekti. Prosimo, da tiho delate okoli teh težav, ampak nam (alivzdrževalcem vtičnikov) dajte vedeti za to, da lahko odpravimo te težave.</para
></listitem>
			<listitem
><para
>Veliko &rkward; vtičniki se nanašajo na visoko specializirane izraze, od obdelave podatkovin statistike, pa tudi z drugih področij znanosti. V mnogih primerih bo dober prevod zahteval vsaj osnovno poznavanje teh področij. V nekaterih primerih <emphasis
>ni</emphasis
> dobrega prevoda za tehnični izraz, najboljša možnost pa je lahko, da izraz pustite nepreveden ali da vključite angleški izraz v oklepaju. Ne osredotočajte se preveč na 100 % oznake prevedenih nizov, se osredotočite na zagotavljanje dobrega prevoda, tudi če to pomeni preskok nekaterih nizov (ali celo preskok nekaterih katalogov sporočil kotcelota). Drugi uporabniki bodo morda lahko zapolnili morebitne tehnične vrzeli.</para
></listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="chapter_about_information">
<title
>Informacije o avtorju, licenci in različici</title>
<para
>Torej ste napisali niz vtičnikov in se pripravljate na <link linkend="external_plugins"
>delite svoje delo</link
>. Da bi zagotovili, da bodo uporabniki vedeli, kaj je vaše delo, pod kakšnimi pogoji lahko uporabljajo in ga distribuirajo in na koga naj se obrnejo glede težav ali idej, dodate nekaj informacij <emphasis
>o</emphasis
> vaših vtičnikih. To lahko storite z elementom <command
>&lt;about&gt;</command
>. Lahko se uporablja bodisi v &pluginmap; ali v posameznem vtičniku <literal role="extension"
>.xml</literal
> (v obeh primerih kot neposredni podrejeni datotekioznaka dokumenta). Ko je podano v &pluginmap; veljalo bo za vsevtičniki. Če je <command
>&lt;about&gt;</command
> podan na obeh mestih,informacije <command
>&lt;about&gt;</command
> v vtičniku <literal role="extension"
>.xml</literal
> bo preglasila tisto v datoteki &pluginmap;. Dodate lahko tudi element <command
>&lt;about&gt;</command
> v .rkh-strani, ki niso povezane z vtičnikom, če je to potrebno.</para>
<para
>Tukaj je primer &pluginmap; datoteko z le nekaj pojasnili spodaj. V primeru dvoma lahko več informacij dobite pri referenci.</para>
<programlisting
>&lt;document 
        namespace="rkward"
        id="SquaretheCircle_rkward"
&gt;
        &lt;about 
                name="Square the Circle"
                shortinfo="Squares the circle using Heisenberg compensation."
                version="0.1-3"
                releasedate="2011-09-19"
                url="http://eternalwondermaths.example.org/23/stc.html"
                license="GPL"
                category="Geometry"
        &gt;
                &lt;author 
                        given="E.A."
                        family="Dölle"
                        email="doelle@eternalwondermaths.example.org"
                        role="aut"
                 /&gt;
                &lt;author 
                        given="A."
                        family="Assistant"
                        email="alterego@eternalwondermaths.example.org"
                        role="cre, ctb"
                 /&gt;
        &lt;/about&gt;
        &lt;dependencies&gt;
                ...
        &lt;/dependencies&gt;
        &lt;components&gt;
                ...
        &lt;/components&gt;
        &lt;hierarchy&gt;
                ...
        &lt;/hierarchy&gt;
&lt;/document&gt;
</programlisting>
<para
>Večino tega je treba razložiti samo po sebi, zato ne bomo razpravljali o vsaki oznaki elementa posebej. Toda poglejmo nekaj podrobnosti, ki verjetno potrebujejo nekaj komentarja za lažje razumevanje. </para>
<para
>Element <parameter
>category</parameter
> v <command
>&lt;about&gt;</command
> je mogoče definirati precej prosto, vendar bi moral biti smiseln, kot jenaj bi se uporabljal za razvrščanje vtičnikov v skupine. Vsi drugi atributi v tej začetni oznaka so obvezni in morajo biti napolnjeni z razumno vsebino. </para>
<para
>Vsaj en <command
>&lt;author&gt;</command
> z veljavnim e-poštnim naslovom mora biti podan tudi vloga <quote
>aut</quote
> (<quote
>avtor</quote
>) mora biti podana. V primeru, da vaš vtičnik povzroča težave ali bi ga kdo želel deliti z drugimi hvaležnost z vami, mora biti enostavno vzpostaviti stik z nekom, ki je vpleten. Za dodatne informacije o drugih veljavnih vlogah, kot je <quote
>ctb</quote
> za kodoprispevke ali <quote
>cre</quote
> za vzdrževanje paketa, glejte<ulink url="http://stat.ethz.ch/R-manual/R-patched/library/utils/html/person.html"
>R dokumentacija o <function
>person()</function
></ulink
>. </para>
<note
><para
>Ne pozabite, da lahko uporabite <command
>&lt;include&gt;</command
> in / ali<command
>&lt;insert&gt;</command
> za ponavljanje informacij v več<literal role="extension"
>.xml</literal
> datoteke (&eg; informacije oavtorju, ki je sodeloval pri več vtičnikih). <link linkend="sect_similar_plugins"
>Več informacij</link
>.</para
></note>
<tip
><para
>Ni vam treba napisati tega &XML; kodo ročno. Če uporabljate funkcijo <function
>rk.plugin.skeleton()</function
> iz paketa <link linkend="rkwarddev"
><application
>rkwarddev</application
></link
> in zagotovite vse potrebne informacije prek <parameter
>about</parameter
> bo samodejno ustvaril &pluginmap; datoteka z delujočim razdelkom &lt;o programu&gt; za vas.</para
></tip>
</chapter>

<chapter id="external_plugins">
<title
>Delite svoje delo z drugimi</title>
<sect1 id="sect_external_plugins"
><title
>Zunanji vtičniki</title>
	<para
>Od različice 0.5.5 je &rkward; zagotavlja udoben način namestitve dodatnih vtičnikov tretjih oseb, ki ne sodijo v sam osnovni paket. Tem pravimo <quote
>zunanji vtičniki</quote
>. Pridejo v obliki &R; paketa in ga je mogoče upravljati neposredno prek običajnega upravljanja paketov značilnosti &R; in/ali &rkward;. </para>
	<para
>Ta razdelek dokumentacije opisuje, kako naj bodo zunanji vtičniki pakirani, tako da jih &rkward; lahko uporablja. Sama izdelava vtičnika je seveda enaka prejšnjim razdelkom. Se pravi, verjetno bi moralinajprej napišite delujoč vtičnik in se nato vrniti sem, če želite izvedeti, kako ga distribuirati. </para>
	<para
>Ker so zunanji vtičniki razmeroma mlada funkcija, bi se lahko podrobnosti o tem verjetno spremenile v prihodnjih izdajah. Vabimo vas, da prispevate svoje ideje, da bi izboljšati postopek. </para>
	<tip>
		<para
>Ti dokumenti pojasnjujejo podrobnosti zunanjih vtičnikov, da se lahko naučite, kako jih delujejo. Poleg tega si oglejte tudi <link linkend="rkwarddev"
><application
>rkwarddev</application
> paket</link
>, ki je bil zasnovan za avtomatizacijo velikega dela procesa pisanja. </para>
	</tip>
</sect1>
<sect1 id="why_external_plugins">
<title
>Zakaj zunanji vtičniki?</title>
	<para
>Število paketov za razširitev funkcionalnosti &R; je že zdaj neizmerno in raste. Po eni strani vas želimo spodbuditi k pisanju vtičnikov tudi za najbolj specializirane naloge, ki jih potrebujete. Na drugi strani se povprečen uporabnik ne bi smel izgubiti v ogromnih drevesih menijev, polnih neznanih statističnih izrazov. Zato se je zdelo smiselno ohraniti vtičnik obdelava v &rkward; tudi precej modularen. Ekipa &rkward; ohranja svoje lastno javno skladišče paketov na <ulink url="https://files.kde.org/rkward/R/"
>https://files.kde.org/rkward/R/</ulink
>, določeno za gostovanje vaših zunanjih vtičnikov. </para>
	<para
>Praviloma velja, da vtičniki, za katere se zdi, da služijo široko uporabljenemu namenu (&eg; t-testi) bi morali postati del osrednjega paketa, medtem ko tisti, ki služijo bolj omejeni skupini ljudi s posebnimi interesi, naj bi bili na voljo kot izbirni paket. Za vas kot avtorja vtičnika je najboljša praksa, da samo začnite z zunanjim vtičnikom. </para>
</sect1>
  
<sect1 id="structure_of_a_plugin_package">
<title
>Struktura paketa vtičnikov</title>
	<para
>Za pravilno namestitev in pravilno delovanje zunanjih vtičnikov morajo slediti nekaterim strukturnim smernicam glede njihove hierarhije datotek. </para>
    
	<sect2 id="file_hierarchy"
><title
>Hierarhija datotek</title>
		<para
>Oglejmo si prototipno hierarhijo datotek dodelanega vtičnika v arhivu. Ni vam treba vključiti vseh teh imenikov in/ali datotek za vtičnik za delo (preberite, če želite izvedeti, kaj je nujno potrebno), razmisliteo tem kot na primer <quote
>najboljše prakse</quote
>: </para>
		<programlisting
>plugin_name/
                inst/
                        rkward/
                                plugins/
                                        plugin_name.xml
                                        plugin_name.js
                                        plugin_name.rkh
                                        ...
                                po/
                                        ll/
                                                LC_MESSAGES/
                                                        rkward__plugin_name_rkward.mo
                                        rkward__plugin_name_rkward.ll.po
                                        rkward__plugin_name_rkward.pot
                                tests/
                                        testsuite_name/
                                                RKTestStandards.sometest_name.rkcommands.R
                                                RKTestStandards.sometest_name.rkout
                                                ...
                                        testsuite.R
                                plugin_name.pluginmap
                                ...
        ChangeLog
        README
        AUTHORS
        LICENSE
        DESCRIPTION
                </programlisting>
		<note>
			<para
>V tem primeru morajo vsi pojavi <token
>plugin_name</token
>,<token
>testsuite_name</token
> in <token
>sometest_name</token
> biti ustrezno nadomeščeni s svojimi pravilnimi imeni. Tudi <token
>ll</token
> je namesto za jezikovno okrajšavo (&eg;, <quote
>de</quote
>, <quote
>en</quote
> ali <quote
>es</quote
>). </para>
		</note>
		<tip>
			<para
>Te hierarhije datotek vam ni treba ustvariti ročno. Če uporabljatefunkcijo <function
>rk.plugin.skeleton()</function
> iz <link linkend="rkwarddev"
><application
>rkwarddev</application
> paketa</link
>, bosamodejno ustvari vse potrebne datoteke in imenike, razen imenika <filename
>po</filename
>, ki ga ustvari in upravlja <link linkend="i18n_workflow"
>skript za prevajanje</link
>. </para>
		</tip>
		<sect3 id="basic_plugin_components">
		<title
>Osnovne komponente vtičnika</title>
			<para
>Obvezno je vključiti vsaj tri datoteke: a <link linkend="pluginmap"
>&pluginmap;</link
>, vtičnik <link linkend="mainxml"
>.xml</link
>opis in datoteko vtičnika <link linkend="jstemplate"
>.js</link
>. to je celo imenik "plugins" neobvezen. Morda bi le pomagalo dati vaše datoteke v nekem redu, še posebej, če vključite več kot en vtičnik v pogovorno okno v arhivu, kar seveda ni problem. Lahko imate imenike za dejanske datoteke vtičnikov, kot se vam zdi primerno, preprosto morajo podobni <link linkend="pluginmap"
>&pluginmap;</link
>.Prav tako je mogoče celo vključiti več &pluginmap; datotek, če ustreza za vaše potrebe, vendar jih morate potem vse vključiti v <quote
>plugin_name.pluginmap</quote
>. </para>
			<para
>Vsak &R; paket mora imeti veljavno datoteko <filename
>DESCRIPTION</filename
>,kar je ključnega pomena tudi za &rkward; ga prepoznajo kot ponudnika vtičnikov. Večina informacij, ki jih nosi, je potreben tudi v vtičniku <link linkend="chapter_about_information"
>Meta-information</link
> in morda <link linkend="chapter_dependencies"
>dependencies</link
>, vendar v drugem formatu (dokumentacija &R; pojasnjuje <ulink url="http://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file"
> <filename
>DESCRIPTION</filename
> datoteka s podrobnostmi</ulink
>). </para>
			<para
>Poleg splošne vsebine <filename
>DESCRIPTION</filename
> ne pozabite vključiti tudi vrstice <quote
>Enhances: rkward</quote
>.To bo povzročilo &rkward; da samodejno pregleda paket za vtičnike, če jeje nameščen. Primer datoteke <filename
>DESCRIPTION</filename
> je videti takole: </para>
			<programlisting
>Package: SquaretheCircle
        Type: Package
        Title: Square the circle
        Version: 0.1-3
        Date: 2011-09-19
        Author: E.A. Dölle &lt;doelle@eternalwondermaths.example.org&gt;
        Maintainer: A. Assistant &lt;alterego@eternalwondermaths.example.org&gt;
        Enhances: rkward
        Description: Squares the circle using Heisenberg compensation.
        License: GPL
        LazyLoad: yes
        URL: http://eternalwondermaths.example.org/23/stc.html
        Authors@R: c(person(given="E.A.", family="Dölle", role="aut",
                        email="doelle@eternalwondermaths.example.org"),
                        person(given="A.", family="Assistant", role=c("cre",
                        "ctb"), email="alterego@eternalwondermaths.example.org"))
                        </programlisting>
			<tip>
				<para
>Te datoteke vam ni treba pisati ročno. Če uporabljate funkcijo<function
>rk.plugin.skeleton()</function
> iz <link linkend="rkwarddev"
><application
>rkwarddev</application
> paket</link
> in zagotovite vsepotrebne informacije prek možnosti <quote
>o</quote
>, bosamodejno ustvaril delujočo datoteko <filename
>DESCRIPTION</filename
> za vas. </para>
			</tip>
		</sect3>
		<sect3 id="additional_information">
		<title
>Dodatne informacije (neobvezno)</title>
			<para
><filename
>Dnevnik sprememb</filename
>, <filename
>README</filename
>,<filename
>AUTHORS</filename
>, <filename
>LICENSE</filename
> bi morale biti samo po sebi razumljive in so v celoti neobvezne. Pravzaprav jih ne bo tolmačil &rkward;, zato so bolj namenjeni prenašanju dodatnih informacij, ki bi lahko bile relevantne &eg; za distributerje. Večina njihove ustrezne vsebine (avtorji, licenčni pogoji itd.) bodo vključeni v dejanski vtičnik datoteke vseeno (glejte <link linkend="chapter_about_information"
>razdelek o metainformacijah</link
>). Upoštevajte, da lahko vse te datoteke postavite tudi nekje v imenik "inst", če jih ne želite samo, da je prisoten v izvornem arhivu, ampak tudi v nameščenem paketu. </para>
		</sect3>
		<sect3 id="automated_plugin_testing">
		<title
>Samodejno testiranje vtičnika (izbirno)</title>
			<para
>Drug izbirni imenik je "tests", ki je namenjen zagotavljanju datotekpotrebno za <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>samodejno testiranje vtičnikov</ulink
>. Titesti so koristni za hitro preverjanje, ali vaši vtičniki še vedno delujejo z novimirazličicami &R; ali &rkward;. Če želite vključiti teste, se morate res omejiti se na shemo poimenovanja in hierarhijo, prikazano tukaj. To je, da morajo biti testi v imeniku z imenom <filename
>tests</filename
>, kivključuje datoteko <filename
>testsuite.R</filename
> in mapo s standardi testov, poimenovani po ustreznem testnem nizu. Lahko pa zagotovite več kot ena zbirka testov; v tem primeru, če jih ne želite pripeti vseh v eni datoteki <filename
>testsuite.R</filename
> jih lahko razdelite v &eg;eno datoteko za vsak preskusni paket in ustvarite en <filename
>testsuite.R</filename
>s klici <function
>source()</function
> za vsako datoteko zbirke. V kateremkoli primeru ustvarite ločene podimenike s testnimi standardi za vsak definiran skupek. </para>
			<para
>Prednost vzdrževanja te strukture je, da je mogoče izvajati teste vtičnikov preprosto s klicem <function
>rktests.makplugintests()</function
> iz paketa <ulink url="rkward://rhelp/rkwardtests"
>rkwardtests</ulink
> brez dodatnih argumentov. Oglejte si spletno dokumentacijo o<ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>Samodejno testiranje vtičnikov</ulink
> za nadaljnje podrobnosti. </para>
		</sect3>
	</sect2>
</sect1>
  
	<sect1 id="building_the_plugin_package">
		<title
>Gradnja paketa vtičnikov</title>
		<para
>Kot je bilo že razloženo, so zunanji vtičniki &rkward; v veljavi &R; paketi, zato je postopek pakiranja enak. V nasprotju s "pravim" &R;  paketom, čisti paket vtičnikov ne nosi nobenih nadaljnje &R; Kode (čeprav lahko seveda dodate &rkward; vtičniki za običajno &R; paketi kot, z uporabo istih metod, ki so razložene tukaj). To bi moralo biti celo lažje ustvariti delujoč paket, če imate veljavno<filename
>DESCRIPTION</filename
> in se držite hierarhije datotek razloženo v <link linkend="structure_of_a_plugin_package"
>prejšnjem razdelku</link
>.</para>
		<para
>Najlažji način, da dejansko zgradite in preizkusite svoj vtičnik, je uporabaukaza <application
>R</application
> v ukazni vrstici, na primer:</para>
		<para
><userinput
><command
>R</command
> <option
>CMD build</option
> <parameter
><filename
>SquaretheCircle</filename
></parameter
> </userinput
></para>
		<para
><userinput
><command
>R</command
> <option
>CMD INSTALL</option
> <parameter
><filename
>SquaretheCircle_0.1-3.tar.gz</filename
></parameter
> </userinput
></para>
		<tip
><para
>Paketa vam ni treba graditi v ukazni vrstici. Če uporabite funkcijo <function
>rk.build.package()</function
> iz <link linkend="rkwarddev"
><application
>rkwarddev</application
> paket</link
>,bo namesto vas zgradil in/ali preveril vaš paket vtičnikov.</para
></tip>
	</sect1>
</chapter>

<chapter id="rkwarddev">
	<title
>Razvoj vtičnika s paketom <application
>rkwarddev</application
></title>
	<sect1 id="rkdev_overview"
><title
>Pregled</title>
		<para
>Pisanje zunanjih vtičnikov vključuje pisanje datotek v treh jezikih (&XML;,&javascript; in R) ter ustvarjanje standardizirane hierarhije imenikov. Da bi bilo to veliko lažje za voljne razvijalce vtičnikov, smo zagotovili paket <application
>rkwarddev</application
>. Zagotavlja število preprostih &R; funkcij za ustvarjanje datoteke &XML; koda za vsa pogovorna okna elemente, kot so zavihki, potrditvena polja, spustni seznami ali brskalniki datotek kot funkcije za ustvarjanje &javascript; kode in &rkward; datoteke pomoči za začetek. Funkcija <function
>rk.plugin.skeleton()</function
> ustvaripričakovano drevo imenikov in vse potrebne datoteke, kjer naj bi bile biti.</para>
		<para
>Ta paket ni privzeto nameščen, ampak ga je treba namestiti ročno iz <ulink url="https://files.kde.org/rkward/R/"
>&rkward; repozitorija</ulink
>. To lahko storite z &GUI; vmesnikom  (<menuchoice
><guimenu
>Nastavitve</guimenu
><guimenuitem
>Konfiguriraj pakete</guimenuitem
></menuchoice
>) ali iz katere koli tekoče &R; seje:</para>
		<programlisting
>install.packages("rkwarddev", repos="https://files.kde.org/rkward/R")
                library(rkwarddev)
                </programlisting>
		<para
><application
>rkwarddev</application
> je odvisen od drugega klicanega majhnega paketa<quote
>XiMpLe</quote
>, ki je zelo preprost &XML; razčlenjevalnik in generator terprisoten tudi v istem skladišču.</para>
		<para
>Tam lahko najdete tudi celotno <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev.pdf"
>dokumentacijo v formatu PDF</ulink
>. Podrobnejši uvod v delo s paketom najdete v <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev_vignette.pdf"
>vinjeto rkwarddev</ulink
>.</para>
	</sect1>

	<sect1 id="rkdev_example"
><title
>Praktični primer</title>
		<para
>Da boste dobili idejo, kako izgleda <quote
>skriptiranje vtičnika</quote
>,v primerjavi z neposrednim pristopom, ki ste ga videli v prejšnjih poglavjih, bomo ponovno ustvarili celoten vtičnik t-test -- tokrat samo z &R; funkcijami paketa <application
>rkwarddev</application
>.</para>

		<tip
><para
>Paket bo dodal novo &GUI; pogovorno okno za &rkward; pod <menuchoice
><guimenu
>Datoteka</guimenu
><guimenuitem
>Izvoz</guimenuitem
><guimenuitem
>Ustvari &rkward; skript vtičnika</guimenuitem
></menuchoice
>. Kot že ime pove, lahko ustvarite okostja vtičnikov za nadaljnje urejanje z njim. To pogovorno okno je nato ustvaril <application
>rkwarddev</application
> skript, ki ga najdete v <quote
>demo</quote
> imeniku nameščenega paketa in izvornih paketov,kot dodaten primer. Zaženete ga lahko tudi tako, da pokličete <function
>demo("skeleton_dialog")</function
></para
></tip>

		<sect2 id="rkdev_gui"
><title
>&GUI; opis</title>
		<para
>Takoj boste opazili, da je potek dela precej drugačen: v nasprotju z neposrednim pisanjem kode XML ne začnete z definicijo <command
>&lt;document&gt;</command
>, temveč neposredno z elementi vtičnika, ki jih želite imeti v dialogu. Vsak element vmesnika - naj bodo to potrditvena polja, spustni meniji, spremenljive reže ali karkoli drugega - lahko dodelite posameznim &R; objektom in nato združite te objekte v dejanski &GUI;. Paket ima funkcije za <link linkend="interfaceelements"
>vsako oznako XML</link
>, ki jo je mogoče uporabiti za definiranje vtičnika &GUI;, in večina jih ima celo isto ime, le s predpono <function
>rk. XML.*</function
>. Na primer definiranje <command
>&lt;varselector&gt;</command
> in dveh elementov <command
>&lt;varslot&gt;</command
> za <replaceable
>"x"</replaceable
> in <replaceable
>"y"</replaceable
> primera t-testa lahko izvedete tako:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE, id.name="x")
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE, id.name="y")
                </programlisting>
		<para
>Najbolj zanimiva podrobnost je verjetno <parameter
>source=</parameter
><replaceable
>spremenljivke</replaceable
>: Pomembna značilnost paketa je, da lahko vse funkcije ustvarijo samodejne ID-je, tako da vam ni treba razmišljati o nobeni njihovi vrednosti <parameter
>id</parameter
> ali si jih zapomniti, da se nanašajo na določeni element vtičnika. Lahko preprosto podate &R; predmete kot referenca, kot vse funkcije, ki potrebujejo ID nekega drugega elementa, ga lahko tudi preberejo iz teh predmetov. <function
>rk.XML.varselector()</function
> je malo poseben, saj običajno nima posebne vsebine, iz katere bi lahko naredil ID (lahko, vendar le, če določite oznako), zato moramo nastaviti ime ID-ja. Toda <function
>rk.XML.varslot()</function
> ne potrebuje <parameter
>id.name</parameter
>argumentov tukaj, tako da bi to zadostovalo:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
                </programlisting>
		<para
>Če želite ponovno ustvariti primer kode do točke, bi morali nastavitivse ID vrednosti ročno. Ker pa nam bo paket olajšal življenje,od zdaj naprej nam to ne bo več mar.</para>
		<tip>
			<para
><application
>rkwarddev</application
> je zmožen veliko avtomatizacije, da vam pomaga zgraditi vaše vtičnike. Vendar je morda bolje, da ga ne uporabite v polni meri. Če je vaš cilj ustvariti kodo, ki ne deluje lelahko pa ga tudi človek zlahka prebere in primerja z vašim generatorskim skriptom bi morali razmisliti o tem, da vedno nastavite uporabne ID-je s <parameter
>id.name</parameter
>. Poimenovanje vašega &R; predmeti, ki so enaki tem ID-jem, bodo prav tako pomagali k pridobivanju skriptne kode, ki je lahko razumljiva. </para>
		</tip>
		<para
>Če želite videti, kako je videti koda XML definiranega elementa, če želite jo izvozite v datoteko, lahko predmet preprosto pokličete po njegovem imenu. Torej, če ste klicali <quote
>var.x</quote
> v vaši &R; seji, bi morali videti nekaj podobnega:</para>
		<programlisting
>&lt;varslot id="vrsl_compare" label="primerjaj" source="vars" types="number" required="true" /&gt;
                </programlisting>
		<para
>Nekatere oznake so uporabne le v kontekstu drugih. Zato je npr.ne boste našli funkcije za oznako <command
>&lt;option&gt;</command
>.Namesto tega so opredeljeni izbirni gumbi in spustni seznami, vključno z njihovimi možnostmi kot poimenovan seznam, kjer imena predstavljajo oznake, ki bodo prikazane vpogovornem oknu, njihova vrednost pa je imenovan vektor, ki ima lahko dva vnosa,<parameter
>val</parameter
> za vrednost možnosti in logično vrednost<parameter
>chk</parameter
>, da določite, ali je ta možnost privzeto označena.</para>
		<programlisting
>test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
        options=list(
                "Two-sided"=c(val="two.sided"),
                "First is greater"=c(val="greater"),
                "Second is greater"=c(val="less")
        )
)
                </programlisting>
		<para
>Rezultat je videti takole:</para>
		<programlisting
>&lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
        &lt;option label="Two-sided" value="two.sided" /&gt;
        &lt;option label="First is greater" value="greater" /&gt;
        &lt;option label="Second is greater" value="less" /&gt;
&lt;/radio&gt;
                </programlisting>
		<para
>Vse, kar manjka elementom zavihka <quote
>Osnovne nastavitve</quote
>, je potrditveno polje za seznanjene vzorce in strukturiranje vseh teh elementov v vrsticah in stolpcih: ​</para>
		<programlisting
>check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))
                </programlisting>
		<para
><function
>rk.XML.cbox()</function
> je redka izjema, kjer ime funkcije ne vsebuje celotnega imena oznake, da prihranite nekaj tipkanja za ta pogosto uporabljen element. To zdaj vsebuje <function
>basic.settings</function
>: </para>
		<programlisting
>&lt;row id="row_vTFSPP10TF"&gt;
        &lt;varselector id="vars" /&gt;
        &lt;column id="clm_vrsTFSPP10"&gt;
                &lt;varslot id="vrsl_compare" label="compare" source="vars" types="number" required="true" /&gt;
                &lt;varslot id="vrsl_against" label="against" i18n_context="compare against" source="vars" types="number" required="true" /&gt;
                &lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
                        &lt;option label="Two-sided" value="two.sided" /&gt;
                        &lt;option label="First is greater" value="greater" /&gt;
                        &lt;option label="Second is greater" value="less" /&gt;
                &lt;/radio&gt;
                &lt;checkbox id="chc_Pardsmpl" label="Paired sample" value="1" value_unchecked="0" /&gt;
        &lt;/column&gt;
&lt;/row&gt;
                </programlisting>
		<para
>Na podoben način bodo naslednje vrstice ustvarile &R; objekti za elemente zavihka <quote
>Možnosti</quote
>, ki predstavljajo funkcije za spinboxe, okvirje in raztezanje: </para>
		<programlisting
>check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")
                </programlisting>
		<para
>Vse, kar moramo storiti, je, da objekte združimo v zavihek in ga postavimo v pogovorno okno: </para>
		<programlisting
>full.dialog &lt;- rk.XML.dialog(
        label="Two Variable t-Test",
        rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
)
                </programlisting>
		<para
>Ustvarimo lahko tudi razdelek čarovnika z dvema stranema z uporabo istih predmetov, tako da bodo njuni ID-ji ekstrahirani za oznake <command
>&lt;copy&gt;</command
>:</para>
		<programlisting
>full.wizard &lt;- rk.XML.wizard(
                label="Two Variable t-Test",
                rk.XML.page(
                        rk.XML.text("As a first step, select the two variables you want to compare against
                                each other. And specify, which one you theorize to be greater. Select two-sided,
                                if your theory does not tell you, which variable is greater."),
                        rk.XML.copy(basic.settings)),
                rk.XML.page(
                        rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                variables have equal variances. An appropriate correction will be applied then.
                                Choosing \"assume equal variances\" may increase test-strength, however."),
                        rk.XML.copy(check.eqvar),
                        rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                the difference in means. Below you can specify whether one should be shown, and
                                which confidence-level should be applied (95% corresponds to a 5% level of
                                significance)."),
                        rk.XML.copy(conf.frame)))
                </programlisting>
		<para
>To je to za &GUI;. Globalni dokument bo na koncu združil <function
>rk.plugin.skeleton()</function
>.</para>
		</sect2>

		<sect2 id="rkdev_jscode"
><title
>&javascript; Koda</title>
			<para
>Do zdaj se je morda zdelo, da uporaba paketa <application
>rkwarddev</application
> ni veliko pomagala. To se bo prav zdaj spremenilo.</para>
			<para
>Prvič, tako kot nam ni bilo treba skrbeti za ID-je elementov pri definiranju &GUI; postavitve, nam ni treba skrbeti za &javascript; imena spremenljivk v naslednjem koraku. Če želite več nadzora, lahko napišete navadno kodo &javascript;in jo prilepite v ustvarjeno datoteko. Verjetno pa je veliko učinkoviteje to narediti na način <application
>rkwarddev</application
>.</para>
			<para
>Predvsem vam ni treba sami definirati nobene spremenljivke, saj lahko <function
>rk.plugin.skeleton()</function
> skenira vaš &XML; kodo in samodejno definira vse spremenljivke, ki jih boste verjetno potrebovali -- na primer, ne da bi se trudili vključiti potrditvenega polja, če pozneje ne uporabite njegove vrednosti ali stanja. Tako lahko začnemo pisati dejansko &R; kodo, ki takoj ustvari JS.</para>
			<tip
><para
>Funkcija <function
>rk.JS.scan()</function
> lahko skenira tudi obstoječe &XML; datoteke za spremenljivke.</para
></tip>
			<para
>Paket ima nekaj funkcij za konstrukte kode JS, ki se pogosto uporabljajo v &rkward; vtičniki, kot je funkcija <function
>echo()</function
> ali pogoji <function
>if() {...} else {...}</function
>. Med JS in &R; je nekaj razlik, &eg; za <function
>paste()</function
> v &R; vejico uporabljate za združevanje znakovnih nizov, medtem ko za <function
>echo()</function
> v JS uporabljate <quote
>+</quote
>, vrstice pa se morajo končati s podpičjem. Z uporabo &R; funkcije, lahko skoraj pozabite na te razlike in še naprej pišete &R; kodo.</para>
			<para
>Te funkcije lahko sprejmejo različne razrede vhodnih objektov: bodisi golo besedilo, &R; predmeti z &XML; kodo, kot je zgoraj, ali pa rezultate nekaterih drugih funkcij JS paketa. Na koncu boste vedno poklicali <function
>rk.paste.JS()</function
>, ki se obnaša podobno kot <function
>paste()</function
>, vendar jih bo glede na vhodne objekte nadomestil z njihovimi &XML; ID, &javascript; ime spremenljivke ali celo celoten &javascript; kodni bloki.</para>
			<para
>Za primer t-testa potrebujemo dva predmeta JS: enega za izračun rezultatov in enega za njihovo tiskanje v funkciji <function
>printout()</function
>:</para>
		<programlisting
>JS.calc &lt;- rk.paste.JS(
        echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
        js(
                if(check.paired){
                        echo(", paired=TRUE")
                },
                if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                },
                if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                },
                linebreaks=TRUE
        ),
        echo(")\n"),
        level=2
)

JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)
                </programlisting>
		<para
>Kot lahko vidite, <application
>rkwarddev</application
> nudi tudi &R; implementacija funkcije <function
>echo()</function
>. Vrne natanko en niz znakov s svojo veljavno različico JS. Morda boste tudi opazili, da so vsi &R; predmeti tukaj tisti, ki smo jih ustvarili že prej. Samodejno bodo nadomeščeni s svojimi imeni spremenljivk, zato bi moralo biti to precej intuitivno. Kadarkoli potrebujete samo to zamenjavo, lahko uporabite funkcijo <function
>id()</function
>, ki prav tako vrne natanko en niz znakov iz vseh objektov, ki jih je prejel (lahko bi rekli, da se obnaša kot <function
>paste( )</function
> z zelo specifično zamenjavo predmeta).</para>
    <para
>Funkcija <function
>js()</function
> je ovoj, ki vam omogoča uporabo <command
>if(){...} else {...}</command
> pogojev &R;, kot ste jih že uporabljali. Prevedeni bodo neposredno v kodo JS. Ohranja tudi nekatere operatorje, kot so <command
>&lt;</command
>, <command
>&gt;=</command
> ali <command
>||</command
>, tako da lahko logično primerjate svoje &R; predmetov, ne da bi večino časa morali navajati. Oglejmo si nastali objekt <quote
>JS.calc</quote
>, ki zdaj vsebuje niz znakov s to vsebino:</para>
		<programlisting
>echo("res &lt;- t.test (x=" + vrslCompare + ", y=" + vrslAgainst + ", hypothesis=\"" + radUsngtsth + "\"");
        if(chcPardsmpl) {
                echo(", paired=TRUE");
        } else {}
        if(!chcPardsmpl &amp;&amp; chcAssmqlvr) {
                echo(", var.equal=TRUE");
        } else {}
        if(spnCnfdnclv != "0.95") {
                echo(", conf.level=" + spnCnfdnclv);
        } else {}
        echo(")\n");
                </programlisting>
    <note>
      <para
>Druga možnost je za ugnezdene pogoje <function
>if()</function
> v<function
>js()</function
>, lahko uporabite <function
>ite()</function
>funkcijo, ki se obnaša podobno kot &R;-jeva <function
>ifelse()</function
>.Vendar so pogojni stavki, izdelani z uporabo <function
>ite()</function
>običajno težje berljivi in jih je treba zamenjati s <function
>js()</function
> kadar koli je to mogoče. </para>
    </note>
		</sect2>

		<sect2 id="rkdev_pluginmap"
><title
>Mapa vtičnikov</title>
		<para
>Ta razdelek je zelo kratek: ni nam treba napisati &pluginmap; sploh, ker ga samodejno lahko ustvari <function
>rk.plugin.skeleton()</function
>. Hierarhijo menija je mogoče določiti prek <parameter
>pluginmap</parameter
> možnosti:</para>
			<programlisting
>[...]
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test"))
        [...]
                        </programlisting>
		</sect2>

		<sect2 id="rkdev_rkh"
><title
>Stran s pomočjo</title>
			<para
>Tudi ta razdelek je zelo kratek: <function
>rk.plugin.skeleton()</function
> ne more napisati celotne strani pomoči iz informacij, ki jih ima. Lahko pa skenira &XML; dokument tudi za elemente, ki si verjetno zaslužijo vnos strani s pomočjo, in samodejno ustvari predlogo strani s pomočjo za naš vtičnik. Vse, kar moramo storiti kasneje, je, da napišemo nekaj vrstic za vsak naveden razdelek.</para>
			<tip
><para
>Funkcija <function
>rk.rkh.scan()</function
> lahko skenira tudi obstoječe &XML; datotek za ustvarjanje okostja datoteke pomoči.</para
></tip>
		</sect2>

		<sect2 id="rkdev_plugin_generator"
><title
>Ustvarite datoteke vtičnika</title>
			<para
>Zdaj prihaja zadnji korak, v katerem bomo vse ustvarjene objekte predali <function
>rk.plugin.skeleton()</function
>:</para>
			<programlisting
>plugin.dir &lt;- rk.plugin.skeleton("t-Test",
        xml=list(
                dialog=full.dialog,
                wizard=full.wizard),
        js=list(
                results.header="Two Variable t-Test",
                calculate=JS.calc,
                printout=JS.print),
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test")),
        load=TRUE,
        edit=TRUE,
        show=TRUE)
                        </programlisting>
			<para
>Datoteke bodo privzeto ustvarjene v časovnem imeniku. Zadnje tri možnosti niso potrebne, vendar so zelo priročne: <parameter
>load=</parameter
><replaceable
>TRUE</replaceable
> samodejno doda nov vtičnik &rkward; konfiguraciji (ker je v začasnem imeniku in zato bo prenehal obstajati, ko je &rkward; zaprt, ga bo &rkward; ob naslednjem zagonu znova samodejno odstranil), <parameter
>edit=</parameter
><replaceable
>TRUE</replaceable
> bo odprl vse ustvarjene datoteke za urejanje v &rkward; zavihki urejevalnika in <parameter
>show=</parameter
><replaceable
>TRUE</replaceable
> bo poskušal neposredno zagnati vtičnik, tako da lahko brez klika preverite, kako je videti. Razmislite o dodajanju <parameter
>overwrite=</parameter
><replaceable
>TRUE</replaceable
>, če boste svoj skript večkrat zagnali (&eg; po spremembah kode), saj privzeto nobena datoteka ne bo prepisana.</para>
			<para
>Objekt rezultata <quote
>plugin.dir</quote
> vsebuje pot do imenika, v katerem je bil ustvarjen vtičnik. To je lahko uporabno v kombinaciji s funkcijo <function
>rk.build.package()</function
> za izdelavo dejanskega &R; paket za skupno rabo vtičnika z drugimi -- &eg; tako, da ga pošljete na &rkward; razvojno ekipo, ki bo dodana v naše skladišče vtičnikov.</para>
		</sect2>
		<sect2 id="rkdev_ttest_script"
><title
>Celoten scenarij</title>
		<para
>Če povzamemo vse zgoraj navedeno, je tukaj celoten skript za ustvarjanje delujočega primera t-testa. Poleg že razložene kode tudi naloži paket, če je potrebno, in uporablja okolje <function
>local()</function
>, tako da vsi ustvarjeni objekti ne bodo končali v vašem trenutnem delovnem prostoru (razen <quote
> plugin.dir</quote
>):</para>
		<programlisting
>require(rkwarddev)

local({
        variables &lt;- rk.XML.varselector(id.name="vars")
        var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
        var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
        test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
                options=list(
                        "Two-sided"=c(val="two.sided"),
                        "First is greater"=c(val="greater"),
                        "Second is greater"=c(val="less")
                )
        )
        check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
        basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))

        check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
        conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
        check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
        conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")

        full.dialog &lt;- rk.XML.dialog(
                label="Two Variable t-Test",
                rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
        )

        full.wizard &lt;- rk.XML.wizard(
                        label="Two Variable t-Test",
                        rk.XML.page(
                                rk.XML.text("As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater."),
                                rk.XML.copy(basic.settings)),
                        rk.XML.page(
                                rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing \"assume equal variances\" may increase test-strength, however."),
                                rk.XML.copy(check.eqvar),
                                rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance)."),
                                rk.XML.copy(conf.frame)))

        JS.calc &lt;- rk.paste.JS(
                echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
                js(
                        if(check.paired){
                        echo(", paired=TRUE")
                        },
                        if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                        },
                        if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                        },
                        linebreaks=TRUE
                ),
                echo(")\n"), level=2)

        JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)

        plugin.dir &lt;&lt;- rk.plugin.skeleton("t-Test",
                xml=list(
                        dialog=full.dialog,
                        wizard=full.wizard),
                js=list(
                        results.header="Two Variable t-Test",
                        calculate=JS.calc,
                        printout=JS.print),
                pluginmap=list(
                        name="Two Variable t-Test",
                        hierarchy=list("analysis", "means", "t-Test")),
                load=TRUE,
                edit=TRUE,
                show=TRUE,
                overwrite=TRUE)
})
                </programlisting>
		</sect2>

  </sect1>
  <sect1 id="rkwarddev_rkh"
><title
>Dodajanje strani s pomočjo</title>
    <para
>Če želite napisati stran s pomočjo za svoj vtičnik, najbolj preprosti način za to je, da dodate posebna navodila neposredno v definicije &XML; elementi, ki jim pripadajo: </para>
    <programlisting
>variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse.",
  component="Data"
)
    </programlisting>
    <para
>Besedilo, podano parametru <parameter
>help</parameter
>, lahko nato pridobi <function
>rk.rkh.scan()</function
> in ga zapiše na stran s pomočjo te komponente vtičnika. Da bi to tehnično delovalo, pa mora <function
>rk.rkh.scan()</function
> vedeti, kateri &R; objekti pripadajo eni komponenti vtičnika. Zato morate zagotoviti tudi parameter <parameter
>component</parameter
> in zagotoviti, da je enak za vse predmete, ki pripadajo skupaj. </para>
    <para
>Ker boste običajno združili veliko predmetov v eno pogovorno okno in boste morda želeli tudi ponovno uporabiti predmete, kot je <command
>&lt;varslot&gt;</command
>, v več komponentah vaših vtičnikov, je mogoče komponento globalno definirati s funkcijo <function
>rk.set.comp()</function
>. Če je nastavljeno, se predpostavlja, da vsi naslednji objekti, uporabljeni v vašem skriptu, pripadajo tej določeni komponenti, dokler <function
>rk.set.comp()</function
> ni ponovno poklicana z drugim imenom komponente. Nato lahko izpustite parameter <parameter
>component</parameter
>: </para>
    <programlisting
>rk.set.comp("Data")
variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse."
)
    </programlisting>
    <para
>Če želite na stran s pomočjo dodati globalne razdelke, kot je <command
>&lt;summary&gt;</command
> ali <command
>&lt;usage&gt;</command
>, uporabite funkcije, kot je <function
>rk.rkh.summary()</function 
> ali <function
>rk.rkh.usage()</function
> ustrezno. Njihovi rezultati se nato uporabijo za nastavitev elementov seznama, kot je <parameter
>summary</parameter
> ali <parameter
>usage</parameter
> v parametru <parameter
>rkh</parameter
> funkcije <function
>rk.plugin.component() </function
>/<function
>rk.plugin.skeleton()</function
>. </para>
	</sect1>
  <sect1 id="rkwarddev_i18n"
><title
>Prevajanje vtičnikov</title>
    <para
>Paket <application
>rkwarddev</application
> lahko ustvari zunanje vtičnike s polno podporo za i18n. Na primer, vse ustrezne funkcije, ki generirajo objekte XML, ponujajo izbirni parameter za podajanje <replaceable
>i18n_context</replaceable
> ali <replaceable
>noi18n_label</replaceable
>: </para>
    <programlisting
>varComment &lt;- rk.XML.varselector(id.name="vars", i18n=list(comment="Glavni izbirnik spremenljivk")) varContext &lt;- rk.XML.varselector(id.name="vars", i18n =list(context="Izbirnik glavne spremenljivke")) cboxNoi18n &lt;- rk.XML.cbox(label="Moč", id.name="moč", i18n=FALSE)
    </programlisting>
    <para
>Zgornji primeri ustvarijo rezultat, kot je ta:</para>
    <programlisting
># varComment
&lt;!-- i18n: Main variable selector --&gt;
  &lt;varselector id="vars" /&gt;

# varContext
&lt;varselector id="vars" i18n_context="Main variable selector" /&gt;

# cboxNoi18n
&lt;checkbox id="power" noi18n_label="Power" value="true" /&gt;
    </programlisting>
    <para
>Obstaja tudi podpora za prevedljivo kodo JS. Pravzaprav poskuša paket privzeto dodati klice <function
>i18n()</function
> na mestih, kjer je to običajno koristno. Funkcija <function
>rk.JS.header()</function
> je dober primer: </para>
    <programlisting
>jsHeader &lt;- rk.JS.header("Rezultati testa")
    </programlisting>
    <para
>To ustvari naslednjo kodo JS:</para>
    <programlisting
>new Header(i18n("Rezultati testa")).print();
    </programlisting>
    <para
>Lahko pa tudi ročno označite nize v vaši kodi JS kot prevedljive z uporabo funkcije <function
>i18n()</function
> tako kot bi to storili, če bi datoteko JS napisali neposredno.</para>
  </sect1>
</chapter>

<appendix id="reference">
<title
>Referenca</title>

<sect1 id="propertytypes"
><title
>Vrste lastnosti/Modifikatorji</title>
<para
>Na nekaterih mestih v tem uvodu smo govorili o <quote
>lastnostih</quote
> &GUI; elementov ali kako drugače. Pravzaprav obstaja več različnih vrst nepremičnin. Običajno vam to ni treba skrbeti, saj lahko po zdravi pameti katero koli nepremičnino povežete s katero koli drugo lastnino. Vendar pa znotraj obstajajo različne vrste lastnosti. To je pomembno pri pridobivanju nekaterih posebnih vrednosti v predlogi JS. V stavkih getString ("id")/getBoolean ("id")/getList ("id") lahko podate tudi nekaj tako imenovanih <quote
>modifikatorjev</quote
>, kot je ta: <function
>getString ("id.modifier" )</function
>. Ta modifikator bo vplival na način tiskanja vrednosti. Preberite si seznam lastnosti in modifikatorje, ki jih dajejo na voljo: </para>
<variablelist>
<varlistentry>
<term
>Lastnosti niza</term>
<listitem
><para
>Najbolj preprosta vrsta lastnosti, ki se uporablja za preprosto držanje dela besedila. Modifikatorji: <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Niz, kot je definiran / nastavljen.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>citiran</term>
	<listitem
><para
>Niz v narekovajih (primeren za prenos v &R; kot znak).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Logične lastnosti</term>
<listitem
><para
>Lastnosti, ki so lahko vklopljene ali izklopljene, resnične ali napačne. Na primer lastnosti, ustvarjene z oznakami &lt;convert&gt;, tudi lastnost, ki spremlja &lt;potrditveno polje&gt; (glej spodaj). Glede na dani modifikator bodo vrnjene naslednje vrednosti: <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Lastnost bo privzeto vrnila 1, če je res, in 0 v nasprotnem primeru. Priporočen način pridobivanja logičnih vrednosti je uporaba <function
>getBoolean()</function
>. Upoštevajte, da bo za <function
>getString()</function
> niz "0" vrnjen, ko je lastnost napačna. Ta niz bi bil v JS ovrednoten kot true, ne kot false.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"labeled"</term>
	<listitem
><para
>Vrne niz »true«, če je true, »false«, če je false ali kateri koli niz po meri, ki je bil določen (običajno v &lt;potrditvenem polju&gt;).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"true"</term>
	<listitem
><para
>Vrne niz, kot da bi bila lastnost true, tudi če je false</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"false"</term>
	<listitem
><para
>Vrne niz, kot da bi bila lastnost false, tudi če je true</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"not"</term>
	<listitem
><para
>To dejansko vrne drugo logično lastnost, ki je obratna od trenutne (&ie; false, če je true, true, če je false)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"numeric"</term>
	<listitem
><para
>Zastarelo, predvideno za združljivost za nazaj. Enako kot brez modifikatorja "". Vrni "1", če je lastnost true, ali "0", če je false.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Lastnosti celega števila</term>
<listitem
><para
>Lastnost, zasnovana tako, da hrani celoštevilsko vrednost (seveda pa še vedno vrne številski niz znakov predlogi JS). Ne sprejema nobenih modifikatorjev. Uporablja se v &lt;spinbox&gt;es (glejte spodaj)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>Lastnosti realnega števila</term>
<listitem
><para
>Lastnost, zasnovana tako, da hrani vrednost realnega števila (seveda pa še vedno vrne številski niz znakov v predlogo JS). Uporablja se v &lt;spinbox&gt;es (glejte spodaj) <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Za <function
>getValue() / getString()</function
> to vrne enako kot "formatted". V prihodnjih različicah bo namesto tega mogoče pridobiti številčno predstavitev.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"formatted"</term>
	<listitem
><para
>Vrne oblikovano število (kot niz).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Lastnosti RObject</term>
<listitem
><para
>Lastnost je oblikovala izbor enega ali več &R; predmetov. Najpogosteje se uporablja v varselectors in varslots. Glede na dani modifikator bodo vrnjene naslednje vrednosti: <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Privzeto bo lastnost vrnila polno ime izbranega predmeta. Če je izbran več kot en predmet, bodo imena predmetov ločena s prelomi vrstic ("\n").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"shortname"</term>
	<listitem
><para
>Kot zgoraj, vendar vrne le kratka imena za objekte. Na primer, predmet znotraj seznama bi dobil samo ime, ki ga ima znotraj seznama, brez imena seznama.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"label"</term>
	<listitem
><para
>Kot zgoraj, vendar vrne &rkward; oznaka(e) predmeta(ov) (če oznaka ni na voljo, je to isto kot kratko ime)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Lastnosti seznama nizov</term>
<listitem
><para
>Ta lastnost vsebuje seznam nizov. <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Za <function
>getValue()/getString()</function
> to vrne vse nize, ločene z "\n". Any "\n" v vsakem elementu so ubežni kot dobesedni "\n". Vendar je priporočena uporaba namesto tega pridobivanje vrednosti s funkcijo <function
>getList()</function
>, ki bo vrnila niz nizov.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"joined"</term>
	<listitem
><para
>Vrne seznam kot en sam niz z elementi, združenimi z "\n". V nasprotju z brez modifikatorja ("") posamezni nizi _ne_ ubežijo.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Lastnosti kode</term>
<listitem
><para
>Lastnost vtičnikov, ki so ustvarili kodo. To je pomembno za vdelovalne vtičnike, da lahko vdelate kodo, ki jo ustvari vdelani vtičnik, v kodo, ki jo ustvari vtičnik (najvišje ravni). Glede na dani modifikator bodo vrnjene naslednje vrednosti: <variablelist>
	<varlistentry>
	<term
>Brez modifikatorja ("")</term>
	<listitem
><para
>Vrne celotno kodo, &ie; razdelki "preprocess", "calculate", "printout" in (toda ne "preview") sestavljeni v en niz.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preprocess"</term>
	<listitem
><para
>Vrne le predprocesni del kode</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"calculate"</term>
	<listitem
><para
>Vrne samo odsek kode za izračun</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"printout"</term>
	<listitem
><para
>Vrne le izpisni del kode</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preview"</term>
	<listitem
><para
>Vrne razdelek predogleda kode</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="globalxmlelements">
	<title
>Elementi splošnega namena za uporabo v kateri koli &XML; datoteki (<literal role="extension"
>.xml</literal
>, <literal role="extension"
>.rkh</literal
>, &pluginmap;)</title>
	<variablelist>
	<varlistentry>
	<term
>&lt;snippets&gt;</term>
	<listitem
><para
>Dovoljeno kot neposredni podrejeni element &lt;dokumenta&gt; vozlišče in samo tam. Postavljen naj bo blizu vrha datoteke. Glejte <link linkend="snippets"
>razdelek o uporabi odlomkov</link
>. Samo en &lt;odlomek&gt; element je lahko prisoten. Izbirno, brez atributov.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;snippet&gt;</term>
	<listitem
><para
>Določa en sam delček. Dovoljeno samo kot neposredni podrejeni element &lt;nippets/&gt; element. Lastnosti: <variablelist
> <varlistentry>
		<term
>&lt;id&gt;</term>
		<listitem
><para
>Identifikacijski niz za delček. Obvezno.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;insert&gt;</term>
	<listitem
><para
>Vstavi vsebino &lt;snippet&gt;. Dovoljeno povsod. Lastnosti: <variablelist
> <varlistentry>
		<term
>&lt;snippet&gt;</term>
		<listitem
><para
>Identifikacijski niz delčka, ki ga želite vstaviti. Obvezno.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;include&gt;</term>
	<listitem
><para
>Vključi vsebino druge &XML; datoteka (vse znotraj elementa &lt;document&gt; te datoteke). Dovoljeno povsod. Lastnosti: <variablelist
> <varlistentry>
		<term
>&lt;file&gt;</term>
		<listitem
><para
>Ime datoteke glede na imenik, v katerem je trenutna datoteka. Zahtevano.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	</variablelist>
</sect1>

<sect1 id="xmlelements"
><title
>Elementi za uporabo v &XML; opis vtičnika</title>
<para
>Lastnosti elementov so navedene v <link linkend="elementproperties"
>ločenem razdelku</link
>.</para>

<sect2 id="generalelements"
><title
>Splošni elementi</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Prisoten mora biti v vsaki datoteki description.xml kot korensko vozlišče. Brez posebne funkcije. Brez atributov</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Informacije o tem vtičniku (avtor, licenca itd.). Ta element je dovoljen v datoteki <literal role="extension"
>.xml</literal
> posameznega vtičnika in v &pluginmap; datoteke. Glejte <link linkend="pluginmapelements"
>&pluginmap; sklic na datoteko</link
> za podrobnosti o sklicu, <link linkend="chapter_about_information"
>poglavje o informacijah 'o'</link
> za uvod.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;code&gt;</term>
<listitem
><para
>Določa, kje iskati predlogo JS za vtičnik. Uporabite samo enkrat na datoteko kot neposredni podrejeni element oznake dokumenta. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Ime datoteke predloge JS glede na imenik, v katerem je plugin-xml</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;help&gt;</term>
<listitem
><para
>Določa, kje iskati datoteko pomoči za vtičnik. Uporabite samo enkrat na datoteko kot neposredni podrejeni element oznake dokumenta. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Ime datoteke za pomoč glede na imenik, v katerem je plugin-xml</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;copy&gt;</term>
<listitem
><para
>Lahko se uporablja kot podrejeni (neposredni ali posredni) glavnih elementov postavitve, &ie; &lt;pogovorno okno&gt; in &lt;čarovnik&gt;. To se uporablja za kopiranje celotnega bloka &XML; elementi 1:1. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID, ki ga je treba iskati. &lt;copy&gt; bo iskal prejšnji &XML; element, ki je dobil isti ID, in ga kopirajte, vključno z vsemi podrejenimi elementi.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>copy_element_tag_name</parameter
></term>
	<listitem
><para
>V nekaj primerih boste želeli skoraj dobesedno kopijo, vendar spremenite ime oznake elementa za kopiranje. Najpomembnejši primer tega je, ko želite kopirati celoten &lt;tab&gt; iz pogovornega vmesnika na &lt;stran&gt; vmesnika čarovnika. V tem primeru bi nastavili copy_element_tag_name="stran" za samodejno pretvorbo.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="interfaceelements"
><title
>Definicije vmesnikov</title>
<variablelist>
<varlistentry>
<term
>&lt;dialog&gt;</term>
<listitem
><para
>Definira vmesnik pogovornega okna tipa dialog. Postavite &GUI; definicija znotraj te oznake. Uporabite samo enkrat na datoteko kot neposredni podrejeni element oznake dokumenta. Za vtičnik je potrebna vsaj ena od oznak "dialog" ali "wizard". Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Napis za pogovorno okno</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>Ali naj se pogovorno okno uporabi kot "recommended - priporočeni" vmesnik (&ie; vmesnik, ki bo privzeto prikazan, razen če je uporabnik &rkward; konfiguriral tako, da privzeto uporablja določen vmesnik)? Ta atribut trenutno nima učinka, saj je implicitno "true", razen če je priporočen čarovnik.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;wizard&gt;</term>
<listitem
><para
>Definira vmesnik vrste čarovnika. Postavite &GUI; definicijo znotraj te oznake. Uporabite samo enkrat na datoteko kot neposredni podrejeni element oznake dokumenta. Za vtičnik je potrebna vsaj ena od oznak "dialog" ali "wizard". Sprejme samo &lt;page&gt; ali &lt;embed&gt;-oznake kot neposredni podrejene. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Napis za čarovnika</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>Ali naj se čarovnik uporablja kot "recommended - priporočen" vmesnik (&ie; vmesnik, ki bo prikazan privzeto, razen če je uporabnik konfiguriral &rkward; za privzeti vmesnik)? Izbirno, privzeto je "false".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="layoutelements"
><title
>Elementi postavitve</title>
<para
>Vsi elementi v tem razdelku sprejemajo atribut id="identifierstring". Ta atribut je neobvezen za vse elemente. Uporabite ga lahko na primer za skrivanje/onemogočanje celotnega elementa postavitve in vseh elementov, ki jih vsebuje (glejte <link linkend="logic"
>poglavje &GUI; logic</link
>). Id-string ne sme vsebovati "." (pike) ali ";" (podpičja) in bi moralo biti na splošno omejeno na alfanumerične znake in podčrtaj (»_«). Navedeni so le dodatni atributi.</para>
<variablelist>
<varlistentry>
<term
>&lt;page&gt;</term>
<listitem
><para
>Določa novo stran v čarovniku. Dovoljeno samo kot neposredni podrejeni element elementa &lt;wizard&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;row&gt;</term>
<listitem
><para
>Vsi neposredni podrejeni elementi oznake "row - vrstica" bodo postavljeni od leve proti desni.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;column&gt;</term>
<listitem
><para
>Vsi neposredni podrejeni elementi oznake "column - stolpec" bodo postavljeni od zgoraj navzdol.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;stretch&gt;</term>
<listitem
><para
>Privzeto so elementi v &GUI; zasedejo ves razpoložljivi prostor. Na primer, če imate dva stolpca drug ob drugem, je levi poln elementov, desni pa vsebuje samo en ukaz <command
>&lt;radio&gt;</command
>, nadzor <command
>&lt;radio&gt;</command
> se bo razširil navpično, čeprav v resnici ne potrebuje razpoložljivega prostora, in videti bo bo grdo. V tem primeru res želite dodati "blank" pod <command
>&lt;radio&gt;</command
>. Za to uporabite &lt;stretch&gt; element. Preprosto bo porabil nekaj prostora. Ne pretiravajte s tem elementom, običajno je dobra ideja za &GUI; elemente, da dobijo ves razpoložljivi prostor, le včasih bo postavitev razmaknjena. &lt;stretch&gt; element ne sprejema nobenih argumentov, niti "id". Prav tako ne smete postaviti otrok v &lt;stretch&gt; element (z drugimi besedami, vedno ga boste uporabljali samo kot "&lt;stretch/&gt;")</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Nariše okvir/polje okoli svojih neposrednih podrejenih elementov. Uporablja se lahko za vizualno združevanje povezanih možnosti. Postavitev znotraj okvirja je od zgoraj navzdol, razen če postavite &lt;row&gt; znotraj. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Napis za okvir (neobvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>Okvirje je mogoče narediti checkable - označljive. V tem primeru bodo vsi vsebovani elementi onemogočeni, ko okvir ni odkljukan, in omogočeni, ko je odkljukan. (izbirno, privzeto je "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Samo za okvirje vrste chackable: Ali naj bo okvir privzeto odkljukan? Privzeto je "true". Ni interpretirano za okvirje, ki niso checkable.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tabbook&gt;</term>
<listitem
><para
>Organizira elemente v tabbook - knjižico zavihkov. Sprejema le oznake &lt;tab&gt; kot neposredne podrejene.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tab&gt;</term>
<listitem
><para
>Določa stran v tabbook - knjižici zavihkov. Postavite &GUI; definicija za zavihek znotraj te oznake. Lahko se uporablja samo kot neposredni podrejeni element &lt;tabbook&gt; oznaka. &lt;tabbook&gt; mora imeti vsaj dva definirana zavihka. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Napis za stran zavihka (obvezno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Prikaže text besedilo, obdano s to oznako v &GUI;. Podprto je nekaj preprostih &HTML; slogovnih oznak (zlasti <markup
>&lt;b&gt;</markup
>, <markup
>&lt;i&gt;</markup
>, <markup
>&lt;p&gt;</markup
> in <markup
>&lt;br/&gt;</markup
>). Kljub temu naj bo formatiranje čim manjše. Vstavljanje popolnoma prazne vrstice doda trd prelom vrstice. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Vrsta besedila. Eno izmed "normalno", "warning" ali "error". To vpliva na videz besedila (neobvezno, privzeto je normalno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="activeelements"
><title
>Aktivni elementi</title>
<para
>Vsi elementi v tem razdelku sprejemajo atribut id="identifierstring". Ta atribut je obvezen za vse elemente. Navedeni so le dodatni atributi. Id-string ne sme vsebovati "." (pik).</para>
<variablelist>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Zagotavlja seznam razpoložljivih predmetov, med katerimi lahko uporabnik izbere enega ali več. Za uporabnost potrebuje enega ali več &lt;varslot&gt; kot protipostavko. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za varselector - izbirnik spremenljivk (neobvezno, privzeto je "Izberi spremenljivko(e)")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>Uporablja se v povezavi z "varselector", da uporabniku omogoči izbiro ene ali več spremenljivk. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za varslot (priporočeno, privzeto je "Variable:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source</parameter
></term>
	<listitem
><para
>Varselektor iz katerega pridobite izbor (obvezno, razen če se povežete ročno ali z uporabo source_property)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source_property</parameter
></term>
	<listitem
><para
>Poljubna lastnost za kopiranje vrednosti, ko kliknete gumb za izbiro. Če je navedeno, to preglasi atribut "source".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Ali je za oddajo kode potrebno, da ta varslot vsebuje veljavno vrednost. Oglejte si <link linkend="elementproperties"
>required-property</link
> (izbirno, privzeto je false)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>multi</parameter
></term>
	<listitem
><para
>Ali varslot vsebuje samo enega (privzeto, "false") ali več predmetov</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_duplicates</parameter
></term>
	<listitem
><para
>Ali sme varslot sprejeti samo edinstvene objekte (privzeto, »false«) ali če je lahko isti objekt dodan večkrat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars</parameter
></term>
	<listitem
><para
>Pomembno samo, če je multi="true": Najmanjše število spremenljivk, ki jih je treba izbrati, da bo izbor veljaven (neobvezno, privzeto je "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars_if_any</parameter
></term>
	<listitem
><para
>Pomembno samo, če je multi="true": nekatere reže varslot se lahko štejejo za veljavne, če je na primer reža varslot prazna ali vsebuje vsaj dve vrednosti. To določa, koliko spremenljivk mora biti izbranih, če sploh katere (2 v primeru). (izbirno, privzeto je "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_vars</parameter
></term>
	<listitem
><para
>Smiselno samo, če je multi="true": največje število spremenljivk za izbiro (neobvezno, privzeto je "0", kar pomeni, da ni največjega števila)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>razredi</parameter
></term>
	<listitem
><para
>Če podate enega ali več &R; imen razredov (ločena s presledki (" ")), bo varslot tukaj sprejemal samo predmete, ki pripadajo tem razredom (neobvezno, <emphasis
>uporabljajte zelo previdno</emphasis
>, uporabniku ne sme biti preprečeno sprejemanje veljavnih izbir in &R; ima <emphasis
>veliko</emphasis
> različnih razredov)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>vrste</parameter
></term>
	<listitem
><para
>Če podate eno ali več vrst spremenljivk (ločenih s presledki (" ")), bo tukaj varslot sprejel samo objekte teh vrst. Veljavni tipi so "unknown", "number", "string", "factor", "invalid". (Izbirno, <emphasis
>uporabljajte zelo previdno</emphasis
>, uporabniku ne bi smeli preprečiti veljavnih izbir in &rkward; ne pozna vedno vrste spremenljivke)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>num_dimensions</parameter
></term>
	<listitem
><para
>Število dimenzij, ki jih mora imeti objekt. "0" (privzeto) pomeni, da je sprejemljivo poljubno število dimenzij. (izbirno, privzeto je "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_length</parameter
></term>
	<listitem
><para
>Najmanjša dolžina, ki jo mora imeti predmet, da je sprejemljiv. (izbirno, privzeto je "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_length</parameter
></term>
	<listitem
><para
>Največja dolžina, ki jo mora imeti predmet, da je sprejemljiv. (izbirno, privzeto je največje celo število, ki ga je mogoče predstaviti v sistemu)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Zagotavlja seznam razpoložljivih nizov (ne &R; objektov), ki jih je treba izbrati v enem ali več spremljajočih &lt;valuesslot&gt;s. Možnosti nizov je mogoče definirati z uporabo oznak &lt;option&gt; kot neposredne podrejene (glejte spodaj) ali nastaviti z uporabo dinamičnih <link linkend="elementproperties"
>lastnosti</link
>. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za izbirnik vrednosti (neobvezno, privzeto ni oznake)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Uporablja se v povezavi z &lt;valueselector&gt; da uporabniku omogoči izbiro enega ali več elementov niza. Ta element je večinoma identičen &lt;varslot&gt; in ima enake atribute, razen tistih, ki se nanašajo na lastnosti sprejemljivih elementov (&ie; razredi, tipi, num_dimensions, min_length, max_length).</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Določa skupino radijskih ekskluzivnih gumbov (hkrati je mogoče izbrati samo enega). Zahteva vsaj dve oznaki &lt;option&gt; kot neposredne podrejene. Nobene druge oznake niso dovoljene kot podrejene. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za radijski nadzor (priporočeno, privzeto je »Izberite eno:«)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Določa skupino možnosti, od katerih je mogoče hkrati izbrati eno in samo eno s spustnim seznamom. To je funkcionalno enakovredno &lt;radio&gt;, vendar je videti drugače. Zahteva vsaj dve oznaki &lt;option&gt; kot neposredne podrejene. Nobene druge oznake niso dovoljene kot podrejene. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za spustni seznam (priporočeno, privzeto je »Izberite enega:«)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Zagotavlja seznam razpoložljivih nizov, iz katerih lahko uporabnik izbere poljubno število. Možnosti niza je mogoče definirati z uporabo oznak &lt;option&gt; kot neposredne podrejene (glejte spodaj) ali nastaviti z uporabo dinamičnih <link linkend="elementproperties"
>lastnosti</link
>. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za &lt;select&gt; (izbirno, privzeto ni oznake)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>single</parameter
></term>
	<listitem
><para
>Če je nastavljeno na true, bo mogoče izbrati samo eno vrednost namesto več vrednosti hkrati (boolean, privzeto je false)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Lahko se uporablja samo kot neposredni podrejeni element &lt;radio&gt;, &lt;dropdown&gt;, &lt;valueselector&gt; ali &lt;select&gt; element. Predstavlja eno izbirno možnost v radijskem nadzoru ali spustnem seznamu. Kot &lt;option&gt; elementi so vedno del enega od izbirnih elementov, običajno nimajo lastnega "id-ja", vendar glejte spodaj. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za možnost (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>Vrednost niza, ki jo bo nadrejeni element vrnil, če je ta možnost označena/izbrana (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Ali naj bo možnost označena/izbrana privzeto "true" ali "false". V &lt;radio&gt; ali &lt;dropdown&gt;, je lahko samo ena možnost nastavljena na <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, in če nobena možnost ni označena, bo prva možnost v nadrejenem elementu samodejno označeno/izbrano. V &lt;select&gt; je lahko izbranih poljubno število možnosti. (izbirno, privzeto je "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Določanje parametra "id" za &lt;option&gt; elementov ni obvezen (in pravzaprav je priporočljivo, da ne nastavite "id-ja", razen če ga res potrebujete). Vendar pa vam bo podajanje "id-ja" omogočilo, da dinamično omogočite/onemogočite &lt;option&gt;, tako da se povežete z logično lastnostjo <replaceable
>id_of_radio.id_of_optionX.enabled</replaceable
>. Trenutno to deluje za možnosti znotraj &lt;radio&gt; ali &lt;dropdown&gt; samo elementi; &lt;valueselector&gt; in &lt;select&gt; možnosti trenutno ne podpirajo ID-jev.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Določa potrditveno polje, &ie; eno samo možnost, ki jo je mogoče vklopiti ali izklopiti. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za potrditveno polje (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>Vrednost, ki jo potrditveno polje vrne, če je označeno (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value_unchecked</parameter
></term>
	<listitem
><para
>Vrednost, ki bo vrnjena, če potrditveno polje ni potrjeno (izbirno, privzeto je "", &ie; prazen niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Ali naj bo možnost privzeto potrjena "true" ali "false" (neobvezno, privzeto je "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Element okvirja se na splošno uporablja kot čisti element postavitve in je naveden v razdelku o <link linkend="layoutelements"
>elementih postavitve</link
>. Lahko pa ga tudi preverite, tako da hkrati deluje kot preprosto potrditveno polje. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Določa polje za prosti vnos besedila. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za vnosno polje (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Začetno besedilo besedilnega polja (neobvezno, privzeto je "", &ie; prazen niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>size</parameter
></term>
	<listitem
><para
>Eden izmed "small", "medium" ali "large". "large" definira večvrstično vnosno polje, "small in "medium" sta enovrstični polji (izbirno, privzeto je "medium")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Ali se za oddajo kode zahteva, da ta vnos ni prazen. Oglejte si <link linkend="elementproperties"
>required-property</link
> (izbirno, privzeto je false)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;matrix&gt;</term>
<listitem
><para
>Tabela za vnos matričnih podatkov (ali vektorjev) v &GUI;.</para
> <note
><para
>Ta vnosni element <emphasis
>ni</emphasis
> optimiziran za vnos/urejanje velikih količin podatkov. Čeprav ni stroge omejitve glede velikosti &lt;matrix&gt;, na splošno ne sme preseči približno desetih vrstic/stolpcev. Če pričakujete večje podatke, dovolite uporabnikom, da jih izberejo kot &R; objekt (kar je lahko dobra ideja kot alternativna možnost, v skoraj <emphasis
>vseh</emphasis
> primerih, kjer uporabljate matrični element).</para
></note
> <para
>Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za tabelo (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>način</parameter
></term>
	<listitem
><para
>Eno od "integer", "real" ali "string". Vrsta podatkov, ki bodo sprejeti v tabeli (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Najmanjša sprejemljiva vrednost (za matrike tipa "integer" ali "real") (neobvezno, privzeta vrednost je najmanjša predstavljiva vrednost)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Največja sprejemljiva vrednost (za matrike tipa "integer" ali "real") (neobvezno, privzeta vrednost je največja predstavljiva vrednost)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_missings</parameter
></term>
	<listitem
><para
>Ali so v matriki dovoljene manjkajoče (prazne) vrednosti. To je implicirano za matrike ali način "string" (neobvezno, privzeto je false).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_columns</parameter
></term>
	<listitem
><para
>Ko je nastavljeno na true, lahko uporabnik dodaja stolpce tako, da vnese v skrajno desne (neaktivne) celice (neobvezno, privzeto je true).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_rows</parameter
></term>
	<listitem
><para
>Ko je nastavljeno na true, lahko uporabnik dodaja vrstice s tipkanjem v najnižje (neaktivne) celice (izbirno, privzeto je true).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>rows</parameter
></term>
	<listitem
><para
>Število vrstic v matriki. Nima učinka za allow_user_resize_rows="true". <note
><para
>To lahko nadzirate tudi z nastavitvijo lastnosti "rows".</para
></note
> (izbirno, privzeto je 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>columns</parameter
></term>
	<listitem
><para
>Število stolpcev v matriki. Nima učinka za allow_user_resize_columns="true". <note
><para
>To lahko nadzirate tudi z nastavitvijo lastnosti "columns".</para
></note
> (izbirno, privzeto je 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Najmanjše število vrstic v matriki. Matrica se ne bo skrčila pod to velikost. (izbirno, privzeto je 0; glejte tudi: <parameter
>allow_missings</parameter
>.).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_columns</parameter
></term>
	<listitem
><para
>Najmanjše število stolpcev v matriki. Matrica se ne bo skrčila pod to velikost. (izbirno, privzeto je 0; glejte tudi: <parameter
>allow_missings</parameter
>.).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_height</parameter
></term>
	<listitem
><para
>Prisilite da &GUI; element ostane na začetni višini. Ne uporabljajte v kombinaciji z matricami, kjer se lahko število vrstic kakor koli spremeni. Uporabno, posebej pri ustvarjanju vektorskega vhodnega elementa (columns="1"). Če je ta možnost nastavljena na true, ne bo prikazan noben vodoravni drsnik, tudi če matrika presega razpoložljivo širino (ker bi to vplivalo na višino). (neobvezno, privzeto je false).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_width</parameter
></term>
	<listitem
><para
>Nekoliko napačno imenovan: Predpostavimo, da se število stolpcev ne bo spremenilo. Zadnji (ali običajno samo) stolpec bo raztegnjen, da zavzame razpoložljivo širino. Ne uporabljajte v kombinaciji z matrikami, kjer se lahko število stolpcev kakor koli spremeni. Uporabno, posebej pri ustvarjanju vektorskega vhodnega elementa (rows="1"). (neobvezno, privzeto je false).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>horiz_headers</parameter
></term>
	<listitem
><para
>Nizi za vodoravno glavo, ločeni z ";". Glava bo skrita, če je nastavljena na "". (izbirno, privzeto je številka stolpca).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>vert_headers</parameter
></term>
	<listitem
><para
>Nizi, ki se uporabljajo za navpično glavo, ločeni z ";". Glava bo skrita, če je nastavljena na "". (izbirno, privzeto številka vrstice).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;optionset&gt;</term>
<listitem
><para
>Uporabniški vmesnik za ponavljanje nabora možnosti za poljubno število elementov (<link linkend="optionset"
>uvod v nabore možnosti</link
>). Lastnosti:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Če je naveden, bo nabor označen kot neveljaven, razen če ima vsaj toliko vrstic (neobvezno, celo število).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows_if_any</parameter
></term>
	<listitem
><para
>Kot min_rows, vendar bo preizkušen le, če obstaja vsaj ena vrstica (neobvezno, celo število).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_rows</parameter
></term>
	<listitem
><para
>Če je določen, bo niz označen kot neveljaven, razen če ima največ to število vrstic (neobvezno, celo število).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>keycolumn</parameter
></term>
	<listitem
><para
>ID stolpca, ki bo deloval kot ključni stolpec. Nabor možnosti z (veljavnim) ključnim stolpcem bo deloval kot "nastavljen" nabor možnosti. Nabor možnosti brez ključnega stolpca bo omogočil ročno vstavljanje/odstranjevanje elementov. Ključni stolpec mora biti označen kot zunanji. (izbirno, privzeto ni ključnega stolpca).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Podrejeni elementi:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;optioncolumn&gt;</term>
	<listitem
><para
>Določa en neobvezen stolpec niza. Za vsako vrednost, ki jo želite pridobiti iz nabora možnosti, morate deklarirati ločen &lt;optioncolumn&gt;. Lastnosti: <variablelist>
			<varlistentry
><term
><parameter
>id</parameter
></term>
			<listitem
><para
>ID neobveznega stolpca (obvezno, niz).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>external</parameter
></term>
			<listitem
><para
>Nastavite na true, če je neobvezni stolpec nadzorovan zunaj nabora možnosti optionset (neobvezno, logično, privzeto na false).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>label</parameter
></term>
			<listitem
><para
>Če je podan, bo optioncolumn prikazan v stolpcu s to oznako (neobvezno, niz, privzeto ni prikazano).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>connect</parameter
></term>
			<listitem
><para
>Lastnost za povezavo tega stolpca z možnostmi, podana kot id znotraj območja &lt;content&gt;. Za zunanji &lt;optioncolumn&gt; bo ustrezna vrednost nastavljena na zunanje nastavljeno vrednost. Za navadne (nezunanje) &lt;optioncolumn&gt; bo ustrezna vrstica lastnosti &lt;optioncolumn&gt; nastavljena, ko se lastnost spremeni znotraj področja vsebine. (izbirno, niz, privzeto ni povezano).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>default</parameter
></term>
			<listitem
><para
>Samo za zunanje stolpce: vrednost, ki naj se predpostavi za ta stolpec, če za vnos ni znana nobena vrednost. Redko uporabno. (Izbirno, privzeto prazen niz)</para
></listitem
></varlistentry>
		</variablelist>
	</para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;content&gt;</term>
	<listitem
><para
>Deklarirajte vsebino / UI nabora. Brez atributov. Kot podrejeni elementi so dovoljeni vsi običajni aktivni, pasivni in postavitveni elementi. Poleg tega je v starejših različicah &rkward; (do 0.6.3) bil dovoljen poseben podrejeni element <command
>&lt;optiondisplay&gt;</command
>. To je zastarelo v &rkward; 0.6.4 in ga je treba preprosto odstraniti iz obstoječih vtičnikov. </para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;logic&gt;</term>
	<listitem
><para
>Izbirna specifikacija logike uporabniškega vmesnika za uporabo <emphasis
>znotraj</emphasis
> območja vsebine nabora možnosti. Oglejte si <link linkend="logicelements"
>sklic na &lt;logic&gt;</link
> </para
></listitem
></varlistentry>
	</variablelist>
</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Element, zasnovan za izbiro enega imena datoteke (ali imena imenika). Upoštevajte, da bo to polje sprejelo poljuben niz, čeprav je namenjen uporabi za datoteke, samo: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za brskalnik (neobvezno, privzeto je "Vnesite ime datoteke")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Začetno besedilo brskalnika (neobvezno, privzeto je "",  &ie; prazen niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Eden izmed "file", "dir" ali "savefile". Za izbiro obstoječe datoteke, obstoječega imenika ali neobstoječe datoteke (neobvezno, privzeto je "file")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_urls</parameter
></term>
	<listitem
><para
>Ali je mogoče izbrati (nelokalne) &URL; (neobvezno, privzeto je "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>filter</parameter
></term>
	<listitem
><para
>Filter vrste datoteke, &eg; ("*.txt *.csv" za datoteke .txt in .csv). Samodejno je dodan ločen vnos za "Vse datoteke" (izbirno, privzeto je "", &ie; Vse datoteke)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Ali je za oddajo kode potrebno, da polje ni prazno. Upoštevajte, da to ne pomeni nujno, da je izbrano ime datoteke veljavno. Oglejte si <link linkend="elementproperties"
>required-property</link
> (neobvezno, privzeto na true)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Element, zasnovan za izbiro imena &R; predmet, v katerega želite shraniti (&ie; na splošno še ne obstaja, v nasprotju z varslot): <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka za vnos (neobvezno, privzeto je "Shrani v:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Začetno besedilo vnosa (neobvezno, privzeto je "my.data")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Ali je za oddajo kode zahtevano, da polje vsebuje dovoljeno ime objekta. Oglejte si <link linkend="elementproperties"
>required-property</link
> (neobvezno, privzeto na true)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>V mnogih primerih uporabe je shranjevanje v &R; predmet neobvezno. V teh primerih lahko s tem atributom v element saveobject-element vključite potrditveno polje. Ko je nastavljeno na true, bo saveobject aktiviran / deaktiviran s potrditvenim poljem. Oglejte si <link linkend="elementproperties"
>active-property</link
> saveobject (neobvezno, privzeto je false)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Samo za preverljive saveobject-elemente: Ali je kontrolnik privzeto označen / omogočen (neobvezno, privzeto je false)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Vrtilno polje, v kateri lahko uporabnik izbere številsko vrednost z uporabo neposrednega vnosa s tipkovnice ali majhnih puščic gor/dol. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka vrtilnega polja (priporočeno, privzeto "Vnesite vrednost:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Najnižja vrednost, ki jo lahko uporabnik vnese v vrtilno polje (neobvezno, privzeto je najnižja vrednost, ki jo je tehnično mogoče predstaviti v vrtilnem polju)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Največja vrednost, ki jo lahko uporabnik vnese v vrtilno polje (neobvezno, privzeta vrednost je najvišja vrednost, ki jo je tehnično mogoče predstaviti v vrtilnem polju)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Začetna vrednost, prikazana v vrtilnem polju (neobvezno, privzeto je "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>En od "real" ali "integer". Ali bo vrtilno polje sprejelo realna števila ali samo cela števila (neobvezno, privzeto je "real")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default_precision</parameter
></term>
	<listitem
><para
>Smiselno samo, če ima vrtilno polje type="real". Podaja privzeto število decimalnih mest, prikazanih v vrtilnem polju (prikazano bo samo toliko ničel na koncu). Ko uporabnik pritisne puščice gor/dol, se to decimalno mesto spremeni. Vendar bo uporabnik morda še vedno lahko vnesel vrednosti z večjo natančnostjo (glejte spodaj) (neobvezno, privzeto je "2")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_precision</parameter
></term>
	<listitem
><para
>Največje število števk, ki jih je mogoče smiselno predstaviti (neobvezno, privzeto je "8")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>Ta napredni element omogoča uporabniku, da iz izbranih spremenljivk izbere formulo/niz interakcij. Na primer za GLM lahko ta element uporabite, da uporabniku omogočite določitev interakcijskih pogojev v modelu. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>fixed_factors</parameter
></term>
	<listitem
><para
>ID reže varslot, ki vsebuje izbrane fiksne faktorje (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dependent</parameter
></term>
	<listitem
><para
>ID reže varslot, ki vsebuje izbrano odvisno spremenljivko (obvezno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>V ta vtičnik vdelajte drug vtičnik (glejte <link linkend="embedding"
>poglavje o vdelavi</link
>). Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>component</parameter
></term>
	<listitem
><para
>Registrirano ime komponente za vdelavo (glejte <link linkend="pluginmap"
>poglavje o registraciji komponent</link
>) (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>as_button</parameter
></term>
	<listitem
><para
>Če je nastavljeno na "true", bo v vdelani &GUI; nameščen samo gumb pushbutton, vdelani &GUI; bo prikazan samo (v ločenem oknu), ko pritisnete gumb pushbutton (neobvezno, privzeto je "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Smiselno samo, če je as_button="true": oznaka gumba (priporočljivo, privzeto je "Options")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Potrditveno polje za preklop funkcije predogleda. Upoštevajte, da od različice 0.6.5 &rkward; so elementi predogleda <command
>&lt;preview&gt;</command
> označeni s posebnimi črkami v pogovornih oknih vtičnikov (ne v čarovnikih): postavljeni bodo v stolpec z gumbi, ne glede na to, kje so točno definirani v uporabniškem vmesniku. Še vedno je dobra ideja, da jih definirate na smiselnem mestu v postavitvi zaradi združljivosti za nazaj. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka polja (neobvezno, privzeto je "Preview")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>način</parameter
></term>
	<listitem
><para
>Vrsta predogleda. Podprte vrste so "plot" (glejte <link linkend="preview_plots"
>poglavje o predogledih grafov</link
>), "output" (glejte <link linkend="preview_output"
>poglavje o (&HTML;) predogledih izhodov</link 
>), "data" (glejte <link linkend="preview_data"
>predoglede podatkov</link
>) in "custom" (glejte <link linkend="preview_custom"
>predoglede po meri</link
>). (izbirno, privzeto je "plot")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>placement</parameter
></term>
	<listitem
><para
>Postavitev predogleda: "attached" (na glavno delovno mesto), "detached" (samostojno okno), "docked" (priloženo pogovornemu oknu vtičnika) in "default" (trenutno je to enako kot "docked", lahko pa na neki točki lahko konfigurira uporabnik). Na splošno je priporočljivo, da to pustite kot privzeto nastavitev za najboljšo skladnost uporabniškega vmesnika (izbirno, privzeto je "default")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>active</parameter
></term>
	<listitem
><para
>Ali je predogled privzeto aktiven. Na splošno bi morali biti privzeto aktivni samo zasidrani predogledi in tudi za te obstaja razlog, zakaj so privzeti predogledi neaktivni (neobvezno, privzeto je "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="logicelements"
><title
>Logic section</title>
<variablelist>
<varlistentry>
<term
>&lt;logic&gt;</term>
<listitem
><para
>Element, ki vsebuje logični odsek - Logic section. Vsi spodnji elementi so dovoljeni samo znotraj elementa &lt;logic&gt;. Element &lt;logic&gt; je dovoljen samo kot neposredni podrejeni element elementa &lt;document&gt; (največ enkrat na dokument) ali elementov &lt;optionset&gt; (največ enkrat na nabor možnosti optionset). Logični razdelek dokumenta se nanaša na oba &lt;dialog&gt; in &lt;wizard&gt; GUI na enak način.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;external&gt;</term>
<listitem
><para
>Ustvari novo lastnost (niz), ki naj bi bila povezana z zunanjo lastnostjo, če bo vtičnik vdelan. Oglejte si <link linkend="embedding_incomplete"
>razdelek o nedokončanih - "incomplete" vtičnikih</link
>. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID nove lastnosti (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default</parameter
></term>
	<listitem
><para
>Privzeta vrednost niza nove lastnosti, &ie; uporabljena vrednost, če lastnost ni povezana z zunanjo lastnostjo (neobvezno, privzeto je prazen niz)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;i18n&gt;</term>
<listitem
><para
>Ustvari novo lastnost (niz), ki naj bi zagotavljala internacionalizirano oznako. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID nove lastnosti (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Oznaka. To bo prevedeno. (obvezno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;set&gt;</term>
<listitem
><para
>Lastnost nastavite na fiksno vrednost (seveda, če lastnost dodatno povežete s kakšno drugo lastnostjo, vrednost ne ostane fiksna). Na primer, če vdelate vtičnik, vendar želite skriti nekatere njegove elemente, lahko nastavite lastnost vidnosti teh elementov na false. Uporabno npr. za vdelane/vdelane vtičnike. Opomba: če obstaja več &lt;set&gt; elementov za en sam <parameter
>id</parameter
>, ima prednost tisti, ki je zadnji definiran. To se bo včasih koristno zanesti pri uporabi &lt;include&gt;d delov. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID lastnosti za nastavitev (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>to</parameter
></term>
	<listitem
><para
>Vrednost niza, na katero želite nastaviti lastnost to (obvezno). Opomba: Za logične lastnosti, kot sta vidnost, omogočenost, boste atribut običajno nastavili na =="true" ali na="false".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Ustvarite nove logične lastnosti, ki so odvisne od stanja ene ali več različnih lastnosti. Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID nove lastnosti (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>sources</parameter
></term>
	<listitem
><para
>ID-ji lastnosti, od katerih bo ta lastnost odvisna. Določite lahko eno ali več lastnosti, ločenih z ";" (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>način</parameter
></term>
	<listitem
><para
>Način pretvorbe/delovanja. Eden izmed "equals", "notequals", "range", "and", "or". Če je v načinu equals, bo lastnost resnična le, če je vrednost vseh njenih virov enaka standardu atributa (glejte spodaj). Če je v načinu notequals, bo lastnost resnična samo, če se vrednost vseh njenih virov razlikuje od standarda atributa (glejte spodaj). Če je v območju načina "range", morajo biti viri numerični (celoštevilo ali realno). Lastnost bo resnična samo, če so vsi viri v območju, ki ga določata atributa min in max (glejte spodaj). Če je v načinu in, morajo biti viri logične lastnosti. Lastnost bo resnična le, če so resnični vsi viri hkrati. Če je v načinu ali, morajo biti viri logične lastnosti. Lastnost bo resnična le, če je resničen vsaj eden od virov. (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Pomembno samo v načinih equals ali notequals: vrednost niza za primerjavo (obvezno, če je v enem od teh načinov)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Pomembno samo v načinu range: najmanjša vrednost za primerjavo (neobvezno, privzeto je najnižje število s plavajočo vejico, ki ga lahko predstavi stroj)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Pomembno samo v načinu range: največja vrednost za primerjavo (neobvezno, privzeto je največje število s plavajočo vejico, ki ga lahko predstavi stroj)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>require_true</parameter
></term>
	<listitem
><para
>Če je nastavljeno na "true", bo lastnost postala obvezna in bo veljavna samo, če je njeno stanje true/on. Torej, če je lastnost false, bo blokirala gumb <guibutton
>Pošlji</guibutton
> (izbirno, privzeto je "false"). <caution
><para
>Če uporabljate to, poskrbite, da lahko uporabnik zlahka zazna, kaj je narobe, na primer s prikazom pojasnjevalnega &lt;besedila&gt;.</para
></caution
></para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Ustvarite novo lastnost, ki se bo nanašala na različne ciljne lastnosti (ali fiksne nize) na podlagi vrednosti lastnosti pogoja. To omogoča ustvarjanje logike, podobne konstruktom <function
>if()</function
> ali <function
>switch()</function
>. Lastnosti:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>ID nove lastnosti (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>condition</parameter
></term>
	<listitem
><para
>ID lastnosti pogoja (obvezno)</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Podrejeni elementi:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;true&gt;</term>
	<listitem
><para
>Če je lastnost pogoja boolovs vrednost, lahko podate dva podrejena elementa &lt;true&gt; in &lt;false&gt; (in samo te). (Obvezno, če je podan tudi &lt;false&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;false&gt;</term>
	<listitem
><para
>Če je lastnost pogoja boolova vrednost, lahko podate dva podrejena elementa &lt;true&gt; in &lt;false&gt; (in samo te). (Obvezno, če je podan tudi &lt;true&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;case&gt;</term>
	<listitem
><para
>Če lastnost pogoja ni boolova vrednost, lahko navedete poljubno število elementov &lt;case&gt;, enega za vsako vrednost lastnosti pogoja, ki jo želite ujemati (potreben je vsaj en tak element, če lastnost pogoja ni boolova)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;default&gt;</term>
	<listitem
><para
>Če lastnost pogoja ni boolova vrednost, neobvezni element &lt;default&gt; omogoča določitev vedenja, če se noben &lt;case&gt; element ne ujema z vrednostjo lastnosti pogoja (neobvezno, dovoljeno samo enkrat, v kombinaciji z enim ali več elementi &lt;case&gt;).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Podrejeni elementi &lt;true&gt;, &lt;false&gt;, &lt;case&gt; in &lt;default&gt; prevzamejo naslednje atribute:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Samo za elemente &lt;case&gt;: Vrednost, ki se ujema z lastnostjo pogoja (obvezno, niz).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_value</parameter
></term>
	<listitem
><para
>Fiksni niz, ki mora biti naveden kot vrednost lastnosti &lt;switch&gt;, če se trenutni pogoj ujema (obvezno, če dinamična_vrednost ni podana).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dynamic_value</parameter
></term>
	<listitem
><para
><parameter
>id</parameter
> ciljne lastnosti, ki naj bo naveden kot vrednost lastnosti &lt;switch&gt;, če se trenutni pogoj ujema (obvezno, če ni podana fixed_value).</para
></listitem>
	</varlistentry>
	</variablelist>
	</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;connect&gt;</term>
<listitem
><para
>Povezuje dve lastnosti. Lastnost odjemalca bo spremenjena vsakič, ko se spremeni lastnost guvernerja (vendar ne obratno). Lastnosti: <variablelist>
	<varlistentry>
	<term
><parameter
>client</parameter
></term>
	<listitem
><para
>ID lastnosti stranke, &ie; lastnost, ki bo prilagojena (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>governor</parameter
></term>
	<listitem
><para
>ID lastnosti guvernerja, &ie; lastnost, ki bo prilagodila lastnost stranke. To lahko vključuje modifikator (obvezno)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>reconcile</parameter
></term>
	<listitem
><para
>Če je "true", bo lastnost odjemalca prilagodila lastnosti guvernerja ob povezavi tako, da bo lastnost guvernerja sprejemala le vrednosti, ki jih sprejema tudi odjemalec (&eg; predpostavimo, da je regulator številska lastnost z najmanjšo vrednostjo "0" ", odjemalec pa je številska lastnost z najmanjšo vrednostjo "100". Najmanjša vrednost obeh lastnosti bo prilagojena na 100, če je reconcile="true"). Na splošno deluje samo za lastnosti istega osnovnega tipa (neobvezno, privzeto je "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dependency_check&gt;</term>
<listitem
><para
>Ustvari boolovo lastnost, ki je true, če so podane odvisnosti izpolnjene, sicer pa false. Sintaksa elementa &XML; je enaka sintaksi elementa <command
>&lt;dependencies&gt;</command
>, ki je opisan v referenci <link linkend="pluginmapelements"
>&pluginmap;</link
>. Od &rkward; 0.6.1, samo &rkward; in &R; upoštevane so specifikacije različice, ne pa odvisnosti od paketov ali pluginmap.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;skript&gt;</term>
<listitem
><para
>Definirajte kodo skripta za nadzor logike uporabniškega vmesnika. Za podrobnosti glejte <link linkend="logic_scripted"
>razdelek o skriptirani logiki GUJI</link
>. Kodo skripta za zagon je mogoče podati z uporabo atributa <parameter
>"file"</parameter
> ali kot (komentirano) besedilo elementa. Element <command
>&lt;script&gt;</command
> ni dovoljen v razdelku <command
>&lt;logic&gt;</command
> nabora možnosti optionset. Lastnosti: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Ime datoteke skriptne datoteke. (obvezno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

</variablelist>
</sect2>

</sect1
>	<!-- Elements in main XML -->

<sect1 id="elementproperties"
><title
>Lastnosti elementov vtičnika</title>
<para
>Vsi <link linkend="layoutelements"
>elementi postavitve</link
> in vsi <link linkend="activeelements"
>aktivni elementi</link
> imajo naslednje lastnosti, dostopne prek "id_of_element.name_of_property": </para>
<variablelist>
<varlistentry>
<term
>visible</term>
<listitem
><para
>Ali je &GUI; element je viden ali ne (boolean)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>enabled</term>
<listitem
><para
>Ali je &GUI; element je omogočen ali ne (boolean)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>required</term>
<listitem
><para
>Ali je &GUI; zahtevan (za veljavno nastavitev) ali ne. Upoštevajte, da je vsak element, ki je onemogočen ali skrit, tudi implicitno neobvezen (boolean).</para
></listitem>
</varlistentry>
</variablelist>
<para
>Poleg tega imajo nekateri elementi dodatne lastnosti, s katerimi se lahko povežete. Večina aktivnih elementov ima tudi lastnost privzeto "default", katere vrednost bo vrnjena pri klicih <function
>getBoolean/getString/getList ("...")</function
>, če nobena posebna lastnost ni bila imenovana, kot je opisano spodaj. </para>

<variablelist>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Privzeta lastnost je besedilo <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Prikazano besedilo (besedilo)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Ni privzete lastnosti <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Trenutno izbrani predmeti. Verjetno tega ne želite uporabiti. Uporablja se interno (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>root</term>
	<listitem
><para
>Korenski/nadrejeni objekt predmetov, ponujenih za izbor (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>Privzeta lastnost je "available" <variablelist>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Vsi predmeti, shranjeni v reži varslot (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Od predmetov, shranjenih v varslot, tisti, ki so trenutno izbrani. Verjetno tega ne želite uporabiti. Uporablja se interno (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>source</term>
	<listitem
><para
>Kopija predmetov, izbranih v ustreznem izbirniku spremenljivk varselector. Verjetno tega ne želite uporabiti. Uporablja se interno (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Privzeta lastnost je "selected" <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Trenutno izbrani nizi. Modifikator "labeled" za pridobitev ustreznih oznak. V &lt;valueselector&gt; tega verjetno ne želite uporabiti neposredno (samo v &lt;select&gt;). (read/write StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Seznam vrednosti niza, med katerimi lahko izbirate. (read/write StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Oznake za prikaz vrednosti niza. (read/write StringList)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Enako kot &lt;varslot&gt;, vendar so lastnosti seznami nizov namesto RObjects.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Privzeta lastnost je "string" <variablelist>
	<varlistentry>
	<term
>string</term>
	<listitem
><para
>Vrednost trenutno izbrane možnosti (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>number</term>
	<listitem
><para
>Število trenutno izbrane možnosti (možnosti so oštevilčene od zgoraj navzdol, z začetkom pri 0) (celo število)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Enako kot &lt;radio&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Enako kot &lt;valueselector&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Ni privzete lastnosti. "enabled" je *edina* lastnost in trenutno ni na voljo za možnosti znotraj &lt;select&gt; ali &lt;valueselector&gt;. &lt;option&gt; nima "visible" ali "required" lastnosti. <variablelist
> <varlistentry>
	<term
>enabled</term>
	<listitem
><para
>Ali naj bo ta posamezna možnost omogočena ali onemogočena. V večini primerov boste omogočili/onemogočili celoten &lt;radio&lt; ali namesto tega &lt;dropdowni&lt;. Toda to je mogoče uporabiti za dinamično nastavitev omogočenosti posamezne možnosti znotraj &lt;radio&lt; ali &lt;dropdowni&lt; (bool)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Privzeta lastnost je "state.labeled", kar pomeni, da so vrnjene vrednosti, določene z atributoma <parameter
>value</parameter
> in <parameter
>value_unchecked</parameter
>, <emphasis
>ne</emphasis
> prikazane oznake potrditvenega polja. <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Stanje potrditvenega polja (vklopljeno ali izklopljeno). Upoštevajte, da so uporabni modifikatorji te lastnosti (kot vseh logičnih lastnosti) "not" in "labeled" (glejte <link linkend="propertytypes"
>vrste lastnosti</link
>). Vendar je pogosto najbolj uporabno povezati se z lastnostjo brez modifikatorja, &ie; "<emphasis
>checkbox_id</emphasis
>.state", ki bo vrnil stanje potrditvenega polja v obliki, primerni za uporabo v stavku if (0 ali 1). (boolova vrednost)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Privzeta lastnost je "checked", če - in samo če - je okvir mogoče preveriti. Za okvirje, ki jih ni mogoče preveriti, ni privzete lastnosti. <variablelist
> <varlistentry>
	<term
>checked</term>
	<listitem
><para
>Na voljo samo za okvirje, ki jih je mogoče preveriti: stanje potrditvenega polja (vklopljeno ali izklopljeno). Upoštevajte, da sta uporabna modifikatorja te lastnosti (kot vseh logičnih lastnosti) "not" in "numeric" (glejte <link linkend="propertytypes"
>vrste lastnosti</link
>). (boolova vrednost)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Privzeta lastnost je "text" <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Trenutno besedilo v vnosnem polju (niz)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;matrix&gt;</term>
	<listitem
><para
>Privzeta lastnost je "cbind". <variablelist>
		<varlistentry>
			<term
>rows</term>
			<listitem
><para
>Število vrstic v matriki (celo število). Če matrika uporabniku omogoča dodajanje / odstranjevanje vrstic, je treba to lastnost obravnavati kot samo za branje. V nasprotnem primeru bo sprememba spremenila velikost matrike.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>columns</term>
			<listitem
><para
>Število stolpcev v matriki (celo število). Če matrika dovoljuje uporabniku dodajanje/odstranjevanje stolpcev, je treba to lastnost obravnavati kot samo za branje. V nasprotnem primeru bo sprememba spremenila velikost matrike.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>tsv</term>
			<listitem
><para
>Podatki v matriki v formatu tsv (string; branje-pisanje). Upoštevajte, da so v primerjavi z običajno postavitvijo tsv stolpci <emphasis
>columns</emphasis
>, ne vrstice, ločeni z znaki za novo vrstico, celice v stolpcu pa so ločene z znaki tabulatorja.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>0,1,2...</term>
			<listitem
><para
>Podatki iz enega samega stolpca (0 za skrajno levi stolpec). <function
>getValue()</function
>/<function
>getString()</function
> to vrne kot en sam niz, ločen z "\n". Vendar pa je priporočeni način za to uporaba <function
>getList()</function
>, ki ta stolpec vrne kot niz nizov.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>row.0,row.1,row.2...</term>
			<listitem
><para
>Podatki iz ene same vrstice (0 za najvišjo vrstico). <function
>getValue()</function
>/<function
>getString()</function
> to vrne kot en sam niz, ločen z "\n". Vendar pa je priporočeni način za to uporaba <function
>getList()</function
>, ki vrne to vrstico kot niz nizov.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>cbind</term>
			<listitem
><para
>Podatki v formatu, primernem za lepljenje v &R;, zaviti v stavek cbind (niz; samo za branje).</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;optionset&gt;</term>
	<listitem
><para
>Ni privzete lastnosti. <variablelist>
		<varlistentry>
			<term
>row_count</term>
			<listitem
><para
>Število elementov v naboru možnosti optionset (celo število). Samo za branje.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>current_row</term>
			<listitem
><para
>Trenutno aktivni element v naboru možnosti optionset (celo število). -1 za noben aktivni element. Branje-pisanje.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
><emphasis
>optioncolumn_ids</emphasis
></term>
			<listitem
><para
>Za vsak &lt;optioncolumn&gt;, ki ga definirate, bo ustvarjena lastnost seznama nizov s podanim ID-jem.</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Privzeta lastnost je "selection" <variablelist
> <varlistentry>
	<term
>selection</term>
	<listitem
><para
>Trenutno besedilo (ime izbrane datoteke) v brskalniku (niz)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Privzeta lastnost je "selection" <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Polno ime izbranega predmeta (niz; samo za branje – če želite to nastaviti programsko, uporabite "parent" in "objectname")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>parent</term>
	<listitem
><para
>Nadrejeni predmet izbranega predmeta. To je vedno obstoječi &R; objekt vrste, ki lahko vsebuje druge objekte (&eg; seznam ali data.frame). Ko je nastavljen na prazen niz ali neveljaven predmet, se predpostavlja ".GlobalEnv" (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>objectname</term>
	<listitem
><para
>Osnovno ime izbranega predmeta, &ie; niz, ki ga je vnesel uporabnik (po potrebi spremenjen v veljavno &R; ime) (niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>active</term>
	<listitem
><para
>Samo za objekte shranjevanja, ki jih je mogoče preveriti: ali je kontrolnik označen/omogočen. Vedno velja za predmete shranjevanja, ki jih ni mogoče preveriti (bool)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Privzeta lastnost je "int" ali "real.formatted", odvisno od načina vrtilnega polja <variablelist>
	<varlistentry>
	<term
>int</term>
	<listitem
><para
>Vrednost celega števila, ki jo hrani vrtilno polje, ali najbližje celo število, če je v realnem načinu (celo število)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>real</term>
	<listitem
><para
>Realna vrednost, ki jo hrani vrtilno polje (in celo število, če je celo število) (realno)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>Privzeta lastnost je "model" <variablelist>
	<varlistentry>
	<term
>model</term>
	<listitem
><para
>Trenutni niz modela (niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>table</term>
	<listitem
><para
>Data.frame, ki vsebuje zahtevane spremenljivke. Če so uporabljene spremenljivke samo iz enega data.frame, se vrne ime tega data.frame. V nasprotnem primeru se po potrebi sestavi nov data.frame (niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Če so vključene spremenljivke iz več data.frameov, se lahko njihova imena pokvarijo (na primer, če oba data.frames vsebujeta spremenljivko z imenom "x"). To vrne seznam s pokvarjenimi imeni kot indeksi in opisno oznako kot vrednost (niz)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>fixed_factors</term>
	<listitem
><para
>Fiksni faktorji. Verjetno tega ne želite uporabiti. Uporablja se interno (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>dependent</term>
	<listitem
><para
>Odvisna spremenljivka(e). Verjetno tega ne želite uporabiti. Uporablja se interno (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Ni privzete lastnosti <variablelist
> <varlistentry>
	<term
>code</term>
	<listitem
><para
>Koda, ki jo ustvari vdelani vtičnik (code)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Privzeta lastnost je "state" <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Ali je polje za predogled potrjeno (ni nujno, ali je bil predogled že prikazan) (boolean)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Ta element (uporabljen v razdelku &lt;logic&gt;) je poseben, ker je tehnično *je* lastnost, namesto da samo drži eno ali več lastnosti. Je boolove vrste. Upoštevajte, da sta uporabna modifikatorja te lastnosti (kot vseh boolovih lastnosti) "not" in "numeric" (glejte <link linkend="propertytypes"
>vrste lastnosti</link
>)</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Ta element (uporabljen v razdelku &lt;logic&gt;) je poseben, ker je tehnično *je* lastnost (niz), namesto da samo drži eno ali več lastnosti. Omogoča preklapljanje med več ciljnimi lastnostmi glede na vrednost lastnosti pogoja ali ponovno preslikavo vrednosti lastnosti pogoja. Vsi modifikatorji, ki jih podate, se posredujejo ciljnim lastnostim, tako &eg; če so vse ciljne lastnosti lastnosti RObject, lahko na stikalu uporabite tudi modifikator "shortname". Če pa so ciljne lastnosti različnih vrst, lahko uporaba modifikatorjev povzroči napake. Za <replaceable
>fixed_value</replaceable
>s je vsak modifikator tiho opuščen. Upoštevajte, da so ciljne lastnosti, ko do njih dostopate prek stikala, vedno samo za branje.</para
></listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="standard_embeddable_plugins"
><title
>Vstavljivi vtičniki, dobavljeni z uradno izdajo &rkward;</title>
<para
>Številni vtičniki, ki jih je mogoče vdelati, so priloženi &rkward; in jih lahko uporabite v svojih lastnih vtičnikih. Podrobna dokumentacija je trenutno na voljo samo v teh izvornih datotekah vtičnikov ali v datotekah pomoči. Vendar pa je tukaj seznam za hiter pregled tega, kar je na voljo:</para>
<table frame='all'
><title
>Standardni vstavljivi vtičniki</title>
<tgroup cols='4'>
<thead>
<row>
  <entry
>ID</entry>
  <entry
>Pluginmap</entry>
  <entry
>Opis</entry>
  <entry
>Primer uporabe</entry>
</row>
</thead>
<tbody>
<row>
  <entry
>rkward::plot_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Zagotavlja široko paleto možnosti za grafikone. Večina vtičnikov za risanje uporablja to.</entry>
  <entry
>Plots->Barplot, večina drugih vtičnikov za risanje</entry>
</row>
<row>
  <entry
>rkward::color_chooser</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Zelo preprost vtičnik za določanje barve. Trenutna izvedba ponuja seznam imen barv. Prihodnje izvedbe lahko zagotovijo bolj dovršeno izbiranje barv.</entry>
  <entry
>Grafi->Histogram</entry>
</row>
<row>
  <entry
>rkward::plot_stepfun_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Možnosti izrisa stopenjske funkcije</entry>
  <entry
>Parcele->risba ECDF</entry>
</row>
<row>
  <entry
>rkward::histogram_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Možnosti histograma (risbe).</entry>
  <entry
>Grafi->Histogram</entry>
</row>
<row>
  <entry
>rkward::barplot_embed</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Možnosti stolpičnega grafa</entry>
  <entry
>Grafikoni->Stolpični grafikon</entry>
</row>
<row>
  <entry
>rkward::one_var_tabulation</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Zagotavlja tabeliranje ene same spremenljivke.</entry>
  <entry
>Grafikoni->Stolpični grafikon</entry>
</row>
<row>
  <entry
>rkward::limit_vector_length</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Omejite dolžino vektorja (na n največjih ali najmanjših elementov).</entry>
  <entry
>Grafikoni->Stolpični grafikon</entry>
</row>
<row>
  <entry
>rkward::level_select</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Zagotavlja &lt;valueselector&gt; napolnjen z ravnmi (ali edinstvenimi vrednostmi) vektorja.</entry>
  <entry
>Podatki->Prekodiraj kategorične podatke</entry>
</row>
<row>
  <entry
>rkward::multi_input</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Združuje vrtilno polje, vnosne in radijske kontrole za zagotavljanje vnosa znakovnih, številskih in logičnih podatkov.</entry>
  <entry
>Podatki->Prekodiraj kategorične podatke</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>

<sect1 id="pluginmapelements"
><title
>Elementi za uporabo v datotekah &pluginmap;</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Prisoten mora biti v vsaki datoteki &pluginmap; kot korensko vozlišče (natanko enkrat). Lastnosti: <variablelist>
	<varlistentry>
	<term
>base_prefix</term>
	<listitem
><para
>Imena datotek, navedena v datoteki &pluginmap;, so pričakovano relativne glede na imenik datoteke &pluginmap; + predpono, ki jo navedete tukaj. Uporabno, zlasti če se vse vaše komponente nahajajo pod enim samim podimenikom.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>namespace</term>
	<listitem
><para
>Imenski prostor za ID-je komponent. Ko iščete komponente za vdelavo, jih bo mogoče pridobiti prek niza "namespace::component_id". Zaenkrat nastavite na "rkward".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Izbirni identifikatorski niz za ta &pluginmap;. Če navedete to možnost, lahko tretji avtorji sklicujejo in naložijo vašo datoteko &pluginmap; od njihovih (glejte <link linkend="chapter_dependencies"
>poglavje o ravnanju z odvisnostmi</link
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>priority</term>
	<listitem
><para
>En od <replaceable
>"hidden"</replaceable
>, <replaceable
>"low"</replaceable
>, <replaceable
>"medium"</replaceable
> ali <replaceable
>"high"</replaceable
>. &pluginmap; s prioriteto "medium" ali "high" se aktivirajo samodejno, ko jih &rkward; prvič najde. Uporabite <replaceable
>priority="hidden"</replaceable
> za &pluginmap;, ki niso namenjeni za aktiviranje, imenik (namenjen samo za vključitev). V trenutni izvedbi pa to dejansko ne skrije &pluginmap;. (Izbirno, privzeto je "medium").</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;dependencies&gt;</term>
<listitem
><para
>Ta element, ki določa odvisnosti, je dovoljen kot neposredni podrejeni element elementa &lt;document&gt; (enkrat) in kot podrejeni element &lt;component&gt; elementov (enkrat za vsak element &lt;component&gt;). Podaja odvisnosti, ki morajo biti izpolnjene za uporabo vtičnika(-ov). Za pregled glejte <link linkend="chapter_dependencies"
>poglavje o odvisnostih</link
>. Lastnosti:</para>
	<variablelist>
	<varlistentry>
	<term
>rkward_min_version, rkward_max_version</term>
	<listitem
><para
>Najmanjša in največja dovoljena različica &rkward;. Specifikacije različice lahko vključujejo neštevilske pripone, kot je "0.5.7z-devel1". Če določena odvisnost ni izpolnjena, bodo vtičniki, na katere se nanaša, <emphasis
>prezrti</emphasis
>. <link linkend="sect_dependencies_rkward_version"
>Več informacij</link
>. Neobvezno; če ni navedeno, ni najmanjše/največje različice &rkward; bo zahtevano.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>R_min_version, R_max_version</term>
	<listitem
><para
>Najmanjša in največja dovoljena različica &R;. Specifikacije različice morda <emphasis
>ne</emphasis
> vključujejo neštevilske pripone, kot je "0.5.7z-devel1". &R; odvisnost od različice bo prikazana na straneh s pomočjo vtičnikov, vendar nima neposrednega učinka, saj od &rkward; 0.6.1. <link linkend="sect_dependencies_r_version"
>Več informacij</link
>. Neobvezno; če ni navedeno, ni najmanjše/največje različice &R; bo obvezno.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Podrejeni elementi:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;package&gt;</term>
	<listitem
><para
>Doda odvisnost od določenega &R; paketa. Lastnosti: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Ime paketa (obvezno).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Najmanjša / največja dovoljena različica (neobvezno).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>repository</term>
		<listitem
><para
>Repozitorij, kjer je paket mogoče najti. Izbirno, vendar zelo priporočljivo, če paket ni na voljo na CRAN.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;pluginmap&gt;</term>
	<listitem
><para
>Doda odvisnost od določene &rkward; &pluginmap;. Lastnosti: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Id niz zahtevane &pluginmap; (obvezno).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Najmanjša / največja dovoljena različica (neobvezno).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>&URL; kjer je &pluginmap; mogoče najti. Obvezno.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Lahko je prisoten natanko enkrat kot neposredni podrejeni element elementa &lt;document&gt;. Vsebuje meta informacije o &pluginmap; (ali o vtičniku). Za pregled si oglejte <link linkend="chapter_about_information"
>poglavje o informacijah 'o'</link
>. Lastnosti:</para>
	<variablelist>
	<varlistentry>
	<term
>name</term>
	<listitem
><para
>Uporabniku vidno ime. Neobvezno. Ni nujno, da je enak "id".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>version</term>
	<listitem
><para
>Številka različice. Neobvezno. Oblika zapisa ni omejena, vendar zaradi varnosti upoštevajte običajne sheme za ustvarjanje različic, kot je "x.y.z".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>releasedate</term>
	<listitem
><para
>Specifikacija datuma izdaje. Izbirno v obliki "YYYY-MM-DD".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>shortinfo</term>
	<listitem
><para
><emphasis
>short</emphasis
> opis vtičnika / &pluginmap;. Neobvezno.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>url</term>
	<listitem
><para
>&URL; kjer lahko najdete več informacij. Neobvezno, vendar priporočljivo.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>copyright</term>
	<listitem
><para
>Specifikacija avtorskih pravic, &eg; "2012-2013 avtor John Doe". Neobvezno, vendar priporočljivo.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>licence</term>
	<listitem
><para
>Specifikacija licence, &eg; "GPL" ali "BSD". Svojim datotekam ne pozabite priložiti popolne kopije ustrezne licence. Neobvezno, vendar priporočljivo.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>category</term>
	<listitem
><para
>Kategorija vtičnikov, &eg; ""Item response theory". Od &rkward; 0.6.1, nobena kategorija ni vnaprej določena. Neobvezno.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Podrejeni elementi:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;author&gt;</term>
	<listitem
><para
>Doda podatke o avtorju. Lastnosti: <variablelist>
		<varlistentry>
		<term
>ime, ime2, družina</term>
		<listitem
><para
>Bodisi navedite polno ime za <parameter
>name</parameter
> ali pa navedite tako <parameter
>given</parameter
> kot <parameter
>family</parameter
> ločeno.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>role</term>
		<listitem
><para
>Opis vloge avtorja (neobvezno).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>email</term>
		<listitem
><para
>Elektronski naslov, na katerega je avtor dosegljiv. Obvezno. Lahko se nastavi na poštni seznam rkward-devel, če ste naročeni in je vaš vtičnik namenjen vključitvi v uradno izdajo &rkward;.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>&URL; z več podatki o avtorju, &eg; domača stran (neobvezno).</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;components&gt;</term>
<listitem
><para
>Prisoten mora biti natanko enkrat kot neposredni podrejeni element &lt;document&gt; element. Vsebuje posamezne elemente &lt;component&gt;, opisane spodaj. Brez atributov.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;component&gt;</term>
<listitem
><para
>Ena ali več elementov &lt;component&gt; je treba podati kot neposredne podrejene elemente &lt;components&gt; element (in samo tam). Registrira komponento/vtičnik z rkward. Lastnosti: <variablelist>
	<varlistentry>
	<term
>type</term>
	<listitem
><para
>Za prihodnjo razširitev: Vrsta komponente/vtičnika. Zaenkrat vedno nastavljen na "standard" (edina trenutno podprta vrsta).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>ID, po katerem je mogoče pridobiti to komponento (za postavitev v meni (glejte spodaj) ali za vdelavo). Glejte &lt;document&gt;-namespace zgoraj.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Zahtevano vsaj za komponente type="standard": ime datoteke &XML; datoteka, ki opisuje &GUI;.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Oznaka za to komponento, ko je postavljena v hierarhijo menija.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;attribute&gt;</term>
<listitem
><para
>Določa atribut komponente. Zaenkrat smiselno samo za <link linkend="context_import"
>vtičnike za uvoz</link
>. Dovoljeno samo kot neposredni podrejeni &lt;component&gt;. Lastnosti: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>ID atributa</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>value</term>
	<listitem
><para
>Vrednost atributa</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Oznaka, povezana z atributom</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;hierarchy&gt;</term>
<listitem
><para
>Prisoten mora biti natanko enkrat kot neposredni podrejeni element &lt;document&gt;. Opisuje, kje v hierarhiji menija naj bodo postavljene zgoraj navedene komponente. Sprejme samo elemente &lt;menu&gt;  kot neposredno podrejene. Brez atributov.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;menu&gt;</term>
<listitem
><para
>En ali več elementov &lt;menu&gt; je treba podati kot neposredne potomce elementa &lt;hierarchy&gt;. Razglasi nov (pod)meni. Če meni z danim ID-jem (glejte spodaj) že obstaja, se oba menija združita. Element &lt;menu&gt; je dovoljen kot neposredni podrejeni element &lt;hierarchy&gt; element (meni najvišje ravni) ali kot neposredni podrejeni element katerega koli drugega elementa &lt;menu&gt; (podmeni). Nasprotno pa element &lt;menu&gt; sprejme druge elemente &lt;menu&gt; ali elemente &lt;entry&gt; kot podrejene. Lastnosti: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Identifikacijski niz menija. Uporabno, ko so definicije menija prebrane iz več datotek &pluginmap;, da zagotovite, da je vtičnike mogoče postaviti v iste menije. Nekateri ID-ji menijev, kot je "file", se nanašajo na vnaprej določene menije (v tem primeru meni "File"). Ne pozabite preveriti z obstoječo datoteko &pluginmap; za uporabo doslednih ID-jev.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Oznaka za meni.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Omogoča nadzor vrstnega reda vnosov v meniju. Glejte <link linkend="pluginmap_grouping"
>razvrstitev elementov menija</link
>. Neobvezno.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;entry&gt;</term>
<listitem
><para
>Vnos v meni, &ie; možnost menija za priklic vtičnika. Lahko se uporablja samo kot neposredni podrejeni element &lt;menu&gt; elementa, ne sprejema podrejenih elementov. Lastnosti: <variablelist>
	<varlistentry>
	<term
>component</term>
	<listitem
><para
>ID komponente, ki jo je treba priklicati, ko je aktiviran ta menijski vnos.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Omogoča nadzor vrstnega reda vnosov v meniju. Glejte <link linkend="pluginmap_grouping"
>razvrstitev elementov menija</link
>. Neobvezno.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;group&gt;</term>
<listitem
><para
>Razglasi skupino elementov v meniju. Glejte <link linkend="pluginmap_grouping"
>razvrstitev elementov menija</link
>. Lastnosti: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ime te grupe.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>separated</term>
	<listitem
><para
>Neobvezno. Če je nastavljeno na "true", bo element v tej grupi vizualno ločen od okoliških elementov.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Ime grupe, ki ji želite dodati to grupo (neobvezno).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;context&gt;</term>
<listitem
><para
>Razglasi vnose v <link linkend="contextualized_plugins"
>context</link
>. Dovoljeno samo kot neposredni podrejeni element oznake &lt;document&gt;. Sprejme samo oznake &lt;menu&gt; kot neposredno podrejene. Lastnosti: <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>ID konteksta. Zaenkrat sta implementirana samo dva konteksta: "x11" in "import".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;require&gt;</term>
<listitem
><para
>Vključi še eno datoteko &pluginmap;. Ta datoteka &pluginmap; se naloži samo enkrat, tudi če je zahtevana - &lt;require&gt;d iz več drugih datotek. Najpomembnejši primer uporabe je vključitev datoteke pluginmap, ki deklarira nekatere komponente, ki so vdelane s komponentami, deklariranimi v tem &pluginmap;. Elementi &lt;require&gt; so dovoljeni samo kot neposredno podrejeni vozlišča &lt;document&gt;. Lastnosti: <variablelist>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Ime datoteke vključeno v &pluginmap;. To je vidno glede na imenik trenutne datoteke &pluginmap; + base_prefix (glejte zgoraj, element &lt;document&gt;). Če ne poznate relativne poti do datoteke &pluginmap; če jo želite vključiti, uporabite atribut <parameter
>map</parameter
>, da se nanj sklicujete z ID-jem.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>map</term>
	<listitem
><para
>Če želite vključiti &pluginmap; datoteke iz drugega paketa (ali &rkward; &pluginmap; iz vaše zunanje &pluginmap;), se lahko nanjo sklicujete po njenem <replaceable
>namespacename::id</replaceable
>, kot je določeno v zahtevanem elementu &pluginmap; &lt;document&gt;. Vključitev ne bo uspela, če &pluginmap; s tem ID-jem ni znan (&eg; ni nameščen v uporabnikovem sistemu). To metodo uporabite samo za vključitev &pluginmap; zunaj vašega paketa. Za mape v vašem paketu je podajanje relativne poti (atribut <parameter
>file</parameter
>) hitrejše in zanesljivejše. </para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="helpfileelements"
><title
>Elementi za uporabo v datotekah .rkh (pomoč).</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Prisoten mora biti v vsaki datoteki <literal role="extension"
>.xml</literal
> kot korensko vozlišče (natančno enkrat). Brez atributov.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;title&gt;</term>
<listitem
><para
>Naslov strani s pomočjo. To se <emphasis
>ne</emphasis
> interpretira za strani s pomočjo za vtičnik (to vzame naslov iz samega vtičnika), samo za samostojne strani. Brez atributov. Besedilo v &lt;title&gt; bo postalo naslov strani s pomočjo. Lahko se definira samo enkrat, kot neposredni podrejeni element vozlišča &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;summary&gt;</term>
<listitem
><para
>Kratek povzetek strani s pomočjo (ali za kaj se ta vtičnik uporablja). To bo vedno prikazano na vrhu strani s pomočjo. Brez atributov. Besedilo v oznaki &lt;summary&gt; bo prikazano. Priporočeno, vendar ni obvezno. Lahko se definira samo enkrat, kot neposredni podrejeni element vozlišča &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;usage&gt;</term>
<listitem
><para
>Nekoliko bolj podroben povzetek uporabe. To bo vedno prikazano neposredno za &lt;summary&gt;. Brez atributov. Besedilo v oznaki &lt;usage&gt; bo prikazano. Priporočeno za strani s pomočjo vtičnikov, ni pa obvezno. Lahko se definira samo enkrat, kot neposredni podrejeni element vozlišča &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;section&gt;</term>
<listitem
><para
>Razdelek za splošne namene. Lahko se uporabi poljubno število krat kot neposredni podrejeni element vozlišča &lt;document&gt;. Ti razdelki so prikazani po vrstnem redu njihove definicije, vendar vsi <emphasis
>za</emphasis
> &lt;usage&gt; in <emphasis
>pred</emphasis
> razdelkom &lt;settings&gt;. Besedilo v znaki &lt;section&gt; bo prikazano. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Identifikator, potreben za skok na ta razdelek iz navigacijske vrstice (ali povezave). V datoteki mora biti edinstven. Zahtevano, ni privzeto.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Naslov (napis) tega razdelka. Zahtevano, ni privzeto.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>short_title</term>
	<listitem
><para
>Kratek naslov, primeren za prikaz v navigacijski vrstici. Neobvezno, privzeto je polni naslov.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;settings&gt;</term>
<listitem
><para
>Določa razdelek, ki vsebuje reference na različne nastavitve &GUI;. Samo smiselno in uporabljeno samo za strani s pomočjo, povezane z vtičniki. Uporabi kot neposrednega podrejenega elementa &lt;document&gt;. Lahko vsebuje samo elemente &lt;setting&gt; in &lt;caption&gt; kot neposredne podrejene. Brez atributov.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;setting&gt;</term>
<listitem
><para
>Razlaga posamezno nastavitev v &GUI;. Dovoljeno samo kot neposredni podrejeni element elementa &lt;settings&gt;. Prikaže se besedilo v elementu. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>ID nastavitve v vtičniku <literal role="extension"
>.xml</literal
>. Zahtevano, ni privzete vrednosti.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Neobvezni naslov za nastavitev. Če je izpuščen (v večini primerov je priporočljiva izpustitev), bo naslov vzet iz vtičnika <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;caption&gt;</term>
<listitem
><para
>Napis za vizualno združevanje več nastavitev. Lahko se uporablja le kot neposredni podrejeni element elementa &lt;settings&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>ID ustreznega elementa (običajno &lt;frame&gt;, &lt;page&gt; ali &lt;tab&gt;) v vtičniku <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Izbirni naslov za napis. Če je izpuščen (v večini primerov je priporočljiva izpustitev), bo naslov vzet iz vtičnika <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;related&gt;</term>
<listitem
><para
>Določa razdelek s povezavami do nadaljnjih povezanih informacij. Bo vedno prikazano za razdelkom &lt;settings&gt;. Brez atributov. Besedilo v oznaki &lt;related&gt; bo prikazano. Običajno bo to vsebovalo seznam v slogu &HTML;. Priporočeno za strani s pomočjo vtičnikov, ni pa obvezno. Lahko se definira samo enkrat, kot neposredni podrejeni element vozlišča &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;technical&gt;</term>
<listitem
><para
>Določa razdelek, ki vsebuje tehnične informacije, ki niso pomembne za končne uporabnike (kot je notranja struktura vtičnika). Vedno bo prikazan zadnji na strani s pomočjo. Brez atributov. Besedilo v oznaki &lt;related&gt; bo prikazano. Ni potrebno in ni priporočljivo za večino strani s pomočjo vtičnikov. Lahko se definira samo enkrat, kot neposredni podrejeni element vozlišča &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;link&gt;</term>
<listitem
><para
>Povezava. Lahko se uporablja v katerem koli od zgoraj opisanih razdelkov. <variablelist
> <varlistentry>
	<term
>href</term>
	<listitem
><para
>Ciljni &URL;. Upoštevajte, da je na voljo več specifičnih &URL; za &rkward;. Za podrobnosti si oglejte <link linkend="pluginhelp"
>razdelek o pisanju strani za pomoč</link
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;label&gt;</term>
<listitem
><para
>Vstavi vrednost oznake uporabniškega vmesnika. Lahko se uporablja v katerem koli od zgoraj opisanih razdelkov. <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>ID elementa v vtičniku, za katerega želite kopirati atribut <replaceable
>label</replaceable
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;various &HTML; tags&gt;</term>
<listitem
><para
>Najbolj osnovne oznake &HTML; so dovoljene v razdelkih. Prosimo, da minimalno uporabljate ročno oblikovanje.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="guilogic_functions"
><title
>Funkcije, ki so na voljo za &GUI; logično skriptiranje</title>
<variablelist>
<varlistentry
><term
>Razred "Component"</term>
<listitem
><para
>Razred, ki predstavlja posamezno komponento ali lastnost komponente. Najpomembnejši pojavek tega razreda je spremenljivka "gui", ki je vnaprej določen kot korenska lastnost trenutne komponente. Za pojavke razreda "Component" so na voljo naslednje metode: <variablelist>
	<varlistentry
><term
>absoluteId(base_id)</term
><listitem
><para
>Vrne absolutni ID <emphasis
>base_id</emphasis
> ali – če je base_id izpuščen – identifikator komponente.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getValue(id)</term
><listitem
><para
>Odsvetovano. Namesto tega uporabite <function
>getString(), getBoolean() ali getList()</function
>. Vrne vrednost dane podrejene lastnosti. Vrne vrednost te lastnosti, če je ID izpuščen.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getString(id)</term
><listitem
><para
>Vrne vrednost dane podrejene lastnosti kot niz. Vrne vrednost te lastnosti, če je ID izpuščen.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getBoolean(id)</term
><listitem
><para
>Vrne vrednost dane podrejene lastnosti kot boolovo vrednost (če je mogoče). Vrne vrednost te lastnosti, če je ID izpuščen.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getList(id)</term
><listitem
><para
>Vrne vrednost podane podrejene lastnosti kot matriko nizov (če je mogoče). Vrne vrednost te lastnosti, če je ID izpuščen.</para
></listitem
></varlistentry>
	<varlistentry
><term
>setValue(id, value)</term
><listitem
><para
>Nastavite vrednost dane podrejene lastnosti na <emphasis
>value</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getChild(id)</term
><listitem
><para
>Vrne pojavek podrejene lastnosti z danim <emphasis
>id</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>addChangeCommand(id, command)</term
><listitem
><para
>Izvedi <emphasis
>command</emphasis
> vsakič, ko se spremeni podrejena lastnost, podana z <emphasis
>id</emphasis
>.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Razred "RObject"</term>
<listitem
><para
>Razred, ki predstavlja en predmet v &R;. Pojavek tega razreda lahko dobite z uporabo <command
>makeRObject(objectname)</command
>. Za pojavke razreda "RObject" so na voljo naslednje metode: <warning
><para
>Če so kateri koli ukazi še vedno na čakanju v ozadju, so lahko informacije, ki jih zagotovijo te metode, zastarele do trenutka, ko se zažene koda vtičnika. <emphasis
>Ne</emphasis
> zanašajte se nanj pri kritičnih operacijah (tveganje izgube podatkov).</para
></warning>
	<variablelist>
	<varlistentry
><term
>getName()</term
><listitem
><para
>Vrne absolutno ime predmeta.</para
></listitem
></varlistentry>
	<varlistentry
><term
>exists()</term
><listitem
><para
>Vrne, ali predmet obstaja. Na splošno morate to preveriti, preden uporabite katero koli od spodaj navedenih metod.</para
></listitem
></varlistentry>
	<varlistentry
><term
>dimensions()</term
><listitem
><para
>Vrne niz dimenzij (podobno kot <command
>dim()</command
> v R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>classes()</term
><listitem
><para
>Vrne matriko razredov (podobno kot <command
>class()</command
> v R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>isClass(class)</term
><listitem
><para
>Vrne true, če je objekt razreda <emphasis
>class</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFrame()</term
><listitem
><para
>Vrne true, če je objekt data.frame.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isMatrix()</term
><listitem
><para
>Vrne true, če je objekt matrix.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isList()</term
><listitem
><para
>Vrne true, če je objekt seznam.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isFunction()</term
><listitem
><para
>Vrne true, če je objekt funkcija.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isEnvironment()</term
><listitem
><para
>Vrne true, če je objekt okolje.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataNumeric()</term
><listitem
><para
>Vrne true, če je objekt vektor številskih podatkov.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFactor()</term
><listitem
><para
>Vrne true, če je objekt vektor faktorskih podatkov.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataCharacter()</term
><listitem
><para
>Vrne true, če je objekt vektor znakovnih podatkov.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataLogical()</term
><listitem
><para
>Vrne true, če je objekt vektor logičnih podatkov.</para
></listitem
></varlistentry>
	<varlistentry
><term
>parent()</term
><listitem
><para
>Vrne pojavek "RObject", ki predstavlja nadrejenega elementa tega predmeta.</para
></listitem
></varlistentry>
	<varlistentry
><term
>child(childname)</term
><listitem
><para
>Vrne pojavek "RObject", ki predstavlja podrejeno <emphasis
>childname</emphasis
> tega predmeta.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Razred "RObjectArray"</term>
<listitem
><para
>Niz primerkov RObject. Primerek tega razreda lahko dobite z uporabo <command
>makeRObjectArray(objectnames)</command
>. Še posebej je uporabno pri delu z varsloti, ki omogočajo izbiro več predmetov.</para
></listitem>
</varlistentry>
<varlistentry
><term
>include()-function</term>
<listitem
><para
><command
>include(ime datoteke)</command
> lahko uporabite za vključitev ločene datoteke JS.</para
></listitem>
</varlistentry>
<varlistentry
><term
>doRCommand()-function</term>
<listitem
><para
><command
>doRCommand(command, callback)</command
> se lahko uporablja za poizvedbo &R; za informacijo. Preberite razdelek o <link linkend="querying_r_for_info"
>poizvedovanju &R; znotraj vtičnika</link
> za podrobnosti in opozorila.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

</appendix>

<appendix id="troubleshooting">
<title
>Odpravljanje težav med razvojem vtičnika</title>
<para
>Torej ste prebrali vso dokumentacijo, naredili vse pravilno, pa še vedno ne morete spraviti v delo? Brez skrbi, uredili bomo. Prva stvar, ki jo morate storiti, je: Aktivirajte <guilabel
>&rkward; Sporočila o odpravljanju napak</guilabel
> - okno (na voljo v meniju <guimenu
>Windows</guimenu
> - ali z desnim klikom na eno od orodnih vrstic) in nato znova zaženite svoj vtičnik. Splošno pravilo je, da v oknu s sporočili ne smete videti nobenega izhoda, ko je priklican vaš vtičnik ali kadar koli drugje. Če obstaja, je verjetno povezan z vašim vtičnikom. Poglejte, če vam pomaga. </para>
<para
>Če se zdi, da je na konzoli vse v redu, poskusite povečati raven odpravljanja napak (v ukazni vrstici z uporabo <command
>rkward --debug-level 3</command
> ali tako, da nastavite raven odpravljanja napak na 3 v <menuchoice
><guimenu 
>Nastavitve</guimenu
> <guimenuitem
>Konfiguriraj &rkward;</guimenuitem
> <guimenuitem
>Odpravljanje napak</guimenuitem
></menuchoice
>). Ni nujno, da vsa sporočila, prikazana na višjih ravneh odpravljanja napak, kažejo na težavo, vendar je verjetno, da se vaša težava pojavi nekje med sporočili. </para>
<para
>Če še vedno ne morete ugotoviti, kaj je narobe, ne obupajte. Vemo, da je to zapletena stvar in – navsezadnje – morda ste tudi vi naleteli na napako v &rkward; in &rkward; je treba popraviti. Samo pišite na poštni seznam za razvoj in nam povejte o težavi. Z veseljem vam bomo pomagali. </para>
<para
>Nazadnje, tudi če ste izvedeli, kako to storiti sami, vendar ste ugotovili, da dokumentacija ni preveč koristna ali celo napačna v nekaterih pogledih, nam to sporočite tudi na poštnem seznamu, da bomo lahko popravili/izboljšali dokumentacijo. </para>
</appendix>

<appendix id="license">
<title
>Licenca</title>
<para
>Prevod: Matjaž Jeran <email
>matjaz.jeran@amis.net</email
></para
> 
&underFDL;
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
