<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [
  <!ENTITY rkward '<application
>RKWard</application
>'>
  <!ENTITY R '<application
>R</application
>'>
  <!ENTITY javascript 'JavaScript'>
  <!ENTITY pluginmap '<literal role="extension"
>.pluginmap</literal
>'>
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Ukrainian "INCLUDE"
><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!--- This file is part of the RKWard project (https://rkward.kde.org).
SPDX-FileCopyrightText: by Thomas Friedrichsmeier <thomas.friedrichsmeier@kdemail.net>
SPDX-FileCopyrightText: by Meik Michalke <meik.michalke@hhu.de>
SPDX-FileContributor: The RKWard Team <rkward-devel@kde.org>
SPDX-License-Identifier: GFDL-1.2-no-invariants-or-later OR GPL-2.0-or-later
-->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title
>Вступ до написання додатків до &rkward;</title>

<authorgroup>
<author
><firstname
>Thomas</firstname
> <surname
>Friedrichsmeier</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>

<author
><firstname
>Meik</firstname
> <surname
>Michalke</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>
<!-- Additional authors go here -->

<othercredit role="translator"
><firstname
>Юрій</firstname
><surname
>Чорноіван</surname
><affiliation
><address
><email
>yurchor@ukr.net</email
></address
></affiliation
><contrib
>Переклад українською</contrib
></othercredit
> 
</authorgroup>



<copyright>
<year
>2006-2022</year>
<holder
>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice
>&FDLNotice;</legalnotice>

<date
>24 квітня 2022 року</date>
<releaseinfo
>0.7.4</releaseinfo>

<abstract>
<para
>Цей підручник присвячено питанням написання додатків до &rkward;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>R</keyword>
<keyword
>rkward</keyword>
<keyword
>додатки</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title
>Вступ</title>

	<para
>У цьому документі описано способи створення додатків. З часом цей документ став доволі об’ємним. Нехай вас це не лякає. Ми рекомендуємо вам ознайомитися із чотирма базовими кроками (які наведено нижче), щоб вловити основні принципи роботи. Після цього ви можете перейти до таблиці змісту цього підручника, щоб визначити розділи, які могли б вас зацікавити. </para>
	<para
>Якщо у вас виникнуть питання або коментарі, будь ласка, поділіться ними у списку листування розробників &rkward;. </para>
	<para
><emphasis
>Вам не потрібно читати цей підручник, щоб користуватися &rkward;.</emphasis
> Цей документ присвячено розширенню можливостей &rkward;. Його читачами мають стати досвідчені користувачі або ті, хто хоче допомогти у поліпшенні &rkward;. </para>
	<para
>Написання стандартного додатка, загалом, — це чотирикроковий процес: </para>
		<itemizedlist>
			<listitem
><para
><link linkend="pluginmap"
>Додавання нового пункту у ієрархію меню.</link
></para
></listitem>
			<listitem
><para
><link linkend="mainxml"
>Описання вигляду та поведінки графічного інтерфейсу додатка.</link
></para
></listitem>
			<listitem
><para
><link linkend="jstemplate"
>Визначення того, як слід створювати код R на основі параметрів, які користувач визначає за допомогою графічного інтерфейсу.</link
></para
></listitem>
			<listitem
><para
><link linkend="pluginhelp"
>Додавання сторінок довідки до вашого додатка.</link
></para
></listitem>
		</itemizedlist>
	<para
>Ми опишемо усі ці кроки послідовно. </para>
	<para
>Під час виконання цих чотирьох кроків може бути використано деякі додаткові концепції, але для простоти ми розібрали їх у окремих главах: <itemizedlist>
			<listitem
><para
><link linkend="logic"
>Логіка графічного інтерфейсу</link
></para
></listitem>
			<listitem
><para
><link linkend="embedding"
>Вбудовування додатків до додатків</link
></para
></listitem>
			<listitem
><para
><link linkend="plugin_series"
>Корисні концепції щодо створення серій з подібних додатків</link
></para
></listitem>
		</itemizedlist>
	</para>
	<para
>Крім того, у жодній з глав не викладено усіх можливостей, швидше там можна знайти лише загальні концепції. Повний <link linkend="reference"
>довідник</link
> усіх параметрів наведено окремо. </para>
</chapter>

<chapter id="whatareplugins">
<title
>Попередні зауваження. Для чого призначено додатки у &rkward;? Як працюють додатки?</title>
	<para
>Звичайно ж, першим питанням, яке може у вас виникнути: яку частину функціональних можливостей &rkward; реалізовано за допомогою додатків або що можна зробити за допомогою додатків? </para>
	<para
>Ось один зі способів відповісти: зніміть позначки з усіх файлів &pluginmap; на сторінці <menuchoice
><guimenu
>Параметри</guimenu
><guimenuitem
>Налаштувати &rkward;</guimenuitem
><guimenuitem
>Додатки</guimenuitem
></menuchoice
> і подивіться, чого не вистачає у програмі. Трохи конструктивніша відповідь: більшість статистичних функцій, доступ до яких можна отримати з графічного інтерфейсу програми, реалізовано за допомогою додатків. Крім того, ви можете створити доволі гнучкий графічний інтерфейс до усіх типів дій за допомогою додатків. </para>
	<para
>Базова парадигма додатків &rkward; ґрунтується на саме такому порядку, у якому її викладено у цьому підручнику: файл XML описує вигляд графічного інтерфейсу додатка, додатковий файл JavaScript використовується для створення команд &R; на основі визначених у графічному інтерфейсі параметрів. Тобто, додатки насправді не виконують ніяких статистичних обчислень. Замість цього, додатки створюють набір команд &R;, за допомогою якого і виконуються ці обчислення. Команди &R; надсилаються до модуля обробки коду &R; для виконання, а результат, типово, буде показано у вікні виведення даних. </para>
	<para
>У наступних розділах можна знайти докладні відомості щодо цих питань. </para>
</chapter>

<chapter id="pluginmap">
<title
>Створення пунктів меню</title>
	<para
>Для створення додатка вам слід повідомити &rkward; про нього. Отже, першим, що слід зробити, є створення файла &pluginmap; (або внесення змін до наявного файла). Форматом &pluginmap; є XML. Розгляньмо приклад (звичайно ж, вам слід подбати про те, щоб &rkward; було налаштовано на завантаження вашого файла &pluginmap; -- <menuchoice
><guimenu
>Параметри</guimenu
><guimenuitem
>Налаштувати &rkward;</guimenuitem
><guimenuitem
>Додатки</guimenuitem
></menuchoice
>): </para>
	<tip>
		<para
>Після прочитання цієї глави зверніться до <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>. У ньому реалізовано декілька функцій &R; для створення більшості теґів XML &rkward;. </para>
	</tip>
	<programlisting
>&lt;!DOCTYPE rkpluginmap&gt;
        </programlisting>
	<para
>Значення типу документа (doctype) насправді не обробляється, але для нього встановлюється значення <replaceable
>"rkpluginmap"</replaceable
>. </para>
	<programlisting
>&lt;document base_prefix="" namespace="myplugins" id="mypluginmap"&gt;
        </programlisting>
	<para
>Атрибутом <parameter
>base_prefix</parameter
> можна скористатися, якщо усі ваші додатки зберігаються у одному каталозі. Загалом, тоді ви можете не вказувати каталог у назвах файлів, визначених нижче. Можна залишити для цього атрибута значення <replaceable
>""</replaceable
>. </para
><para
>Як ви побачите далі, усі додатки мають власні унікальні ідентифікатори, <parameter
>id</parameter
>. Параметр <parameter
>namespace</parameter
> призначено для упорядковування таких ідентифікаторів з метою запобігання випадковому дублюванню ідентифікаторів. На внутрішньому рівні значення namespace і <quote
>::</quote
> дописуються перед усіма ідентифікаторами, які ви визначаєте у цім &pluginmap;. Загалом, якщо ви маєте намір <link linkend="sect_external_plugins"
>поширювати ваші додатки як пакунок &R;</link
>, вам варто скористатися для значення параметра <parameter
>namespace</parameter
> назвою вашого пакунка. Додатки, які постачаються разом із офіційним дистрибутивом &rkward; мають значення параметра <replaceable
>namespace="rkward"</replaceable
>. </para>
	<para
>Атрибут <parameter
>id</parameter
> є необов’язковим, але визначення ідентифікатора для вашого &pluginmap; уможливлює для інших програмістів автоматичне завантаження у їхніх &pluginmap; вашого &pluginmap; (див. <link linkend="chapter_dependencies"
>розділ щодо залежностей</link
>). </para>
	<programlisting
>&lt;components&gt;
        </programlisting>
	<para
>Компоненти? Ми ж, начеб-то, говорили про додатки? Так, але у майбутньому, додатки будуть нічим іншим, ніж особливим класом компонентів. Тому усе, що ми тут робимо, є реєстрацією усіх компонентів або додатків у &rkward;. Розгляньмо приклад запису: </para>
	<programlisting
>&lt;component type="standard" id="t_test_two_vars" file="t_test_two_vars.xml" label="Two Variable t-Test" /&gt;
        </programlisting>
	<para
>Спочатку, атрибут <parameter
>type</parameter
>: поки що залишимо для нього значення <replaceable
>"standard"</replaceable
>. Інші типи ще не реалізовано. Про <parameter
>id</parameter
> ми вже писали вище. Кожному компоненту має бути надано унікальний (у його просторі назв) ідентифікатор. Виберемо простий для розпізнавання. Не варто використовувати пробіли або символи, які не належать до типової латинської абетки. Використання таких символів не заборонено, але вони можуть мати якесь спеціальне призначення. За допомогою атрибута <parameter
>file</parameter
> ви вказуєте, де зберігається <link linkend="mainxml"
>опис самого додатка</link
>. Адресу файла слід вказувати відносно каталогу, у якому зберігається файл &pluginmap; та <parameter
>base_prefix</parameter
>, вказаного вище. Нарешті, надамо компоненту мітку. Цю мітку буде показано у меню (або у інших місцях інтерфейсу у майбутніх версіях). </para>
	<para
>Типово у файлі &pluginmap; міститься декілька компонентів, отже, ось іще декілька компонентів: </para>
	<programlisting
>&lt;component type="standard" id="unimplemented_test" file="means/unimplemented.xml" /&gt;
                &lt;component type="standard" id="fictional_t_test" file="means/ttests/fictional.xml" label="This is a fictional t-test" /&gt;
                &lt;component type="standard" id="descriptive" file="descriptive.xml" label="Descriptive Statistics" /&gt;
                &lt;component type="standard" id="corr_matrix" file="corr_matrix.xml" label="Correlation Matrix" /&gt;
                &lt;component type="standard" id="simple_anova" file="simple_anova.xml" label="Simple Anova" /&gt;
        &lt;/components&gt;
        </programlisting>
	<para
>Гаразд, на першому кроці ми повідомили &rkward;, що такі додатки існують. Як же тепер їх викликати? Слід розмістити відповідні пункти у ієрархії меню: </para>
	<programlisting
>&lt;hierarchy&gt;
                &lt;menu id="analysis" label="Analysis"&gt;
        </programlisting>
	<para
>Одразу після теґу <command
>&lt;hierarchy&gt;</command
> ви маєте почати опис того, у якому <command
>&lt;menu&gt;</command
> буде ваш пункт додатка. У наведеному вище рядку ви повідомляєте, що пункт додатка має бути розташовано у меню <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> (не обов’язково у основному списку пунктів, можливо, у підменю). Меню <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> є стандартним у &rkward;, отже його не потрібно буде створювати з нуля. Втім, якщо меню ще не існує, за допомогою атрибута <parameter
>label</parameter
> ви створите його і дасте йому назву. Нарешті, атрибут <parameter
>id</parameter
> ще раз ідентифікує це <command
>&lt;menu&gt;</command
>. Він потрібен для того, щоб декілька файлів &pluginmap; могли розмістити пункти додатків у одному меню. Програма виконує упорядковування меню, шукаючи <command
>&lt;menu&gt;</command
> з вказаним <parameter
>id</parameter
>. Якщо меню з таким ідентифікатором ще не існує, програма створює нове меню. Якщо ж меню з таким ідентифікатором буде знайдено, пункт додатка буде додано саме до нього. </para>
	<programlisting
>&lt;menu id="means" label="Means"&gt;
        </programlisting>
	<para
>В основному, те саме: тепер ми визначаємо підменю у меню <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Воно називатиметься <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="ttests" label="t-Tests"&gt;
        </programlisting>
	<para
>І остаточний рівень ієрархії меню: підменю меню <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;entry component="t_test_two_vars" /&gt;
        </programlisting>
	<para
>Тепер, нарешті, меню, у якому ми хочемо розташувати наш пункт додатка. Теґ <command
>&lt;entry&gt;</command
> повідомить програмі, що це, нарешті, сам пункт, а не ще одне підменю. Атрибут <parameter
>component</parameter
> посилається на <parameter
>id</parameter
>, який ми надали додатку або компоненту вище. </para>
	<programlisting
>&lt;entry component="fictional_t_test" /&gt;
                                &lt;/menu&gt;
                                &lt;entry component="fictional_t_test" /&gt;
                        &lt;/menu&gt;
                        &lt;menu id="frequency" label="Frequency" index="2"/&gt;
        </programlisting>
	<para
>Якщо ви ще не зрозуміли, це ще одне підменю меню <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Див. наведений нижче знімок вікна. Ми пропустили частину, яку не видно, позначивши її [...]. </para>
	<programlisting
>[...]
                        &lt;/menu&gt;
                        &lt;entry component="corr_matrix"/&gt;
                        &lt;entry component="descriptive"/&gt;
                        &lt;entry component="simple_anova"/&gt;
                &lt;/menu&gt;
        </programlisting>
	<para
>Це завершальні пункти, які видно на наведеному нижче знімку вікна. </para>
	<programlisting
>&lt;menu id="plots" label="Plots"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Звичайно ж, ви можете розташувати ваші додатки у меню, відмінних від меню <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="file" label="File"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Навіть у стандартних меню, зокрема <menuchoice
><guimenu
>File</guimenu
></menuchoice
>. Вам лише треба вказати відповідне значення <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;/hierarchy&gt;        
&lt;/document&gt;
        </programlisting>
	<para
>Ось як це робиться. І знімок вікна, на якому показано результат: </para>
	<screenshot>
	<screeninfo
>Ієрархія меню, створена за допомогою наведеного вище коду</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Ієрархія меню, створена за допомогою наведеного вище коду</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Незрозуміло? Найпростіше буде розпочати з файлів &pluginmap;, які постачаються разом із &rkward;, вносячи в них потрібні вам виправлення. Крім того, якщо вам потрібна допомога, не вагайтеся і пишіть до списку листування розробників. </para>
	<sect1 id="pluginmap_grouping"
><title
>Керування порядком пунктів меню</title>
		<para
>Типово, усі пункти (записи або підменю) у меню буде автоматично упорядковано за абеткою. У <emphasis
>деяких</emphasis
> випадках варто втрутитися у цей процес. Якщо це так, ви можете згрупувати елементи у такий спосіб:</para>
		<itemizedlist>
			<listitem>
				<para
>Таким чином, ви можете визначити групи у будь-якому меню. Усі елементи, що належать одній групі буде згруповано:</para>
				<programlisting
>&lt;group id="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
			<para
>Якщо ви хочете візуально відокремити групу від інших пунктів, скористайтеся такою синтаксичною конструкцією:</para>
				<programlisting
>&lt;group id="somegroup" separated="true"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Пункти, меню та групи можна додати до певної групи, ось так:</para>
				<programlisting
>&lt;entry component="..." group="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Фактично, можна визначити групи (без ліній-роздільників) неявно:</para>
				<programlisting
>&lt;entry component="first" group="a"/&gt;
                &lt;entry component="third"/&gt;
                &lt;entry component="second" group="a"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Назви груп є специфічними для кожного меню. Наприклад, група «a» у меню «Data» не конфліктує з групою «a» у меню «Analysis».</para>
			</listitem
><listitem>
				<para
>Найпоширенішим випадком визначення груп є пункти на початку і наприкінці меню. Для таких пунктів передбачено групи «top» (верх) і «bottom» (низ) у кожному меню.</para>
			</listitem
><listitem>
				<para
>Записи у межах кожної з груп упорядковуються за абеткою. Групи упорядковуються за порядком оголошення (якщо їх, звичайно ж, не дописано до іншої групи).</para>
			</listitem
><listitem>
				<para
>Меню і пункти без визначеної групи, логічно, також утворюють групу окрему групу ("").</para>
			</listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="mainxml">
<title
>Визначення графічного інтерфейсу</title>
<sect1 id="sect_defining_the_GUI"
><title
>Визначення діалогового вікна</title>
	<para
>У <link linkend="pluginmap"
>попередньому розділі</link
> ми обговорювали питання щодо реєстрації додатка у &rkward;. Найважливішим є визначення шляху до файла XML із описом того, як має виглядати інтерфейс додатка. У цьому розділі ми спробуємо навчитися створювати такі файли XML. </para>
	<tip>
		<para
>Після прочитання цієї глави зверніться до <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>. У ньому реалізовано декілька функцій &R; для створення більшості теґів XML &rkward;. </para>
	</tip>
	<para
>Знову ж таки, ми будемо обговорювати конкретний приклад. У нашому прикладі (дещо спрощеному) ми створимо інтерфейс до двофакторної t-перевірки. </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
        </programlisting>
	<para
>Значення типу документа (doctype) насправді ще не обробляється, але для нього встановлюється значення <replaceable
>rkplugin</replaceable
>. </para>
	<programlisting
>&lt;document&gt;
        &lt;code file="t_test_two_vars.js"/&gt;
        </programlisting>
	<para
>Усі додатки створюють певний програмний код. У поточній версії єдиним способом створити цей код є використання JS, як це докладно описано у <link linkend="jstemplate"
>наступному розділі</link
>. Наведений вище фрагмент визначає, де шукати код JS. Назву файла слід вказувати відносно каталогу, у якому зберігається файл XML додатка. </para>
	<programlisting
>&lt;help file="t_test_two_vars.rkh"/&gt;
        </programlisting>
	<para
>Зазвичай, непогано супроводжувати ваш додаток сторінкою довідки. У наведеному вище фрагменті вказано назву файла сторінки довідки відносно каталогу, у якому зберігається файл XML додатка. Документацію щодо написання сторінок довідки наведено <link linkend="pluginhelp"
>тут</link
>. Якщо ви не надаєте файла довідки, пропустіть цей рядок. </para>
	<programlisting
>&lt;dialog label="Two Variable t-Test"&gt;
        </programlisting>
	<para
>Як ви знаєте, додатки можуть показувати діалогові вікна, можуть працювати як майстер налаштовування або можуть виконувати обидві функції. У нашому прикладі ми розпочнемо визначати інтерфейс діалогового вікна. Атрибут <parameter
>label</parameter
> визначити надпис на смужці заголовка цього діалогового вікна. </para>
	<programlisting
>&lt;tabbook&gt;
                        &lt;tab label="Basic settings"&gt;
        </programlisting>
	<para
>Елементи графічного інтерфейсу можна упорядкувати за допомогою книги із вкладками (tabbook). Тут ми визначили tabbook як перший елемент у діалоговому вікні. Використовуйте обгортку <command
>&lt;tabbook&gt;</command
>[...]<command
>&lt;/tabbook&gt;</command
>, щоб визначити tabbook, потім перейдіть до визначення кожної сторінки у tabbook за допомогою конструкцій <command
>&lt;tab&gt;</command
>[...]<command
>&lt;/tab&gt;</command
>. Атрибут <parameter
>label</parameter
> у елементі <command
>&lt;tab&gt;</command
> визначить надпис на відповідній вкладці tabbook. </para>
	<programlisting
>&lt;row id="main_settings_row"&gt;
        </programlisting>
	<para
>Теґи <command
>&lt;row&gt;</command
> і <command
>&lt;column&gt;</command
> визначають компонування елементів графічного інтерфейсу. Тут ми вказуємо програмі, що хочемо розташувати певні елементи інтерфейсу паралельно у стовпчиках (зліва праворуч). Атрибут <parameter
>id</parameter
> не є обов’язковим, але ми його пізніше використаємо, коли додаватимемо інтерфейс майстра до нашого додатка. Першим елементом у рядку є цей елемент: </para>
	<programlisting
>&lt;varselector id="vars"/&gt;
        </programlisting>
	<para
>За допомогою цього простого теґу ви створюєте список, з якого користувач може вибрати змінні. Ви можете вказати <parameter
>id</parameter
> цього елемента, щоб &rkward; пізніше міг його знайти. </para>
	<warning>
		<para
>У рядку <parameter
>id</parameter
> не можна використовувати крапку (.). </para>
	</warning>
	<programlisting
>&lt;column&gt;
        </programlisting>
	<para
>Далі, ми вкладемо <command
>&lt;column&gt;</command
> до row. Тобто, відповідні елементи буде розташовано один над одним (у стовпчик, згори униз), і всі вони розташовуватимуться праворуч від <command
>&lt;varselector&gt;</command
>. </para>
	<programlisting
>&lt;varslot types="number" id="x" source="vars" required="true" label="compare"/&gt;
                                                &lt;varslot types="number" id="y" source="vars" required="true" label="against" i18n_context="compare against"/&gt;
        </programlisting>
	<para
>Ці елементи є невід’ємною частиною <command
>&lt;varselector&gt;</command
>. Вони відповідають за <quote
>гнізда</quote
>, у яких користувач може задавати змінні. Як можна бачити, для <parameter
>source</parameter
> встановлено те саме значення <parameter
>id</parameter
>, що і для <command
>&lt;varselector&gt;</command
>. Це означає, що <command
>&lt;varslot&gt;</command
> також братимуть змінні з varselector. Теґу <command
>&lt;varslot&gt;</command
> також слід надати <parameter
>id</parameter
>. Такі теґи можуть мати атрибут <parameter
>label</parameter
>, а також можуть бути позначені як <parameter
>required</parameter
> (обов’язкові). Це означає, що кнопку <guibutton
>Submit</guibutton
> не буде доступною для натискання, доки у <command
>&lt;varslot&gt;</command
> не міститиметься коректного значення. Нарешті, атрибут <parameter
>type</parameter
> ще не обробляється, але його буде використано для забезпечення коректності типу змінної у <command
>&lt;varslot&gt;</command
> у наступних версіях. </para>
	<para
>Якщо вас зацікавив атрибут <parameter
>i18n_context</parameter
>: його призначено для надання контекстної довідки для перекладачів слова «against», яке є міткою <command
>&lt;varslot&gt;</command
>, але не впливає на функціональні можливості додатка безпосередньо. Докладніше про цей атрибут у <link linkend="i18n_general"
>окремому розділі</link
>. </para>
	<programlisting
>&lt;radio id="hypothesis" label="using test hypothesis"&gt;
                                                        &lt;option value="two.sided" label="Two-sided"/&gt;
                                                        &lt;option value="greater" label="First is greater"/&gt;
                                                        &lt;option value="less" label="Second is greater"/&gt;
                                                &lt;/radio&gt;
        </programlisting>
	<para
>Тут ми визначаємо групу кнопок взаємовиключних варіантів <command
>&lt;radio&gt;</command
>. У групи є аргумент <parameter
>label</parameter
> і ідентифікатор <parameter
>id</parameter
>. Кожен варіант, <command
>&lt;option&gt;</command
>, (кнопка) має власну мітку <parameter
>label</parameter
> і значення <parameter
>value</parameter
>. Це значення, яке елемент <command
>&lt;radio&gt;</command
> поверне, якщо буде вибрано відповідний варіант. </para>
	<programlisting
>&lt;/column&gt;
                                &lt;/row&gt;
                        &lt;/tab&gt;
        </programlisting>
	<para
>Кожен теґ має бути завершено, початковому теґу має відповідати завершальний. Ми розмістили усі потрібні нам елементи (два <command
>&lt;varslots&gt;</command
> і <command
>&lt;radio&gt;</command
>) у стовпчику <command
>&lt;column&gt;</command
>. Ми також розмістили усі потрібні нам елементи (<command
>&lt;varselector&gt;</command
> і <command
>&lt;column&gt;</command
> з цими елементами) у <command
>&lt;row&gt;</command
>. І ми розмістили усі потрібні нам елементи на першій сторінці у <command
>&lt;tabbook&gt;</command
>. Ми ще не завершили визначення <command
>&lt;tabbook&gt;</command
> (інші сторінки доведеться визначити пізніше) і, звичайно ж, ще залишилося багато чого визначити у <command
>&lt;dialog&gt;</command
>. Але ось знімок вікна, як все визначене нами виглядатиме: </para>
	<screenshot>
	<screeninfo
>Додаток t-перевірки</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="t_test_plugin_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Додаток t-перевірки</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Зауважте, що ми не визначали кнопки <guibutton
>Submit</guibutton
>, <guibutton
>Close</guibutton
> тощо і пов’язаний з ними код. Ці елементи створюються автоматично. Але, звичайно ж, нам доведеться визначити другу сторінку <command
>&lt;tabbook&gt;</command
>: </para>
	<programlisting
>&lt;tab label="Options"&gt;
                                &lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
        </programlisting>
	<para
>Типово, елементи буде розташовано згори вниз, подібно до <command
>&lt;column&gt;</command
>. Оскільки це те саме, що нам потрібно, ми не будемо визначати явно компонування <command
>&lt;row&gt;</command
> або <command
>&lt;column&gt;</command
>. Першим визначеним нами елементом буде пункт з позначкою. Так само, як <command
>&lt;radio&gt;</command
> <command
>&lt;option&gt;</command
>, пункт для позначки має мітку <parameter
>label</parameter
> і значення <parameter
>value</parameter
>. Значення <parameter
>value</parameter
> буде повернуто, якщо користувач позначить пункт. Звичайно ж, пункт для позначки потребує власного ідентифікатора <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;frame label="Confidence Interval" id="frame_conf_int"&gt;
        </programlisting>
	<para
>Тут ми маємо ще один елемент компонування: щоб повідомити програми, що два елементи нижче пов’язано між собою, ми малюємо <command
>&lt;frame&gt;</command
> (рамку). Ця рамка може мати атрибут <parameter
>label</parameter
> (надпис). Оскільки рамка є простим пасивним елементом компонування, вона не потребує ідентифікатора <parameter
>id</parameter
>. Втім, ми визначимо такий атрибут, оскільки ідентифікатор може нам знадобитися пізніше, коли ми визначатимемо додатковий інтерфейс майстра. </para>
	<programlisting
>&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
                                        &lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
                                &lt;/frame&gt;
        </programlisting>
	<para
>У рамці <command
>&lt;frame&gt;</command
> ми розташуємо ще один пункт для позначення <command
>&lt;checkbox&gt;</command
> (за допомогою атрибута <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
> ми повідомляємо, що типово пункт має бути позначено) та поле лічильника <command
>&lt;spinbox&gt;</command
>. За допомогою поля лічильника користувач може вибрати значення від <replaceable
>"min"</replaceable
> до <replaceable
>"max"</replaceable
> з типовим або початковим значенням <replaceable
>"0.95"</replaceable
>. Встановленням типу <parameter
>type</parameter
> у значення <replaceable
>"real"</replaceable
> ми повідомляємо програмі, що прийнятними є дійсні числа, на відміну від типу <parameter
>type=</parameter
><replaceable
>"integer"</replaceable
>, для якого прийнятними були б лише цілі числа. </para>
	<note
><para
>Також можна, а іноді навіть бажано, зробити <command
>&lt;frame&gt;</command
> придатним до позначення, замість додавання <command
>&lt;checkbox&gt;</command
> всередину. Див. довідник з форматування, щоб дізнатися більше. Тут ми цього не робили з міркувань збереження наочності. </para
></note>
	<programlisting
>&lt;/tab&gt;
                &lt;/tabbook&gt;
        &lt;/dialog&gt;
        </programlisting>
	<para
>Ось і усе для другої сторінки <command
>&lt;tabbook&gt;</command
>, усі сторінки у <command
>&lt;tabbook&gt;</command
> і усі елементи у <command
>&lt;dialog&gt;</command
>. Ми завершили визначення вигляду діалогового вікна. </para>
	<programlisting
>&lt;/document&gt;
        </programlisting>
	<para
>Нарешті, ми завершуємо теґ <command
>&lt;document&gt;</command
> і увесь опис. Графічний інтерфейс визначено. Тепер можна зберегти файл. Але як буде створено синтаксичні конструкції команд &R; на основі параметрів з графічного інтерфейсу? Ми поговоримо про це у <link linkend="jstemplate"
>наступному розділі</link
>. Втім, спершу, ми познайомимося із тим, якщо додати інтерфейс майстра та обговоримо ще декілька загальних питань. </para>
</sect1>

<sect1 id="wizard_interface">
	<title
>Додавання інтерфейсу майстра</title>
	<para
>Насправді, нам не потрібно визначати окремий інтерфейс майстра <command
>&lt;wizard&gt;</command
>, ми скористаємося іншим способом. Щоб додати інтерфейс майстра, додаємо теґ <command
>&lt;wizard&gt;</command
> на тому самому рівні, що і теґ <command
>&lt;dialog&gt;</command
>: </para>
	<programlisting
>&lt;wizard label="Two Variable t-Test"&gt;
                        &lt;page id="firstpage"&gt;
                                &lt;text&gt;As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater.&lt;/text&gt;
                                &lt;copy id="main_settings_row"/&gt;
                        &lt;/page&gt;
        </programlisting>
	<para
>Дещо можна зрозуміти і без пояснень: ми додаємо теґ <command
>&lt;wizard&gt;</command
> із міткою <parameter
>label</parameter
> для створення майстра. Оскільки у майстрі може бути декілька сторінок, які буде показано одна за одною, далі ми визначаємо першу сторінку <command
>&lt;page&gt;</command
> і додаємо на неї пояснювальну нотатку <command
>&lt;text&gt;</command
>. Далі, ми користуємося теґом <command
>&lt;copy&gt;</command
>. Цей теґ позбавляє нас від потреби у визначенні того, що ми вже написали для <command
>&lt;dialog&gt;</command
>: теґ copy шукає інший теґ з таким самим ідентифікатором <parameter
>id</parameter
> у попередній частині коду XML. У нашому випадку це усе, що визначено у розділі <command
>&lt;dialog&gt;</command
>, тобто <command
>&lt;row&gt;</command
>, у якому є <command
>&lt;varselector&gt;</command
>, <command
>&lt;varslots&gt;</command
> і варіанти <quote
>hypothesis</quote
> у <command
>&lt;radio&gt;</command
>. Усе це копіюється без змін 1:1 і вставляється на місце елемента <command
>&lt;copy&gt;</command
>. </para>
	<para
>Тепер друга сторінка: </para>
	<programlisting
>&lt;page id="secondpage"&gt;
                                &lt;text&gt;Below are some advanced options. It's generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing "assume equal variances" may increase test-strength, however.&lt;/text&gt;
                                &lt;copy id="varequal"/&gt;
                                &lt;text&gt;Sometimes it's helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance).&lt;/text&gt;
                                &lt;copy id="frame_conf_int"/&gt;
                        &lt;/page&gt;
                &lt;/wizard&gt;
        </programlisting>
	<para
>Майже те саме. Ми додаємо текст, а між ним <command
>&lt;copy&gt;</command
> (копіюємо подальші розділи з інтерфейсу діалогового вікна). </para>
	<para
>Звичайно ж, ви можете зробити вигляд інтерфейсу майстра дуже далеким від звичайного діалогового вікна, і можете не використовувати теґ <command
>&lt;copy&gt;</command
> взагалі. Втім, не забувайте призначати відповідним елементам однакові ідентифікатори <parameter
>id</parameter
> у обох інтерфейсах. Це використовується не лише для передавання параметрів з інтерфейсу діалогового вікна до інтерфейсу майстра і навпаки, коли користувач перемикає інтерфейси (що ще не реалізовано у поточній версії &rkward;), але і спрощує написання шаблонів коду (див. нижче). </para>
</sect1>

<sect1 id="mainxmltips">
	<title
>Деякі розмірковування щодо компонування інтерфейсу</title>
	<para
>У цьому розділі містяться деякі загальні розмірковування щодо того, де і які елементи графічного інтерфейсу слід використовувати. Якщо ви намагаєтеся створити свій перший додаток, можете пропустити цей розділ, оскільки він не стосується базової роботи з графічним інтерфейсом. Повертайтеся до цього розділу згодом, щоб дізнатися про те, як ви можете поліпшити графічний інтерфейс вашого додатка. </para>
	
	<sect2 id="radio_vs_checkbox_vs_dropdown">
		<title
>&lt;radio&gt;, &lt;checkbox&gt; і &lt;dropdown&gt;</title>
		<para
>Тре елементи <command
>&lt;radio&gt;</command
>, <command
>&lt;checkbox&gt;</command
>, <command
>&lt;dropdown&gt;</command
> мають подібне призначення: допомагають користувачеві вибрати один з декількох варіантів. Звичайно ж, поле з позначкою (checkbox) надає змогу вибрати лише один з двох варіантів: позначено чи не позначено. Отже, ним не можна скористатися, якщо варіантів більше за два. Але коли використовувати інші елементи? Ось декілька простих правил: </para>
		<para
>Якщо вам раптом захочеться створити <command
>&lt;radio&gt;</command
> або <command
>&lt;dropdown&gt;</command
> лише з двома пунктами, спочатку спитайте себе, чи не є питання, яке ви хочете задати користувачеві, питанням, відповіддю на яке буде «так» чи «ні». Наприклад, вибір між <quote
>коригувати результати</quote
> і <quote
>не коригувати результати</quote
>, або між <quote
>вилучити пропущені значення</quote
> і <quote
>зберегти пропущені значення</quote
>. Якщо це саме таке питання, оптимальним вибором буде <command
>&lt;checkbox&gt;</command
>: пункт з позначкою займає мало місця, має менше слів у мітках і є найпростішим для читання користувачем. Існує зовсім небагато ситуацій, коли варто вибирати <command
>&lt;radio&gt;</command
>, а не <command
>&lt;checkbox&gt;</command
>, якщо маємо лише два варіанти. Ось приклад: <quote
>Метод обчислень: 'pearson'/'spearman'</quote
>. Тут можливі і інші методи, а вибір методу не є вибором між двома взаємовиключними варіантами. </para>
		<para
>Вибір між <command
>&lt;radio&gt;</command
> і <command
>&lt;dropdown&gt;</command
> є здебільшого питанням наявності місця у вікні. <command
>&lt;dropdown&gt;</command
> має перевагу у тому, що споживає менше місця, навіть якщо варіантів вибору дуже багато. З іншого боку, <command
>&lt;radio&gt;</command
> має перевагу, яка полягає у тому, що усі варіанти можна бачити одразу, без натискання кнопки спадного списку. Загалом, якщо до вибору пропонується шість або більше варіантів, варто скористатися <command
>&lt;dropdown&gt;</command
>. Якщо ж варіантів п’ять або менше, перевагу слід надати <command
>&lt;radio&gt;</command
>. </para>
	</sect2>
</sect1>
</chapter>

<chapter id="jstemplate">
<title
>Створення коду &R; на основі параметрів графічного інтерфейсу</title>
<sect1 id="sect_generating_R_code"
><title
>Використання JavaScript у додатках &rkward;</title>
	<para
>Тепер, коли ми визначили графічний інтерфейс, слід попрацювати над створенням на його основі певного коду &R;. Для цього нам знадобиться ще один текстовий файл, <filename
>code.js</filename
>, який зберігатиметься у тому самому каталозі, що і <link linkend="mainxml"
><filename
>description.xml</filename
></link
>. Ви можете бути знайомі з програмуванням JavaScript (або, якщо бути зовсім точним, ECMA-script) чи нічого не знайти про цю мову програмування. Документації щодо JS вдосталь, як у друкованій формі, так і на сторінках інтернету (приклад: <ulink url="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide"
>https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide</ulink
>). Але для виконання більшості завдань вам не потрібно багато знати про JS, достатньо бути ознайомленим із дуже базовими можливостями. </para>
	<tip>
		<para
>Після прочитання цього розділу ознайомтеся також із <link linkend="rkwarddev"
>розділом щодо пакунка <application
>rkwarddev</application
></link
>. У цьому пакунку можна знайти деякі функції &R; для створення коду JavaScript, який часто використовується у &rkward;. Також у пакунку є засоби автоматичного виявлення змінних, які використовуються у файлі XML додатка і створення базового коду JavaScript, з якого можна розпочати роботу над кодом додатка. </para>
	</tip>
	<note>
		<para
>Текст файлів <literal role="extension"
>.js</literal
> додатків має бути записано у кодуванні UTF-8. Якщо ви користуєтеся символами поза таблицею ASCII, переконайтеся, що ваш редактор використовує саме це кодування. </para>
	</note>
	<para
>Для двопараметричної t-перевірки, файл <filename
>code.js</filename
> виглядатиме так (з проміжними коментарями): </para>
	<sect2 id="sect_JS_preprocess"
><title
>preprocess()</title>
		<programlisting
>function preprocess () {
}
                </programlisting>
		<para
>Файл JS поділено між трьома окремими функціями: <function
>preprocess()</function
>, <function
>calculate()</function
> та <function
>printout()</function
>. Причиною є те, що не увесь код потрібен на усіх етапах роботи. У поточній версії функція попередньої обробки (preprocess) у більшості випадків не використовується (вам вона теж далеко не завжди буде потрібна). </para>
	</sect2>
	<sect2 id="sect_JS_calculate"
><title
>calculate()</title>
		<programlisting
>function calculate () {
        echo ('res &lt;- t.test (x=' + getString ("x") + ', y=' + getString ("y") + ', hypothesis="' + getString ("hypothesis") + '"' + getString ("varequal"));
        var conflevel = getString ("conflevel");
        if (conflevel != "0.95") echo (', conf.level=' + conflevel);
        echo (')\n');
}
                </programlisting>
		<para
>Ця функція виконує створення самого коду команд &R;, які буде виконано на основі параметрів з графічного інтерфейсу. Розгляньмо її детальніше: код, який буде використано створюється за допомогою інструкції <function
>echo()</function
>. Якщо розглянути інструкцію <function
>echo()</function
> крок за кроком, першою її частиною є </para>
		<screen
>res &lt;- t.test (
                </screen>
		<para
>у форматі звичайного тексту. Далі, нам слід заповнити значення, яке вибрано користувачем як перша змінна. Ми отримуємо це значення за допомогою функції <function
>getString ("x")</function
> і дописуємо його до рядка для <quote
>трансляції</quote
>. Це виводить значення елемента графічного інтерфейсу з <parameter
>id=</parameter
><replaceable
>"x"</replaceable
>: нашого першого поля для позначки, <command
>&lt;checkbox&gt;</command
>. Далі, ми дописуємо «, » і робимо подібну ж операцію для отримання значення елемента <replaceable
>"y"</replaceable
> — другого поля для позначки, <command
>&lt;checkbox&gt;</command
>. Для гіпотези (група <command
>&lt;radio&gt;</command
>) та поля для позначки <command
>&lt;checkbox&gt;</command
> щодо рівних дисперсій процедура дуже схожа на описану вище. </para>
		<para
>Зауважте, що замість об’єднання фрагментів виведення за допомогою <quote
>+</quote
> ви можете скористатися декількома інструкціями <function
>echo()</function
>. Усе буде виведено у один рядок. Щоб додати символ розриву рядка у створений код, вставте <replaceable
>"\n"</replaceable
> наприкінці рядка. Теоретично, ви навіть можете створити багаторядкову команду за допомогою однієї інструкції echo, але варто все ж обмежуватися одним рядком (або частиною одного рядка) у створеному однією інструкцією <function
>echo()</function
> коді. </para>
		<note>
			<para
>Окрім функції <function
>getString()</function
>, передбачено функцію <function
>getBoolean()</function
>, яка намагатиметься повернути значення у логічному форматі (придатному до використання у інструкції <function
>if()</function
>), та функцію <function
>getList()</function
>, яка намагатиметься повернути спископодібні дані у <function
>Array()</function
> JS. Приклади застосування цих функцій буде наведено нижче.</para>
			<para
>У наявних додатках ви знайдете багато використань <function
>getValue()</function
> замість <function
>getString()</function
>. Фактично, ці дві функції <emphasis
>майже</emphasis
> ідентичні. Втім, використанню <function
>getString()</function
>, <function
>getBoolean()</function
> та <function
>getList()</function
> слід надавати перевагу, починаючи з версії 0.6.1. </para>
		</note>
		<para
>Для довірчого рівня все трошки складніше. З естетичних міркувань ми не хочемо явним чином вказувати довірчий рівень, який слід використовувати, якщо він відповідає типовому значенню. Отже, замість безумовного виведення значення, нам слід спочатку отримати його до змінної. Далі, ми перевіряємо, чи відрізняється ця змінна від <replaceable
>"0.95"</replaceable
>, і якщо це так, виводимо додатковий аргумент. Нарешті, ми виводимо завершальну дужку та символ кінця рядка, <replaceable
>")\n"</replaceable
>. Ось і усе у функції calculate. </para>
	</sect2>
	<sect2 id="sect_JS_printout"
><title
>printout()</title>
		<programlisting
>function printout () {
        echo ('rk.header (' + i18n ("Two Variable t-Test") + ')\n');
        echo ('rk.print (res)\n');
}
                </programlisting>
		<para
>Ось це і все, що може знадобитися у більшості випадків для функції printout. <function
>rk.header()</function
> виводить стандартний рядок заголовка для результатів. Зауважте, що у файлах <literal role="extension"
>.js</literal
> вам доведеться позначити усі придатні до перекладу рядки вручну за допомогою функції <command
>i18n()</command
> або альтернативних функцій. Докладніше про це у <link linkend="i18n_js"
>розділі щодо інтернаціоналізації</link
>. Ви також можете додати певні відомості щодо цього, якщо потрібно, наприклад: </para>
		<programlisting
>function printout () {
        new Header (i18n ("Two Variable t-Test"))
                  .addFromUI ("varequal")
                  .add (i18n ("Confidence level"), getString ("conflevel"))  // Note: written like this for illustration purposes. More automatic:
        //        .addFromUI ("conflevel")
                  .print ();
echo ('rk.print (res)\n');
}
                </programlisting>
		<para
><function
>rk.print()</function
> використовує пакунок R2HTML для створення даних у форматі HTML. Ще однією корисною функцією є <function
>rk.results()</function
>: ця функція також здатна виводити різні типи таблиць результатів. Втім, якщо ви не певні, просто скористайтеся <function
>rk.print()</function
>, — цього достатньо. Клас JS <function
>Header</function
> є допоміжним класом на рівні JS для створення викликів до <function
>rk.header()</function
> (достатньо зазирнути до створеного коду &R;). Іноді виникає потреба у безпосередньому виклику <function
>echo ('rk.header (...)')</function
> для виведення заголовка до ваших результатів. </para>
		<para
>Зауважте, що на внутрішньому рівні виведені дані є на цей момент часу простим документом &HTML;. Тому у вас може виникнути бажання додати нетиповий код &HTML; за допомогою <function
>rk.cat.output()</function
>. Хоча це і працюватиме, будь ласка, не робіть так. Формат виведення може бути змінено (наприклад на ODF) у майбутніх версіях, отже варто не додавати специфічного для &HTML; коду. Краще не ускладнювати речі і користуватися <function
>rk.header()</function
>, <function
>rk.print()</function
>, <function
>rk.results()</function
> і, якщо потрібно, <function
>rk.print.literal()</function
>. Якщо усі ці функції не задовольняють ваші потреби у форматуванні, повідомте про це розробникам &rkward; за допомогою списку листування розробників. </para>
		<para
>Вітаємо! Ви створили ваш перший додаток. За допомогою наступних глав ви зможете удосконалити і розширити ваші знання. </para>
	</sect2>
</sect1>

<sect1 id="jsconventions">
<title
>Угоди, правила і основа</title>
	<para
>Існує багато способів написання коду &R; для виконання певного завдання, і ще більше існує способів створити цей код &R; за допомогою JS. Як саме ви це зробите — це ваша справа. Втім, існує певний набір правил, які ви маєте виконувати, і базові відомості, які ви маєте розуміти. </para>

	<sect2 id="policylocal">
	<title
>Опис середовища <function
>local()</function
></title>
		<para
>Майже завжди вам доведеться створювати один або декілька тимчасових об’єктів &R; у коді, який створюватиметься вашим додатком. Зазвичай, поява цих об’єктів у робочому просторі користувача і потенційний перезапис змінних користувача є небажаним. Отже, увесь створений додатком код запускається у середовищі <function
>local()</function
> (див. сторінку довідки &R; щодо функції <function
>local()</function
>). Це означає, що усі створені вами змінні є тимчасовими і постійно не зберігатимуться. </para>
		<para
>Якщо користувач явним чином попросить зберегти змінну, вам доведеться надати об’єктові значення за допомогою виразу <function
>.GlobalEnv$objectname &lt;- значення</function
>. Загалом, не використовуйте оператор <function
>&lt;&lt;-</function
>. Ви не обов’язково надає значення у .GlobalEnv. </para>
		<para
>Однією з важливих проблем є використання <function
>eval()</function
>. Вам варто пам’ятати, що типово eval використовуватиме для обчислень поточне середовище, тобто локальне середовище (local). У більшості випадків усе працюватиме як слід, але не завжди. Таким чином, якщо вам потрібно скористатися <function
>eval()</function
>, вам, ймовірно, варто вказати параметр <parameter
>envir</parameter
>: <function
>eval(..., envir=globalenv()</function
>). </para>
	</sect2>

	<sect2 id="policyformatting">
	<title
>Форматування коду</title>
		<para
>Найголовніше, щоб ваш код мовою &R; працював як слід, але також важливо, щоб його було просто читати. Тому, будь ласка, не забувайте про форматування. Ось декілька правил: </para>
		<para
>Звичайні інструкції верхнього рівня у &R; вирівнюються ліворуч. </para>
		<para
>Інструкції підлеглого блоку має бути записано із відступом у одну табуляцію (див. наведений нижче приклад). </para>
		<para
>Якщо ви виконуєте дуже складні обчислення, додавайте до них коментарі, особливо для позначення певних логічних частин коду. Зауважте, що існує спеціальна функція <command
>comment()</command
> для додавання придатних до перекладу коментарів у створений код. </para>
		<para
>Наприклад, створений код може виглядати так, як у наведеному нижче фрагменті. Той самий код без відступів і коментарів буде доволі важко читати, хоча він і не дуже складний: </para>
		<programlisting
># спочатку визначаємо хилитання і обертання
my.wobble &lt;- wobble (x, y)
my.rotation &lt;- wobble.rotation (my.wobble, z)

# метод ухилення має бути вибрано відповідно до обертання
if (my.rotation &gt; wobble.rotation.limit (x)) {
        method &lt;- "foo"
        result &lt;- boggle.foo (my.wobble, my.rotation)
} else {
        method &lt;- "bar"
        result &lt;- boggle.bar (my.wobble, my.rotation)
}
                </programlisting>
	</sect2>

	<sect2 id="policysimplicity">
	<title
>Робота зі складними параметрами</title>
		<para
>Багато додатків можуть виконувати декілька функцій. Наприклад, додаток <quote
>Описова статистика</quote
> може обчислювати середнє, діапазон, суму, добуток, медіану, довжину вибірки тощо. Втім, типово, користувачу буде потрібна лише частина з результатів обчислень. У цьому випадку, будь ласка, намагайтеся робити створений код &R; якомога простішим. Код має містити лише ті команди, які відповідають вибраним вами параметрам. Щоб досягти цього, скористайтеся прикладом типового взірця компонування (у JS; тут domean, domedian і dosd будуть елементами &lt;checkbox&gt;): </para>
		<programlisting
>function calculate () {
        echo ('x &lt;- &lt;' + getString ("x") + ')\n');
        echo ('results &lt;- list ()\n');

        if (getBoolean ("domean.state")) echo ("results$" + i18n ("Mean value") + " &lt;- mean (x)\n");
        if (getBoolean ("domedian.state")) echo ("results$" + i18n ("Median") + " &lt;- median (x)\n");
        if (getBoolean ("dosd.state")) echo ("results$" + i18n ("Standard deviation") + " &lt;- sd (x)\n");
        //...
}
                </programlisting>
	</sect2>
</sect1>

<sect1 id="jstips">
<title
>Підказки і рецепти</title>
	<para
>Ось декілька різноманітних прийомів, які можуть зробити написання додатків трохи менш нудною справою: </para>
	<para
>Якщо вам потрібне значення параметра графічного інтерфейсу у декількох місцях коду вашого додатка, варто надати його значення якійсь змінній у JS, і використовувати її замість повторного отримання значення за допомогою <function
>getString()/getBoolean()/getList()</function
>. Такий спосіб є швидшим, зручнішим для читання та таким, що заощаджує час на набирання коду: </para>
	<programlisting
>function calculate () {
        var narm = "";        // na.rm=FALSE is the default in all functions below
        if (getBoolean ("remove_nas")) {
                $narm = ", na.rm=TRUE";
        }
        // ...
        echo ("results$foo &lt;- foo (x" + narm + ")\n");
        echo ("results$bar &lt;- bar (x" + narm + ")\n");
        echo ("results$foobar &lt;- foobar (x" + narm "\n");
        // ...
}
        </programlisting>
	<para
>Проста допоміжна функція <function
>makeOption()</function
> допоможе вам уникнути додавання параметрів із типовими значеннями: </para>
	<programlisting
>function calculate () {
        var options
        //...
        // Нічого не робити, якщо VALUE дорівнює 0.95 (типове значення). Інакше додати ', conf.int=VALUE' до параметрів.
        options += makeOption ("conf.int", getString ("confint"), "0.95");
        //...
}
        </programlisting>
</sect1>
</chapter>

<chapter id="pluginhelp">
	<title
>Створення сторінки довідки</title>
	<para
>Оскільки додаток, загалом, вже працює як слід, наспів час створити для нього сторінку довідки. Хоча, зазвичай, вам не варто пояснювати кожен раз усе з початку, було б добре надати певні відомості щодо деяких з параметрів та посилання на пов’язані додатки і функції &R;. </para>
	<tip>
		<para
>Після прочитання цієї глави зверніться до <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>. У ньому реалізовано декілька функцій &R; для створення більшості теґів XML &rkward;. Пакунок також допоможе вам створити базовий каркас файлів довідки на основі наявних файлів додатків XML. </para>
	</tip>
	<para
>Вам варто додати це до коду XML вашого додатка (якщо ви цього ще не зробили, зробіть це зараз): </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;help file="назва_файла.rkh" /&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>Де, очевидно, вам слід замінити вираз <filename
>назва_файла</filename
> на відповідну назву. Тепер, створимо цей файл <literal role="extension"
>.rkh</literal
>. Ось приклад із наведеними в ньому описами: </para>
	<programlisting
>&lt;!DOCTYPE rkhelp&gt;
&lt;document&gt;
        &lt;summary&gt;
У цьому розділі мають бути основні відомості щодо того, які завдання виконує додаток.
Цей розділ завжди буде показано на самому початку сторінки довідки.
        &lt;/summary&gt;

        &lt;usage&gt;
У розділі usage можуть міститися трохи практичніші відомості. Втім, тут не обов’язково
пояснювати докладно усі параметри (це слід залишити для розділу «settings»).

Щоб розпочати новий абзац, вставте порожній рядок, як у нашому прикладі.
Цей рядок, навпаки, розташовуватиметься у тому самому абзаці.

В усіх розділах ви можете використовувати простий код HTML, зокрема для &lt;b&gt;жирного&lt;/b&gt; або
&lt;i&gt;курсивного&lt;/i&gt; тексту. Втім, не слід зловживати таким форматуванням.

Розділ usage завжди є другим розділом, який буде показано на сторінці довідки.
        &lt;/usage&gt;

        &lt;section id="sectionid" title="Типовий розділ" short_title="Типовий"&gt;
Якщо потрібно, ви можете додавати розділи між розділом usage та settings.
Втім, зазвичай, у вас не повинно виникнути потреби у таких розділах під час документування додатків. Атрибут «id»
дає точку прив’язки для переходу до цього розділу з меню навігації. Атрибут «short_title»
визначає скорочений заголовок для панелі навігації. Цей атрибут є необов’язковим, типово,
буде використано основний «title» для заголовка розділу і для посилання на панелі
навігації.

У будь-якому розділі ви можете вставити посилання на подальшу інформацію. Для цього вставте такий код:

&lt;link href="URL"&gt;назва посилання&lt;/link&gt;

Де URL може бути зовнішнім посиланням, наприклад http://rkward.kde.org .
На сторінках довідки передбачено декілька спеціалізованих варіантів адрес:

&lt;link href="rkward://page/шлях/ід_сторінки"/&gt;

Такі адреси надають змогу посилатися на сторінки довідки з rkward (не сторінки додатків).

&lt;link href="rkward://компонент/[простір_назв/]ід_компонента"/&gt;

Так можна посилатися на сторінки довідки іншого додатка. Частину [простір_назв/] можна пропустити
(у цьому випадку використовуватиметься стандартний простір назв rkward, приклад:
&lt;link href="rkward://component/import_spss"/&gt; і
&lt;link href="rkward://component/rkward/import_spss"/&gt; є еквівалентними).
Ідентифікатор ід_компонента є тим самим, який було визначено у <link linkend="pluginmap"
>&pluginmap;</link
>.

&lt;link href="rkward://rhelp/rfunction"/&gt;

Посилання на довідку з R щодо «rfunction».

Зауважте, що назви посилань для цього типу посилань буде створено автоматично.
        &lt;/section&gt;

        &lt;settings&gt;
                &lt;caption id="ід_вкладки_або_фрейма"/&gt;
                &lt;setting id="ід_елемента"&gt;
Опис графічного елемента, що ідентифікується вказаним ідентифікатором
                &lt;/setting&gt;
                &lt;setting id="ід_елементаb" title="опис"&gt;
Зазвичай, заголовок (title) елемента графічного інтерфейсу буде видобуто з
<link linkend="mainxml"
>визначення XML додатка</link
> автоматично. Втім,
для деяких елементів графічного інтерфейсу цього опису може бути недостатньо для надійної ідентифікації.
У цьому випадку ви можете додати заголовок явним чином за допомогою атрибута «title».
                &lt;/setting&gt;
                &lt;setting id="ід_елементаc"&gt;
Опис графічного елемента, який позначено ідентифікатором «ід_елементаc»
                &lt;/setting&gt;
                [...]
        &lt;/settings&gt;

        &lt;related&gt;
Типово, розділ related просто містить посилання, ось так:

&lt;ul&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/mean"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/median"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://component/related_component"/&gt;&lt;/li&gt;
&lt;/ul&gt;
        &lt;/related&gt;

        &lt;technical&gt;
У розділі technical (необов’язковий, завжди останній) можуть міститися деякі подробиці
щодо реалізації додатка, які можуть бути корисними лише розробникам RKWard. Цей розділ
корисний для додатків, які було розроблено для вбудовування у багато інших додатків.
Тут можуть бути подробиці щодо параметрів, доступних для налаштовування вбудованого додатка,
і того, які розділи коду містять відповідний код R.
        &lt;/technical&gt;
&lt;/document&gt;
        </programlisting>
</chapter>


<chapter id="logic">
<title
>Логічна взаємодія між елементами графічного інтерфейсу</title>
<sect1 id="sect_GUI_logic"
><title
>Логіка графічного інтерфейсу</title>
	<para
>Усі базові поняття щодо створення додатків до &rkward; було описано у попередніх розділах. Цих базових понять достатньо для багатьох, якщо не більшості, випадків. Втім, іноді вам можуть знадобитися додаткові можливості з керування графічним інтерфейсом вашого додатка. </para>
	<para
>Наприклад, припустімо, що ви хочете розширити приклад з t-перевіркою, використаний у цій документації, так, щоб можна було виконувати два завдання: порівняння змінної з іншою змінною (як показано) і порівняння змінної зі сталим значенням. Одним зі способом це реалізувати є додавання пунктів варіантів для перемикання між двома режимами та додавання пункту лічильника для введення сталого значення, з яким слід порівнювати змінну. Розгляньмо цей спрощений приклад: </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
&lt;document&gt;
        &lt;code file="code.js"/&gt;

        &lt;dialog label="T-Test"&gt;
                &lt;row&gt;
                        &lt;varselector id="vars"/&gt;
                        &lt;column&gt;
                                &lt;varslot id="x" types="number" source="vars" required="true" label="compare"/&gt;
                                &lt;radio id="mode" label="Compare against"&gt;
                                        &lt;option value="variable" checked="true" label="another variable (select below)"/&gt;
                                        &lt;option value="constant" label="a constant value (set below)"/&gt;
                                &lt;/radio&gt;
                                &lt;varslot id="y" types="number" source="vars" required="true" label="variable" i18n_context="Noun; a variable"/&gt;
                                &lt;spinbox id="constant" initial="0" label="constant" i18n_context="Noun; a constant"/&gt;
                        &lt;/column&gt;
                &lt;/row&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Здається усе добре, але з таким графічним інтерфейсом є декілька проблем. По-перше, і varslot, і spinbox буде завжди показано, хоча насправді буде використано лише один з цих елементів. Гірше того, varslot завжди потребуватиме коректного вибору, навіть якщо порівняння буде виконуватися лише зі сталою. Очевидно, якщо ми створюємо багатоцільовий графічний інтерфейс, подібний до цього, нам потрібна більша гнучкість. Введіть до розділу <command
>&lt;logic&gt;</command
> (вставлено на той самий рівень, що і <command
>&lt;code&gt;</command
>, <command
>&lt;dialog&gt;</command
> або <command
>&lt;wizard&gt;</command
>): </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;

        &lt;logic&gt;
                &lt;convert id="varmode" mode="equals" sources="mode.string" standard="variable" /&gt;

                &lt;connect client="y.visible" governor="varmode" /&gt;
                &lt;connect client="constant.visible" governor="varmode.not" /&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>Першим рядком у розділі logic є теґ <command
>&lt;convert&gt;</command
>. На базовому рівні, це створює нову булеву властивість (увімкнено або вимкнено, так або ні), якою можна згодом скористатися. Ця властивість (<replaceable
>"varmode"</replaceable
>) матиме значення «так», якщо буде вибрано верхній варіант, і значення «ні», якщо буде вибрано нижній варіант. Як же це досягається? </para>
	<para
>По-перше, у <parameter
>sources</parameter
> наведено список властивостей джерела, на якими слід працювати (у цьому випадку лише одну; декілька можна вказати так: <parameter
>sources=</parameter
><replaceable
>"mode.string;щось_іще"</replaceable
>, тоді <replaceable
>"varmode"</replaceable
> матиме значення true, якщо і <replaceable
>"mode.string"</replaceable
> і <replaceable
>"щось_іще"</replaceable
> дорівнюють рядку <replaceable
>"variable"</replaceable
>). Зауважте, що у цьому випадку ми не написали просто <replaceable
>"mode"</replaceable
> (як було у <function
>getString("mode")</function
>), а <replaceable
>"mode.string"</replaceable
>. Насправді, це пов’язано з тим, як працює засіб вибору з варіантів на внутрішньому рівні: він має властивість <quote
>string</quote
>, у якій зберігається її рядкове значення. <function
>getString("mode")</function
> — просто скорочення, яке є еквівалентним до <function
>getString("mode.string")</function
>. Ознайомитися із усіма властивостями різних елементів графічного інтерфейсу можна за допомогою відповідного розділу цього підручника. </para>
	<para
>По-друге, ми встановлюємо режим перетворення <parameter
>mode=</parameter
><replaceable
>"equals"</replaceable
>. Це означає, що ми хочемо перевірити, чи є джерело (чи джерела) рівним певному значенню. Нарешті, standard є значенням, із якими слід виконувати порівняння, отже, за допомогою <parameter
>standard=</parameter
><replaceable
>"variable"</replaceable
> ми перевіряємо, чи є властивість <replaceable
>"mode.string"</replaceable
> рівною рядку <replaceable
>"variable"</replaceable
> (значенню верхнього пункту варіанта). Якщо є, значенням змінної varmode буде true, інакше — false. </para>
	<para
>Тепер до справи: ми з’єднуємо (<command
>&lt;connect&gt;</command
>) змінну <replaceable
>"varmode"</replaceable
> з властивістю y.visible, яка керує видимістю varslot-а <replaceable
>"y"</replaceable
>. Зауважте, що будь-який елемент, який стає невидимим, неявним чином стає необов’язковим. Отже, якщо позначено верхній варіант, varslot <replaceable
>"y"</replaceable
> буде обов’язковим і видимим. Якщо ж позначено інший варіант, він стане необов’язковим і невидимим. </para>
	<para
>Для поля лічильника нам потрібне зовсім протилежне. На щастя, нам не обов’язково додавати ще одне <command
>&lt;convert&gt;</command
> для цього: булеві змінні легко перетворювати на протилежні за допомогою додавання модифікатора <replaceable
>"not"</replaceable
>, отже, ми з’єднаємо <replaceable
>"varmode.not"</replaceable
> із властивістю видимості поля лічильника. У результаті або буде показаним і обов’язковим varslot, <emphasis
>або</emphasis
> буде показаним і обов’язковим поле лічильника (spinbox). Усе залежатиме від вибраного варіанта. Графічний інтерфейс змінюватиметься автоматично у відповідь на дії користувача. Спробуйте поекспериментувати з нашим прикладом. </para>
	<para
>Повний список властивостей можна знайти у <link linkend="reference"
>довідковій частині підручника</link
>. Втім, варто обговорити ще одну властивість, яка є специфічною для усіх елементів графічного інтерфейсу: <quote
>enabled</quote
>. Вона не така дієва, як <quote
>visible</quote
>. Вона не керує показом або приховуванням елемента графічного інтерфейсу, а лише вмикає або вимикає його. Вимкнені елементи типово буде показано сірим кольором, вони не реагуватимуть на дії користувача. </para>
	<note>
		<para
>Окрім <command
>&lt;convert&gt;</command
> і <command
>&lt;connect&gt;</command
>, у розділі <command
>&lt;logic&gt;</command
> можна використати ще декілька елементів. Наприклад, розгалуження за умовою може бути реалізовано за допомогою елемента <command
>&lt;switch&gt;</command
>. Докладніший опис можна знайти у <link linkend="logicelements"
>довідці щодо елементів логіки</link
>.</para>
	</note>
</sect1>
<sect1 id="logic_scripted">
<title
>Керування логікою графічного інтерфейсу за допомогою скриптів</title>
	<para
>Хоча з’єднання властивостей, описаного вище, часто достатньо, іноді гнучкішим і зручнішим способом керування логікою графічного інтерфейсу є використання скриптів JS. У цей спосіб наведений вище приклад може бути переписано так: </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;
'
        &lt;logic&gt;
                &lt;script&gt;&lt;![CDATA[
                        // У цьому блоці використано код ECMAScript
                        // інструкція вищого рівня викликається лише один раз
                        gui.addChangeCommand ("mode.string", "modeChanged ()");

                        // ця функція викликається кожного разу, коли змінюється режим «mode»
                        modeChanged = function () {
                                var varmode = (gui.getString ("mode.string") == "variable");
                                gui.setValue ("y.enabled", varmode);
                                gui.setValue ("constant.enabled", !varmode);
                        }
                ]]&gt;&lt;/script&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>Перший рядок коду повідомляє &rkward;, що слід викликати <function
>modeChanged()</function
>, щоб визначити, чи змінилося значення пункту варіанта <parameter
>id=</parameter
><replaceable
>"mode"</replaceable
>. Всередині цієї функції ми визначаємо допоміжну змінну <replaceable
>"varmode"</replaceable
>, яка має значення true, якщо mode має значення <replaceable
>"variable"</replaceable
> як <replaceable
>"constant"</replaceable
>. Далі, ми використовуємо <function
>gui.setValue()</function
> для встановлення властивостей <quote
>enabled</quote
> <replaceable
>"y"</replaceable
> і <replaceable
>"constant"</replaceable
> у той самий спосіб, як ми робили це з інструкціями <command
>&lt;connect&gt;</command
> раніше. </para>
	<para
>Керування логікою графічного інтерфейсу за допомогою скриптів корисне зокрема тоді, коли ви хочете змінити доступні параметри відповідно до типу об’єкта, який вибрано користувачем. Із списком доступних функцій можна ознайомитися у <link linkend="guilogic_functions"
>довідковому розділі</link
>. </para>
	<para
>Зауважте, що підхід до керування графічним інтерфейсом за допомогою скриптів може бути поєднано із інструкціями <command
>&lt;connect&gt;</command
> і <command
>&lt;convert&gt;</command
>, якщо це потрібно. Крім того, зауважте, що теґ <command
>&lt;script&gt;</command
> надає змогу вказати назву файла скрипту на додачу або як альтернативу до вбудовування скриптового коду до файла інтерфейсу. Втім, типово, продемонстроване вище вбудовування коду є зручнішим. </para>
</sect1>
</chapter>

<chapter id="embedding">
<title
>Вбудовування додатків до додатків</title>
<sect1 id="sect_embedding"
><title
>Випадки застосування вбудовування</title>
	<para
>Під час написання додатків часто виникає ситуація, коли ви створюється декілька додатків, які відрізняються лише у певних аспектах, але мають багато спільного. Наприклад, для креслення є багато загальних параметрів &R;, якими можна скористатися для більшості типів креслень. То чи треба створювати графічний інтерфейс і шаблон JS для таких додатків знову і знову? </para>
	<para
>Звичайно ж, повторення однакових дій є дуже марудним. На щастя, робити це не треба. Достатньо створити загальні функції один раз, а потім вбудувати їх до декількох схожих додатків. Фактично, можна вбудувати будь-який додаток до будь-якого іншого додатка, навіть якщо початковий автор вбудовуваного додатка ніколи не думав про те, що його додаток будуть вбудовувати до іншого. </para>
</sect1>
<sect1 id="embedding_dialog">
<title
>Вбудовування до діалогового вікна</title>
	<para
>Гаразд, досить слів. Як це все працює? Дуже просто: достатньо скористатися теґом <command
>&lt;embed&gt;</command
>. Ось позбавлений усього зайвого приклад: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
                &lt;tab label="Plot Options" i18n_context="Options concerning the plot"&gt;
                        &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;/tab&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
        &lt;/tabbook&gt;
&lt;/dialog&gt;
        </programlisting>
	<para
>Тут увесь графічний інтерфейс або додаток параметрів креслення (окрім, звичайно ж, стандартних елементів, подібних до кнопки <guibutton
>Submit</guibutton
>) вбудовано до нашого додатка (спробуйте!). </para>
	<para
>Як можна бачити, синтаксис теґу <command
>&lt;embed&gt;</command
> доволі простий. У ньому використовується <parameter
>id</parameter
>, як і у більшості елементів. Параметр component визначає, який додаток слід вбудувати, його значення можна знайти у файлі &pluginmap; (<replaceable
>"rkward::plot_options"</replaceable
> є результатом склеювання простору назв <quote
>rkward</quote
>, роздільника <quote
>::</quote
> і назви компонента <quote
>plot_options</quote
>). </para>
</sect1>
<sect1 id="embedding_code">
<title
>Створення коду при вбудовуванні</title>
	<para
>Поки усе зрозуміло, але як щодо створеного коду? Як поєднуватиметься код основного і вбудованого додатка? Достатньо просто написати у коді JS основного додатка щось таке: </para>
	<programlisting
>function printout () {
        // ...
        echo ("myplotfunction ([...]" + getString ("plotoptions.code.printout"); + ")\n");
        // ...
}
        </programlisting>
	<para
>Отже, по суті, ми отримуємо код, створений вбудованим додатком, у той самий спосіб, у який отримуємо будь-які інші параметри графічного інтерфейсу. Тут рядок <replaceable
>"plotoptions.code.printout"</replaceable
> можна розгорнути так: <quote
>Розділ printout створеного коду елемента із <parameter
>id</parameter
> plotoptions</quote
> (plotoptions — ідентифікатор, який ми надали теґу <command
>&lt;embed&gt;</command
> вище). І так, якщо вам потрібні додаткові важелі керування, ви навіть можете отримати значення окремих елементів графічного інтерфейсу у вбудованому додатку (але не навпаки, оскільки вбудований додаток нічого не знає про своє середовище). </para>
</sect1>
<sect1 id="embedding_wizard">
<title
>Вбудовування до майстра</title>
	<para
>Якщо у вашому додатку передбачено графічний інтерфейс майстра, вбудовування, в основному, працює так само. Загалом, вам слід зробити так: </para>
	<programlisting
>&lt;wizard [...]&gt;
                [...]
                &lt;page id="page12"&gt;
                        [...]
                &lt;/page&gt;
                &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;page id="page13"&gt;
                        [...]
                &lt;/page&gt;
                [...]
        &lt;/wizard&gt;
        </programlisting>
	<para
>Якщо вбудований додаток надає інтерфейс майстра, його сторінки буде вставлено безпосередньо між <replaceable
>"page12"</replaceable
> і <replaceable
>"page13"</replaceable
> у вашому додатку. Якщо вбудований додаток використовує лише інтерфейс діалогового вікна, буде додано дону нову сторінку між вашими сторінками <replaceable
>"page12"</replaceable
> і <replaceable
>"page13"</replaceable
>. З точки зору користувача, вбудовування буде непомітним. </para>
</sect1>
<sect1 id="embedding_as_button">
<title
>Не таке вбудоване вбудовування: кнопка «Інші параметри»</title>
	<para
>Хоча вбудовування виглядає потужним механізмом, вам не варто ним зловживати. Забагато функцій у файлі графічного інтерфейсу ускладнить пошук відповідних параметрів. Звичайно ж, іноді може виникнути потреба у вбудовуванні значної кількості параметрів роботи додатка (зокрема усіх параметрів функції <function
>plot()</function
>), але оскільки вони, зазвичай, є лише параметрами необов’язкового налаштовування, не слід віддавати їм якесь визначне становище у графічному інтерфейсі. </para>
	<para
>Альтернативно, можна вбудувати ці параметри <quote
>як кнопку</quote
>: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                [...]
                &lt;tab label="Options"&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Specify plotting options"/&gt;
                &lt;/tab&gt;
                [...]
        &lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
	<para
>У цьому випадку до вашого додатка буде доданого одну кнопку із міткою <guibutton
>Specify plotting options</guibutton
>. Якщо користувач натисне цю кнопку, буде відкрито діалогове вікно із усіма параметрами вбудованого додатка. Хоча цей вбудований графічний інтерфейс і не видно більшу частину часу, ви можете отримати його параметри у той самий, <link linkend="embedding_code"
>описаний вище</link
> спосіб. </para>
	<para>
		<caution>
			<para
><quote
>Кнопковий</quote
> підхід варто використовувати лише для додатків, які ніколи не працюють некоректним чином (через пропущені або помилкові значення параметрів). Якщо це не так, користувач не зможе надіслати код на виконання, але не зможе дізнатися нічого про причину, оскільки її буде приховано під нашою кнопкою. </para
>	
		</caution>
	</para>
</sect1>
<sect1 id="embedding_incomplete">
<title
>Вбудовування або визначення незавершених додатків</title>
	<para
>Деякі додатки — фактично, додаток plot_options, використаний як приклад вище, є одним з них — не є самодостатніми. У них просто немає елементів графічного інтерфейсу для вибору деяких важливих значень. Їх призначено лише для вбудовування до інших додатків. </para>
	<para
>Наскільки незавершеним є додаток plot_options? Гаразд, для визначення своєї поведінки йому потрібні назви об’єктів або вирази для осей x і y (насправді, для його роботи достатньо одного з цих об’єктів чи виразів, але хоч один має бути задано, щоб додаток зміг працювати). Втім, у нього немає механізму для вибору цих об’єктів або введення їх у якийсь інший спосіб. То як же він дізнається про ці об’єкти? </para>
	<para
>У розділі логіки роботи додатка plot_options є ще два рядки, які ми ще не обговорили: </para>
	<programlisting
>&lt;logic&gt;
                &lt;external id="xvar" /&gt;
                &lt;external id="yvar" /&gt;

                [...]
        &lt;/logic&gt;
        </programlisting>
	<para
>Це визначає дві додаткові властивості у додатку plot_options. Єдиною їхньою метою є з’єднування з певними (ще невідомими) властивостями додатка, до якого відбувається вбудовування. У додатку plot_options ці дві властивості просто використовуються як будь-які інші, наприклад, у шаблоні JS plot_options є виклики <function
>getString("xvar")</function
>. </para>
	<para
>Далі, для незавершеного додатка не можна наперед дізнатися, до якого додатка відбуватиметься вбудовування і які параметри викликатиме основний додаток. Отже, нам доведеться додати два рядки у розділ logic додатка, до якого ми вбудовуємо інший додаток: </para>
	<programlisting
>&lt;logic&gt;
                [...]

                &lt;connect client="plotoptions.xvar" governor="xvarslot.available" /&gt;
                &lt;connect client="plotoptions.yvar" governor="yvarslot.available" /&gt;
        &lt;/logic&gt;
        </programlisting>
	<para
>Нічого принципово нового, ми вже розбирали інструкції <command
>&lt;connect&gt;</command
> у <link linkend="logic"
>розділі щодо логіки графічного інтерфейсу</link
>. Ми просто з’єднали значення у двох varlot-ах (які у нашому прикладі називаються <replaceable
>"xvarslot"</replaceable
> і <replaceable
>"yvarslot"</replaceable
>) із зовнішніми властивостями вбудованого додатка. Ось і усе. Усі інші дії буде виконано автоматично. </para>
</sect1>
</chapter>

<chapter id="plugin_series">
<title
>Робота з багатьма подібними додатками</title>
<sect1 id="sect_similar_plugins"
><title
>Огляд різних підходів</title>
	<para
>Іноді, виникає потреба у розробці додатків для реалізації послідовності подібних функціональних можливостей. Прикладом може слугувати побудова графіків розподілів. При цьому використовується подібний програмний код і, звичайно ж, графічні інтерфейси таких додатків мають бути подібними. Крім того, подібними будуть і значні частини файлів довідки додатків. Різними у додатках будуть лише декілька параметрів. </para>
	<para
>Найпримітивнішим підходом до вирішення цієї проблеми є розробка одного додатка з наступним простим копіюванням його вмісту, файлів <literal role="extension"
>.js</literal
>,<literal role="extension"
>.xml</literal
> та <literal role="extension"
>.rkh</literal
>, до інших додатків та внесенням у скопійований текст змін. Втім, що трапиться, якщо згодом ви знайдете просту друкарську помилку, яку було скопійовано і вставлено до усіх додатків? Що, якщо вам захочеться додати підтримку нової можливості? Вам доведеться вносити зміни до усіх ваших додатків, один за одним. Це марудна і нудна справа. </para>
	<para
>Другий підхід полягає у використанні <link linkend="embedding"
>вбудовування</link
>. Втім, іноді і вбудовування не є повним вирішенням проблеми, яку ми розглядаємо, здебільшого через те, що вбудовувані <quote
>фрагменти</quote
> є надто великими для використання, а їхнє додавання обмежує можливості компонування коду. Для таких випадків передбачено можливості <link linkend="include_js"
>включення файлів <literal role="extension"
>.js</literal
></link
>, <link linkend="include_xml"
>включення файлів <literal role="extension"
>.xml</literal
></link
> та <link linkend="snippets"
>фрагменти</link
> (втім, варто ознайомитися із <link linkend="include_snippets_vs_embedding"
>думками щодо того, коли слід надавати перевагу вбудовуванню</link
>). </para>
	<para
>Трохи попереджень, перш ніж ви розпочнете читання цього розділу: ці концепції можуть спростити створення серії подібних додатків та поліпшити можливості із супроводу та читання коду таких додатків. Втім, зловживання ними може легко спричинити зворотний ефект. Використовуйте ці концепції виважено. </para>
</sect1>
<sect1 id="include_js">
<title
>Використання інструкції include JS</title>
	<para
>У додатках до &rkward; ви можете дуже просто включити один файл скрипту до іншого. Цінність цього стає очевидною, коли деякі з розділів вашого коду JS є однаковими у всіх додатках. Ви можете просто визначити ці розділи у окремому файлі <literal role="extension"
>.js</literal
> і включити цей файл до усіх файлів <literal role="extension"
>.js</literal
> додатка. Приклад: </para>
	<programlisting
>// цей файл називається "common_functions.js"

function doCommonStuff () {
        // ймовірно, отримуємо деякі параметри тощо.
        // ...
        comment ("Це код R, який використовується у декількох різних додатках\n");
        // ...
}
        </programlisting>
	<programlisting
>// це один з ваших типових файлів <literal role="extension"
>.js</literal
> додатків

// включаємо загальні функції
include ("common_functions.js");

function calculate () {
        // виконуємо якісь дії
        // ...

        // вставляємо загальний код
        doCommonStuff ();
}
        </programlisting>
	<para
>Зауважте, що іноді ліпше зробити навпаки, і визначити <quote
>каркас</quote
> функцій <function
>preprocess()</function
>, <function
>calculate()</function
> і <function
>printout()</function
> у одному файлі, а потім викликати цей файл у тих частинах, які є різними для додатків. Приклад: </para>
	<programlisting
>// це файл, який називається «common_functions.js»

function calculate () {
        // виконуємо якісь дії, які є спільними для усіх додатків
        // ...

        // додаємо щось, що є різним для додатків
        getSpecifics ();

        // ...
}
        </programlisting>
	<programlisting
>// це один із ваших звичайних файлів <literal role="extension"
>.js</literal
> додатка

// включити загальні функції
include ("common_functions.js");

// зауваження: тут не визначається функція calculate().
// цю функцію визначено у common_functions.js.

function getSpecifics () {
        // виведення якогось коду R
}
        </programlisting>
	<para
>Однією з проблем цього підходу, які вам слід мати на увазі, є область видимості змінних. Щоб дізнатися про область видимості більше, ознайомтеся із підручником з JS. </para>
	<para
>Ця методика широко використовується у додатках для малювання графіків розподілів та малюванні розподілів і ЦГТ, отже вам варто ознайомитися з кодом цих додатків, якщо ви шукаєте приклади. </para>
</sect1>

<sect1 id="include_xml">
<title
>Включення файлів <literal role="extension"
>.xml</literal
></title>
	<para
>Майже та сама можливість включення існує і для файлів <literal role="extension"
>.xml</literal
>, &pluginmap; і <literal role="extension"
>.rkh</literal
>. У будь-якому місці цих файлів ви можете розташувати теґ <command
>&lt;include&gt;</command
>, як це показано нижче. У результаті увесь вміст включеного файла XML (якщо бути точним, усе у тезі <command
>&lt;document&gt;</command
> цього файла) буде буквально вставлено у відповідну позицію файла. Зауважте, що включати у такий спосіб можна лише інший файл XML. </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;include file="another_xml_file.xml"/&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>Атрибут <parameter
>file</parameter
> визначає назву файла відносно каталогу, у якому зберігається поточний файл. </para>
</sect1>

<sect1 id="snippets">
<title
>Використання &lt;snippets&gt;</title>
	<para
>Хоча включення файлів, як це показано у <link linkend="include_xml"
>попередньому розділі</link
> є достатньо потужним інструментом, найкориснішим він стає, якщо його поєднати з фрагментами, <command
>&lt;snippets&gt;</command
>. Фрагменти — малі шматки коду, які ви можете вставити у іншу частину файла. Найкращою ілюстрацією буде приклад: </para>
	<programlisting
>&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;frame&gt;
                                &lt;text&gt;
                This will be inserted at two places in the GUI
                                &lt;/text&gt;
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;
        &lt;dialog label="test"&gt;
                &lt;column&gt;
                        &lt;insert snippet="note"/&gt;
                        [...]
                        &lt;insert snippet="note"/&gt;
                &lt;/column&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Отже, ви визначаєте фрагмент коду у одному місці на початку файла XML, а потім використовуєте <command
>&lt;insert&gt;</command
> для вставлення коду туди, куди ви хочете його вставити. </para>
	<para
>Хоча цей приклад і не є таким уже надкорисним сам собою, можна уявити його у поєднанні з включенням за допомогою <command
>&lt;include&gt;</command
> файла <literal role="extension"
>.xml</literal
>. Зауважте, що ви також можете розташувати фрагменти для файла <literal role="extension"
>.rkh</literal
> у тому самому файлі. Ви просто вкажете його за допомогою <command
>&lt;include&gt;</command
> і вставите відповідний фрагмент за допомогою <command
>&lt;insert&gt;</command
>: </para>
	<programlisting
>&lt;!-- Це файл, який називається «common_snippets.xml» --&gt;
&lt;document&gt;
        &lt;snippet id="common_options"&gt;
                &lt;spinbox id="something" [...]/&gt;
                [...]
        &lt;/snippet&gt;
        &lt;snippet id="common_note"&gt;
                &lt;text&gt;Важлива нотатка для цього типу додатків&lt;/text&gt;
        &lt;/snippet&gt;

        &lt;snippet id="common_help"&gt;
                &lt;setting id="something"&gt;Виконує якусь дію&lt;/setting&gt;
                [...]
        &lt;/snippet&gt;
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- Це файл .xml додатка --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;!-- Імпортуємо загальні фрагменти --&gt;
                &lt;include file="common_snippets.xml"/&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test2"&gt;
                &lt;insert snippet="common_note"/&gt;
                &lt;spinbox id="something_plugin_specific" [...] /&gt;
                &lt;insert snippet="common_options"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Подібно до <link linkend="include_js"
>включення до JS</link
>, зворотний підхід часто є навіть ще кориснішим: </para>
	<programlisting
>&lt;!-- Це файл із назвою «common_layout.xml» --&gt;
&lt;document&gt;
        &lt;column&gt;
                &lt;insert snippet="note"&gt;
                [...]
                &lt;insert snippet="plugin_parameters"&gt;
        &lt;/column&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- Це файл .xml додатка --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;text&gt;Нотатка для цього додатка&lt;/text&gt;
                &lt;/snippet&gt;

                &lt;snippet id="plugin_parameters"&gt;
                        &lt;frame label="Специфічні для цього додатка параметри"&gt;
                                [...]
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test3"&gt;
                &lt;include file="common_layout.xml"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Нарешті, можна вставляти фрагменти за допомогою <command
>&lt;insert&gt;</command
> у інші фрагменти, якщо виконуються такі умови: а) буде використано лише один рівень вкладеності і б) розділ <command
>&lt;snippets&gt;</command
> розташовано на початку файла (до вставляння вкладеного фрагмента); причиною цього є те, що обробка інструкцій <command
>&lt;insert&gt;</command
> відбувається у файлі згори вниз. </para>
</sect1>

<sect1 id="include_snippets_vs_embedding">
<title
>&lt;include&gt;, &lt;snippets&gt; і &lt;embed&gt;</title>
	<para
>На перший погляд, теґи <command
>&lt;include&gt;</command
> і <command
>&lt;snippets&gt;</command
> надають можливість зробити те саме, що і <link linkend="embedding"
>вбудовування</link
>: ви можете повторно використати частину коду у різних додатках. Отже, у чому відмінність між цими підходами, і як вибрати з них той, яким слід скористатися? </para>
	<para
>Ключова відмінність між цими концепціями полягає у тому, що придатні до вбудовування додатки є ціліснішими. У них поєднується графічний інтерфейс, код для створення на його основі коду &R; і сторінка довідки. Include та insert, навпаки, можна використовувати дрібнішими частинами, але за рахунок погіршення модульності структури додатків. </para>
	<para
>Додатку, до якого вбудовується інший додаток, типово, не потрібні докладні відомості щодо внутрішньої структури вбудованого додатка. Яскравим прикладом цього є додаток plot_options. Додаткам, до яких його вбудовують не потрібні дані щодо усіх параметрів, які можна змінити, або способу їх надання. Це добре, оскільки інакше зміна додатка plot_options могла б призвести до потреби у коригуванні всіх додатків, до яких його вбудовано (а їх доволі багато). І навпаки, include та insert розкривають усі деталі включення та вставлення, отже усі додатки, у яких використовуються ці інструкції, наприклад, повинні містити точні ідентифікатори і використовувати відповідні типи елементів. </para>
	<para
>Отже, ось просте правило: include та insert є чудовим рішенням, якщо відповідні параметри потрібні лише у доволі обмеженій групі додатків. Вбудовані додатки є ліпшим рішенням, якщо група додатків, до яких планується вбудовування, не є жорстко визначеною, і якщо потрібна модульна структура комплекту додатків. Ще одне просте правило: якщо ви можете розташувати типові фрагменти коду до одного <quote
>фрагмента</quote
>, так і зробіть, і скористайтеся вбудовуванням. Якщо ж для спільних частин доведеться створювати багато невеличких фрагментів коду, скористайтеся <command
>&lt;snippets&gt;</command
>. Ну, і нарешті: якщо усі додатки надають <emphasis
>дуже</emphasis
> подібні функціональні можливості, ймовірно, варто скористатися include та insert. Якщо ж додатки, по суті, мають один або два спільні <quote
>модулі</quote
>, слід користуватися вбудовуванням. </para>
</sect1>
</chapter>

<chapter id="specialized_plugins">
<title
>Концепції, якими можна скористатися у спеціалізованих додатках</title>
<para
>У цій главі наведено відомості щодо певних тем, які є корисними лише для деяких класів додатків. </para>

<sect1 id="specialized_plugins_plots">
	<title
>Додатки для створення графіків</title>
	<para
>Створити креслення з додатка доволі просто. Втім, існує декілька неприємних речей, які слід обійти, та деякі чудові загальні функціональні можливості, про які ви маєте знати. У цьому розділі продемонстровано базові поняття та наведено канонічний приклад, якому вам варто слідувати під час створення додатків для креслення. </para>
	<sect2 id="rk_graph_on">
		<title
>Малювання у вікні виведення результатів</title>
		<para
>Для створення креслення у вікні виведення даних скористайтеся <function
>rk.graph.on()</function
> безпосередньо перед створенням креслення і <function
>rk.graph.off()</function
> одразу після його створення. Це те саме, що, наприклад, викликати <function
>postscript()</function
> і <function
>dev.off()</function
> у звичайному сеансі &R;. </para>
		<para
>Втім, що важливо, вам слід <emphasis
>завжди</emphasis
> викликати <function
>rk.graph.off()</function
> після виклику <function
>rk.graph.on()</function
>. Якщо ви цього не зробите, файл результатів залишиться незавершеним. Щоб переконатися, що <function
>rk.graph.off()</function
> буде насправді викликано, вам слід загорнути <emphasis
>усі</emphasis
> команди &R; між двома викликами у інструкцію <function
>try()</function
>. Ніколи про таке не чули? Не переймайтеся, це просто. Усе, що вам слід зробити, — це дотримуватися взірця у <link linkend="plot_plugin_example"
>прикладі</link
>, який наведено нижче. </para>
	</sect2>
	<sect2 id="preview_plots">
		<title
>Додавання функціональної можливості попереднього перегляду</title>
		<note
><para
>У цьому розділі обговорюється додавання функціональної можливості попереднього перегляду до додатків, які створюють креслення. У підручнику є окремі розділи щодо <link linkend="preview_output"
>попереднього перегляду виведеного тексту (HTML)</link
>, <link linkend="preview_data"
>попереднього перегляду (імпортованих) даних</link
> та <link linkend="preview_custom"
>нетипових попередніх переглядів</link
>. Втім, рекомендуємо вам спершу прочитати цей розділ, оскільки підхід у цілому є схожим в усіх цих випадках.</para
></note>
		<para
>Дуже корисною можливістю усіх додатків для створення креслень і графіків є надання попереднього перегляду із автоматичним оновленням. Для створення такого попереднього перегляду потрібні дві речі: додати пункт з позначкою <command
>&lt;preview&gt;</command
> до вашого <link linkend="mainxml"
>визначення графічного інтерфейсу</link
> і скоригувати <link linkend="jstemplate"
>створений код</link
> для отримання зображення попереднього перегляду. </para>
		<para
>Додавання пункту <command
>&lt;preview&gt;</command
> доволі просте. Достатньо просто розмістити відповідні теґи у описі графічного інтерфейсу. Система сама подбає про створення пристрою для попереднього перегляду, оновлення попереднього перегляду у відповідь на зміни параметрів тощо. Приклад: </para>
		<note
><para
>Починаючи з версії 0.6.5 &rkward; елементи попереднього перегляду, <command
>&lt;preview&gt;</command
>, виокремлюються у діалогових вікнах додатків (не майстрів): вони розташовуються у стовпчику з кнопками, незалежно від того, де їх було визначено у описі графічного інтерфейсу. Втім, варто визначати їх у відповідному місці компонування з міркувань зворотної сумісності. </para
></note>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;dialog [...]&gt;
                        [...]
                        &lt;preview id="preview"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>І це усе, що потрібно для визначення графічного інтерфейсу. </para>
		<para
>Коригування шаблона JS потребує лише трохи більше зусиль. Тут вам потрібно забезпечити створення лише самого креслення і показ його на екранному пристрої, а не спрямовування каналом виведення даних. Тобто, не потрібен друк заголовків, не потрібне <function
>rk.graphics.on()</function
> та подібні виклики. Щоб допомогти вам у цьому, &rkward; викличе функції <function
>preprocess()</function
>, <function
>calculate()</function
> і <function
>printout()</function
> з додатковим параметром, для якого встановлено значення <parameter
>true</parameter
> при створення коду для попереднього перегляду. (Цей параметр буде пропущено при створенні остаточного коду. У javascript обчисленим значенням буде <parameter
>false</parameter
> при використанні в інструкції <function
>if</function
>.)  Див. наведений нижче <link linkend="plot_plugin_example"
>приклад</link
> із типовим взірцем того, який код вам потрібен. </para>
		<para
>Крім того, якщо вам потрібне додаткове керування, ви можете, замість цього, додати до вашого шаблона JS нову функцію із назвою <function
>preview()</function
> і створити код, який потрібен для попереднього перегляду у ній (ймовірно, принаймні частково, знову ж таки, викликом <function
>calculate()</function
> тощо). </para>
	</sect2>
	<sect2 id="plot_options">
		<title
>Загальні параметри креслення</title>
		<para
>Як можна помітити, більшість додатків для креслення у &rkward; надають можливість змінювати широкий діапазон загальних параметрів креслення, наприклад, визначення підписів до осей та полів рисунка. Додати ці параметри до вашого додатка просто. Вони надаються <link linkend="embedding"
>придатним до вбудовування</link
> додатком із назвою <command
>rkward::plot_options</command
>. Вбудовування до інтерфейсу вашого додатка відбувається так: </para>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;logic [...]&gt;
                        &lt;connect client="plotoptions.xvar" governor="x.available"/&gt;
                        &lt;set id="plotoptions.allow_type" to="true"/&gt;
                        &lt;set id="plotoptions.allow_ylim" to="true"/&gt;
                        &lt;set id="plotoptions.allow_xlim" to="false"/&gt;
                        &lt;set id="plotoptions.allow_log" to="false"/&gt;
                        &lt;set id="plotoptions.allow_grid" to="true"/&gt;
                &lt;/logic&gt;
                &lt;dialog [...]&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Plot Options"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>Це додасть до вашого графічного інтерфейсу кнопку для виклику вікна із параметрами креслення. Розділ логіки наведено лише для прикладу. За його допомогою ви можете керувати додатком параметрів креслення. Докладніше про це на сторінці довідки до додатка plot_options (посилання на неї є на сторінці довідки будь-якого додатка, який надає доступ до загальних параметрів). </para>
		<para
>Далі, вам слід забезпечити додавання коду, що відповідає вашим параметрам креслення, до коду, який створюється додатком для креслення. Для цього отримуємо властивості <command
>code.preprocess</command
>, <command
>code.printout</command
> і <command
>code.calculate</command
> з вбудованого додатка параметрів креслення і вставляємо їх до нашого коду так, яке це показано у наведеному нижче <link linkend="plot_plugin_example"
>прикладі</link
>. </para>
	</sect2>
	<sect2 id="plot_plugin_example">
		<title
>Канонічний приклад</title>
		<para
>Ось приклад файла .JS, яким ви можете скористатися як шаблоном, коли ви захочете створити додаток для креслення: </para>
		<programlisting
>function preprocess () {
    // «somepackage» потрібен для створення креслення
    echo ("require (somepackage)\n");
  }
  
  function printout (is_preview) {
    // Якщо «is_preview» має значення false/не визначено, буде створено код повністю, разом із заголовками.
    // Якщо «is_preview» має значення true, буде створено лише основні елементи.

    if (!is_preview) {
      echo ('rk.header (' + i18n ("An example plot") + ')\n\n');
      echo ('rk.graph.on ()\n');
    }
    // Для is_preview==true буде створено лише наведений нижче розділ

    // пам’ятайте: усе між rk.graph.on() і rk.graph.off() слід загортати у інструкцію try():
    echo ('try ({\n');
    // вставте будь-який код зі встановлення параметрів, який має бути запущено до безпосередніх команд створення креслення.
    // Сам код буде створено вбудованим додатком параметрів креслення. printIndentedUnlessEmpty() забезпечить належне форматування.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.preprocess"), '', '\n');

    // створити саме креслення. plotoptions.code.printout забезпечує роботу частини загальних параметрів креслення,
    // які має бути додано до самого виклику функції креслення.
    echo ('plot (5, 5' + getString ("plotoptions.code.printout") + ')\n');

    // вставте тут будь-який код встановлення параметрів, який має бути виконано після креслення.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.calculate"), '\n');
    echo ('})'\n);  // завершуємо інструкцію try()

    if (!is_preview) {
      echo ('rk.graph.off ()\n');
    }
  }
                </programlisting>
	</sect2>
</sect1>
<sect1>
	<title
>Панелі перегляду для даних, виведеного та інших результатів</title>
	<sect2 id="preview_output">
		<title
>Попередній перегляд результатів (HTML)</title>
		<note
><para
>У цьому розділі ви знайдете обговорення додавання функціональної можливості попереднього перегляду до додатків для створення тексту або HTML для друку. Рекомендуємо вам перед прочитанням цього розділу, ознайомитися із розділом щодо <link linkend="preview_plots"
>попереднього перегляду креслень</link
>.</para
></note>
		<para
>Створення попереднього перегляду виведення у форматі HTML дуже подібне до створення попереднього перегляду креслення. У цьому випадку просто переконайтеся, що <command
>preview()</command
> створює відповідні команди <command
>rk.print()/rk.results()</command
>. Втім, загалом, варто пропустити інструкції заголовка у попередньому перегляді. Ось спрощений приклад: </para>
		<programlisting
>&lt;!-- У файлі XML додатка --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" mode="output"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Зауважте специфікацію <parameter
>mode="output"</parameter
> у елементі <command
>&lt;preview&gt;</command
>. </para>
		<programlisting
>// У файлі JS додатка
        function preview () {
                // створює код, використаний для попереднього перегляду
                printout (true);
        }

        function printout (is_preview) {
                // створює заголовок, лише якщо is_preview==false
                if (!is_preview) {
                        new Header ("Це надпис").print ();
                }
                echo ('rk.print (result)');
        }
                </programlisting>
	</sect2>
	<sect2 id="preview_data">
		<title
>Попередній перегляд (імпортованих) даних</title>
		<note
><para
>У цьому розділі ви знайдете обговорення додавання функціональної можливості попереднього перегляду до додатків для створення (імпортування) даних. Рекомендуємо вам перед прочитанням цього розділу, ознайомитися із розділом щодо <link linkend="preview_plots"
>попереднього перегляду креслень</link
>.</para
></note>
		<para
>Створення попереднього перегляду імпортованих даних (будь-яких даних, які може обробляти <command
>rk.edit()</command
>) дуже подібне до створення  <link linkend="preview_plots"
>попереднього перегляду креслення</link
>. У наведеному нижче спрощеному прикладі створюється попередній перегляд даних: </para>
		<programlisting
>&lt;!-- У файлі XML додатка --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" active="true" mode="data"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Зауважте, що цього разу елемент <command
>&lt;preview&gt;</command
> визначає <parameter
>mode="data"</parameter
>. <parameter
>active="true"</parameter
> просто робить попередній перегляд типово активним. </para>
		<programlisting
>// У файлі JS додатка
        function preview () {
                // створює код, що використовується для попереднього перегляду
                calculate (true);
        }

        function calculate (is_preview) {
                echo ('imported &lt;- read.csv (file="' + getString ("file") /* [+ options] */);
                if (is_preview) {
                        echo ('preview_data &lt;- imported\n');
                } else {
                        echo ('.GlobalEnv$' + getString ("name") + ' &gt;- imported\n');
                }
        }

        function printout () {
                // [...]
        }
                </programlisting>
		<para
>Знову ж, функція <command
>preview()</command
> створює майже той самий код, що і функція <command
>calculate()</command
>, отже ми створимо допоміжну функцію <command
>doCalcuate()</command
>, яка міститиме спільні частини цих функцій. Найважливішим є те, що вам слід пов’язати імпортовані дані з об’єктом із назвою <parameter
>preview_data</parameter
> (у межах поточного середовища, local). <emphasis
>Решту дій буде виконано автоматично</emphasis
> (грубо кажучи, &rkward; викличе <command
>rk.edit(preview_data)</command
>, що містить виклик <command
>.rk.with.window.hints()</command
>). </para>
		<note
><para
>Хоча панелі попереднього перегляду є чудовою можливістю програми, вони споживають системні ресурси. У випадку попереднього перегляду даних можливі ситуації, коли попередній перегляд призводитиме до серйозних проблем із швидкодією. Таке трапляється, якщо імпортують величезні набори даних (які надто великі, щоб їх можна було відкрити для редагування у вікні &rkward;), хоча і «звичайні» набори даних може бути імпортовано з помилками, коли створюється величезна кількість рядків або стовпчиків. <emphasis
>Наполегливо рекомендуємо вам обмежити <parameter
>preview_data</parameter
></emphasis
> до розмірності, за якої попередній перегляд буде корисним без небезпеки створення значних проблем із швидкодією (наприклад, матриці з 50 рядками і 50 стовпчиками має бути більш ніж достатньо у більшості випадків). </para
></note>
	</sect2>
	<sect2 id="preview_custom">
		<title
>Нетипові панелі попереднього перегляду</title>
		<para
>Елементом <command
>&lt;preview&gt;</command
> можна скористатися для створення панелей попереднього перегляду для будь-яких типів вікон «документів», які можна долучити до робочого простору &rkward;. Окрім <link linkend="preview_plots"
>креслень</link
> та <link linkend="preview_data"
>вікон даних</link
>, можна створювати попередні перегляди файлів HTML, скриптів &R; та вікна резюме об’єктів. Для останніх вам слід скористатися елементом <command
>&lt;preview mode="custom"&gt;</command
>. </para>
		<para
>Якщо ви прочитали розділи із описом створення попереднього перегляду креслень та даних, вам вже знайомі загальні кроки цієї процедури, але для створення «нетипових» попередніх переглядів доведеться виконати трохи більше ручної роботи. Найважливішою функцією у цьому випадку буде функція &R; <command
>rk.assign.preview.data()</command
>. У наведеному нижче короткому фрагменті коду показано, як має виглядати створений вами код &R; для додатка створення текстового файла: </para>
		<programlisting
>## Буде створено у розділі коду preview() додатка
        pdata &lt;- rk.get.preview.data("SOMEID")
        if (is.null (pdata)) {
                outfile &lt;- rk.get.tempfile.name(prefix="preview", extension=".txt")
                pdata &lt;- list(filename=outfile, on.delete=function (id) {
                        unlink(rk.get.preview.data(id)$filename)
                })
                rk.assign.preview.data("SOMEID", pdata)
        }
        try ({
                cat ("This is a test", pdata$filename)
                rk.edit.files(file=pdata$filename)
        })
                </programlisting>
		<para
>Тут ми маємо отримати значення <parameter
>SOMEID</parameter
> з властивості <parameter
>id</parameter
> елемента <command
>&lt;preview&gt;</command
>. Тобто, використовуємо <command
>getString ("preview.id")</command
> у файлі .js додатка. </para>
	</sect2>
</sect1>

<sect1 id="contextualized_plugins">
	<title
>Додатки, які залежать від контексту</title>
	<para
>Досі ми припускали, що усі додатки є самодостатніми і усі додатки створюють власний пункт у меню. Втім, деякі додатки працюють лише (або і) у певному контексті. Наприклад, додаток для експортування вмісту графічного пристрою X11 &R;, очевидно, корисний, коли його пункт розташовано у меню пристрою X11, а не у основному меню вікна програми. Крім того, такому додатку доведеться передавати номер пристрою, з яким йому доведеться працювати, без додаткового отримання від користувача даних щодо цього. </para>
	<para
>Такі додатки ми будемо називати контекстно-залежними. Відповідно, у <link linkend="pluginmap"
>файлі &pluginmap;</link
> їх не буде розташовано у основному елементі <command
>&lt;hierarchy&gt;</command
> (або буде розташовано не лише там). Вони розташовуватимуться у елементі <command
>&lt;context&gt;</command
>. У поточній версії передбачено лише два різних контексти (додаткові контексти буде додано у майбутніх версіях): x11 та імпортування файлів. Послідовно розгляньмо кожен з контекстів. Навіть якщо вам цікавий лише контекст імпортування, будь ласка, прочитайте й розділ щодо контексту x11, оскільки він є трохи докладнішим. </para>

	<sect2 id="context_x11">
		<title
>Контекст пристрою X11</title>
		<para
>Щоб використати додаток у контексті пристрою x11, тобто додати його пункт у меню вікна, яке ви отримуєте після виклику <function
>x11()</function
> у консолі, спочатку оголосимо його у звичайний спосіб у <link linkend="pluginmap"
>файлі &pluginmap;</link
>: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_x11_plugin" file="my_x11_plugin.xml" label="An X11 context plugin"/&gt;
                [...]
        &lt;/components&gt;
                </programlisting>
		<para
>Втім, вам не потрібно визначати його у ієрархії (ви можете, якщо він працюватиме і як додаток верхнього рівня): </para>
		<programlisting
>&lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
                </programlisting>
		<para
>Замість цього, додайте визначення контексту «x11» і додайте пункт у меню так: </para>
		<programlisting
>&lt;context id="x11"&gt;
                [...]
                &lt;menu id="edit"&gt;
                        [...]
                        &lt;entry id="my_x11_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
&lt;/document&gt;
                </programlisting>
		<para
>У <link linkend="logic"
>розділі логіки файла xml додатка</link
> ви можете тепер оголосити дві властивості <command
>&lt;external&gt;</command
>: <parameter
>devnum</parameter
> і <parameter
>context</parameter
>. Для властивості <parameter
>context</parameter
> (якщо її оголошено) буде встановлено значення <replaceable
>"x11"</replaceable
>, якщо додаток викликано у відповідному контексті. Для властивості <parameter
>devnum</parameter
> буде встановлено значення номера графічного пристрою, з якими слід працювати. Ось і все. </para>
	</sect2>

	<sect2 id="context_import">
		<title
>Контекст імпортування даних</title>
		<para
>Перш ніж читати цей розділ, будь ласка, прочитайте розділ щодо <link linkend="context_x11"
>контексту пристрою X11</link
>, оскільки там наведено пояснення базових понять. </para>
		<para
>Контекст <replaceable
>"import"</replaceable
> використовується для оголошення додатків фільтрування файлів. Ви просто додаєте оголошення з контекстом та <parameter
>id=</parameter
><replaceable
>"import"</replaceable
> до файла &pluginmap;. Втім, у оголошеннях таких додатків є одна особливість: для забезпечення однорідності вигляду діалогового вікна вибору файлів для усіх підтримуваних типів файлів, вам слід оголосити ось що для вашого компонента: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_xyz_import_plugin" file="my_xyz_import_plugin.xml" label="Import XYZ files"&gt;
                        &lt;attribute id="format" value="*.xyz *.zyx" label="XYZ data files"/&gt;
                &lt;/component&gt;
                [...]
        &lt;/components&gt;
        &lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
        &lt;context id="import"&gt;
                [...]
                &lt;menu id="import"&gt;
                        [...]
                        &lt;entry id="my_xyz_import_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
        [...]
&lt;/document&gt;
                </programlisting>
		<para
>Рядок атрибута просто повідомляє, що пов’язаними суфіксами назв для файлів XYZ є <literal role="extension"
>*.xyz</literal
> або <literal role="extension"
>*.zyx</literal
>, і що фільтр слід називати у діалоговому вікні вибору файлів <quote
>XYZ data files</quote
>. </para>
		<para
>У вашому додатку ви можете оголосити дві властивості <command
>&lt;external&gt;</command
>. <parameter
>filename</parameter
> буде встановлено у значення файла з вказаною назвою, а <parameter
>context</parameter
> буде встановлено у значення <replaceable
>"import"</replaceable
>. </para>
	</sect2>
</sect1>

<sect1 id="querying_r_for_info">
<title
>Надсилання запитів щодо даних до &R;</title>
	<para
>Інколи може виникнути потреба у отриманні певних даних від &R; з метою показу їх у графічному інтерфейсі вашого додатка. Наприклад, ви можете запропонувати набір рівнів фактора, який користувач вибрав для аналізу. Починаючи з версії 0.6.2 &rkward;, це можна робити. Перш ніж ми розпочнемо пояснювати, як саме це робити, важливо ознайомитися з певними підводними каменями цього підходу:</para>
	<para
>Код &R;, який запускається у частині графічного інтерфейсу додатка, оброблятиметься у циклі обробки подій &R;, тобто його можна виконувати <emphasis
>під час</emphasis
> виконання інших обчислень. Так зроблено, щоб графічним інтерфейсом вашого додатка можна було користуватися, навіть коли &R; виконує якісь інші дії. Втім, це робить важливою відсутність у вашому коді сторонніх ефектів. Зокрема, має бути забезпечено такі вимоги щодо коду:</para>
	<itemizedlist>
		<listitem
><para
><emphasis
>Не</emphasis
> виконувати надання змінним значень у .GlobalEnv або будь-якому іншому нелокальному середовищі.</para
></listitem>
		<listitem
><para
><emphasis
>Не</emphasis
> виводити нічого до файла виведення результатів.</para
></listitem>
		<listitem
><para
><emphasis
>Не</emphasis
> малювати нічого на екрані.</para
></listitem>
		<listitem
><para
>Загалом, <emphasis
>не</emphasis
> віддавайте ніяких команд, які можуть мати побіжні наслідки. Ваш код може <emphasis
>читати дані</emphasis
>, але не повинен хоч щось <emphasis
>робити</emphasis
>.</para
></listitem>
	</itemizedlist>
	<para
>Беручи це все до уваги, наведемо загальний зразок коду. Ви можете скористатися цим у розділі <link linkend="logic_scripted"
>керування логікою інтерфейсу за допомогою скриптів</link
>:</para>
	<programlisting
>&lt;script&gt;&lt;![CDATA[
                                last_command_id = -1;
                                gui.addChangeCommand ("variable", "update ()");
                                update = function () {
                                        gui.setValue ("selector.enabled", 0);
                                        variable = gui.getValue ("variable");
                                        if (variable == "") return;

                                        last_command_id = doRCommand ('levels (' + variable + ')', "commandFinished");
                                }

                                commandFinished = function (result, id) {
                                        if (id != last_command_id) return;  // зараз з’явиться новий результат
                                        if (typeof (result) == "undefined") {
                                                gui.setListValue ("selector.available", Array ("ERROR"));
                                                return;
                                        }
                                        gui.setValue ("selector.enabled", 1);
                                        gui.setListValue ("selector.available", result);
                                }
                ]]&gt;&lt;/script&gt;
        </programlisting>
	<para
>Тут <parameter
>variable</parameter
> — це властивість, що містить назву об’єкта (наприклад, у <command
>&lt;varslot&gt;</command
>). Кожного разу, коли назва змінюється, виникає потреба у оновленні показу рівнів у <command
>&lt;valueselector&gt;</command
> із назвою <parameter
>selector</parameter
>. Ключовою функцією є <command
>doRCommand()</command
>, функція, яка приймає як перший параметр рядок команди, яку слід виконати, і як другий параметр — назву функції, яку слід викликати, коли виконання команди буде завершено. Зауважте, що команда виконуватиметься у асинхронному режимі, і це дещо ускладнює речі. По-перше, вам слід зробити так, щоб ваш <command
>&lt;valueselector&gt;</command
> залишався вимкненим, доки у ньому не міститиметься актуальної інформації. По-друге, потенційно, до черги обробки може потрапити декілька команд, доки ви отримаєте перші результати. Ось чому кожній команді надано «id», і ми зберігаємо його у <parameter
>last_command_id</parameter
> для подальшого використання.</para>
	  <para
>Під час виконання команди програма виконує вказаний виклик (у нашому випадку <parameter
>commandFinished</parameter
>) з двома параметрами: самим результатом та ідентифікатором відповідної команди. Результат належатиме до типу, який є відповідним представленню у &R;, тобто до числових масивів, якщо результат є числовим тощо. Результатом може бути навіть <command
>list()</command
> &R;,  але у цьому випадку його буде представлено як <command
>Array()</command
> JS без назв.</para>
	  <para
>Зауважте, що навіть це приклад є дещо спрощеним. Насправді, вам доведеться вжити певних застережних заходів, наприклад, уникати надмірної кількості вкладених рівнів у засобі вибору. Втім, ймовірно, вам не потрібно буде дбати про усе самому. Наведений вище приклад взято з додатка <command
>rkward::level_select</command
>, який ви можете просто <link linkend="embedding"
>вбудувати</link
> до вашого власного додатка. Це навіть надасть вам змогу вказати інший вираз для виконання замість <command
>levels()</command
>.</para>
</sect1>

<sect1 id="current_object">
<title
>Посилання на поточний об’єкт або поточний файл</title>
	<para
>Для багатьох додатків бажаною є обробка <quote
>поточного</quote
> об’єкта. Наприклад, додаток <quote
>sort</quote
> міг би попередньо вибрати для упорядковування об’єкт data.frame, який ви зараз редагуєте. Назву поточного об’єкта додатки можуть отримати за допомогою попередньо визначеної властивості із назвою <parameter
>current_object</parameter
>. Ви можете з’єднати цю властивість з додатком у звичайний спосіб. Якщо поточного об’єкта немає, властивість матиме значення порожнього рядка. Так само, доступ до адреси поточного файла скрипту можна отримати з попередньо визначеної властивості із назвою <parameter
>current_filename</parameter
>. Якщо у програмі не редагується жодного скрипту або скрипт ще не було збережено до файла, властивість буде порожньою. </para>
	<para
>У поточній версії <parameter
>current_object</parameter
> може належати лише до класу <function
>data.frame</function
>, але, будь ласка, не покладайтеся на це, оскільки у майбутніх версіях його належність може бути розширена на інші типи. Якщо вам потрібні лише об’єкти <function
>data.frame</function
>, краще з’єднайте додаток з властивістю <parameter
>current_dataframe</parameter
>. Крім того, ви можете примусово встановити тип, використовуючи відповідні обмеження на ваші <command
>&lt;varslot&gt;</command
> або скориставшись <link linkend="logic_scripted"
>скриптовим керуванням логікою графічного інтерфейсу</link
>. </para>
</sect1>

<sect1 id="optionset">
	<title
>Повторення (набору) параметрів</title>
	<para
>Іноді виникає потреба у повторенні набору параметрів для довільної кількості пунктів. Наприклад, припустімо, що вам хочеться створити додаток для упорядковування data.frame. Нехай потрібно упорядкувати набір даних за довільною кількістю стовпчиків (у випадку зв’язків у перших стовпчиках). Реалізувати це доволі просто: надаємо користувачу можливість вибрати декілька змінних у <command
>&lt;varslot&gt;</command
> за допомогою <parameter
>multi="true"</parameter
>. Але якщо виникне потреба розширення, наприклад, дозволити користувачеві вказати для кожної зі змінних, чи слід перетворювати її на символьне або числове значення, або визначити порядок записів (за зростанням чи спаданням), вам знадобиться гнучкіший спосіб. Іншими прикладами може бути малювання декількох графіків на одному кресленні (з можливістю вибору об’єкта, стилю лінії, кольору лінії тощо для кожного з графіків) або визначення відображення для перекодування з набору старих значень на набір нових значень. </para>
	<para
>Увійдімо до <command
>&lt;optionset&gt;</command
>. Розгляньмо простий приклад, спочатку: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        &lt;row&gt;
                                &lt;input id="firstname" label="Ім’я" size="small"&gt;
                                &lt;input id="lastname" label="Прізвище" size="small"&gt;
                                &lt;radio id="gender" label="Стать"&gt;
                                        &lt;optioncolumn label="Чоловіча" value="m"/&gt;
                                        &lt;optioncolumn label="Жіноча" value="f"/&gt;
                                &lt;/radio&gt;
                        &lt;/row&gt;
                &lt;/content&gt;

                &lt;optioncolumn id="firstnames" label="Ім’я" connect="firstname.text"&gt;
                &lt;optioncolumn id="lastnames" label="Прізвище" connect="lastname.text"&gt;
                &lt;optioncolumn id="gender" connect="gender.string"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Тут нами створено інтерфейс для визначення кількості осіб (наприклад авторів). Для заповнення нам потрібен принаймні один запис (<parameter
>min_rows="1"</parameter
>). У елементі <command
>&lt;optionset&gt;</command
> ми починаємо з визначення вмісту, <command
>&lt;content&gt;</command
>, тобто елементів, які належать набору параметрів. Ви вже знайомі із більшістю елементів у <command
>&lt;content&gt;</command
>. </para
><para
>Далі, ми вкажемо потрібні нам змінні, які слід прочитати з набору пунктів до нашого файла JS. Оскільки ми матимемо справу з довільною кількістю записів, ми не можемо просто прочитати <function
>getString ("firstname")</function
> у коді JS. Замість цього, для кожного потрібного нам значення ми вказуємо <command
>&lt;optioncolumn&gt;</command
>. Наприклад, для першого optioncolumn <command
>&lt;connect="firstname.text"&gt;</command
> означає, що вміст елемента <command
>&lt;input&gt;</command
> «firstname» буде прочитано для усіх записів. Значення <command
>&lt;optioncolumn&gt;</command
>, для яких задано <parameter
>label</parameter
>, буде показано на екрані у стовпчику з відповідною міткою. У коді JS ми тепер можемо отримати імена усіх авторів за допомогою <function
>getList("set.firstname")</function
>, прізвища — за допомогою <function
>getList("set.lastnames")</function
>, а стать — за допомогою <function
>getList("set.gender")</function
>. </para>
	<para
>Зауважте, що не існує обмежень щодо того, що ви можете розмістити у <command
>&lt;optionset&gt;</command
>. Ви навіть можете скористатися <link linkend="embedding"
>вбудованими</link
> компонентами. Так само, як із будь-яким іншим елементом, усе, що вам треба зробити, — це зібрати усі бажані змінні для виведення у специфікації <command
>&lt;optioncolumn&gt;</command
>. У випадку вбудованих додатків це часто розділ властивості «code». Приклад: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Колір"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Звичайно ж, ми також можемо скористатися <link linkend="logic"
>логікою графічного інтерфейсу</link
> у optionset. Для цього передбачено два варіанта: ви можете зробити це створивши з’єднання (або скрипт) у основному розділі <command
>&lt;logic&gt;</command
> вашого додатка, як завжди. Втім, доступ до елементів графічного інтерфейсу у області вмісту доведеться здійснювати за допомогою (наприклад) «set.contents.firstname.XYZ». Зауважте префікс «set» (<parameter
>id</parameter
>, який ви призначили set і «contents»). Крім того, ви можете додати окремий розділ <command
>&lt;logic&gt;</command
> як дочірній елемент вашого <command
>&lt;optionset&gt;</command
>. У цьому випадку <parameter
>id</parameter
> буде адресовано відносно області вмісту, наприклад «firstname.XYZ». Втім, у розділі logic optionset не можна використовувати елемент <command
>&lt;script&gt;</command
>. Якщо вам потрібні скриптові команди, вам доведеться скористатися основним розділом <command
>&lt;logic&gt;</command
> додатка. </para>
	<note>
		<para
>Якщо логіку скрипту розташовано у optionset, усе, що ви можете зробити, це отримати доступ до <emphasis
>поточної</emphasis
> області вмісту. Таким чином, типово, має сенс лише з’єднування елементів у області вмісту один з одним. З’єднування властивості поза <command
>&lt;optionset&gt;</command
> із властивістю у області вмісту може бути корисним для ініціалізації. Втім, внесення змін до області вмісту після ініціалізації <emphasis
>не буде застосовано</emphasis
> до пунктів, які користувач вже визначив. Вони стосуватимуться лише поточного позначеного пункту у наборі. </para>
	</note>
	<sect2 id="optionset_driven">
		<title
>«Керовані» optionset-и</title>
		<para
>Досі ми розглядали <command
>&lt;optionset&gt;</command
>, у якому передбачено кнопки для додавання або вилучення пунктів. Втім, іноді набагато природнішим є вибрати пункти поза <command
>&lt;optionset&gt;</command
> і надати лише параметри налаштовування кожного з пунктів у <command
>&lt;optionset&gt;</command
>. Наприклад, припустімо, що вам потрібно надати користувачеві змогу вибрати декілька об’єктів для креслення. Для кожного з об’єктів, користувач повинен мати змогу вказати колір лінії. Реалізувати це <emphasis
>можна</emphasis
>, розташувавши <command
>&lt;varselector&gt;</command
> і <command
>&lt;varslot&gt;</command
> всередині області <command
>&lt;content&gt;</command
>, дозволивши користувачеві вибирати одночасно лише один пункт. Втім, користувачеві доведеться клацати кнопкою миші набагато менше, якщо ви замість цього скористаєтеся <command
>&lt;varslot multi="true"&gt;</command
> <emphasis
>ззовні</emphasis
> щодо <command
>&lt;optionset&gt;</command
>. Далі, ви з’єднаєте засіб вибору об’єктів із так званим «керованим» набором пунктів. Ось реалізація: </para>
		<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;connect client="set.vars" governor="vars.available"/&gt;
                &lt;connect client="set.varnames" governor="vars.available.shortname"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;varselector id="varsel"/&gt;
        &lt;varslot id="vars" label="Objects to plot"/&gt;
        &lt;optionset id="set" keycolumn="var"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Line color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="vars" external="true"&gt;
                &lt;optioncolumn id="varnames" external="true" label="Variable"&gt;
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
		<para
>Почнемо розгляд нашого прикладу з нижньої частини. Там можна бачити два визначення <command
>&lt;optioncolumn&gt;</command
> із <parameter
>external="true"</parameter
>. Це повідомляє &rkward;, що відповідні елементи керуються з-поза меж <command
>&lt;optionset&gt;</command
>. Тут єдиним призначенням optioncolumn «varnames» є надання простих для читання міток у області показу optionset (її з’єднано з модифікатором «shortname» властивості, що містить позначені об’єкти). Метою optioncolumn «vars» є виконання обов’язків «ключового» стовпчика, як це вказано за допомогою <command
>&lt;optionset keycolumn="vars"...&gt;</command
>. Це означає, що для кожного запису у цьому списку набір пропонуватиме один набір пунктів, а пункти логічно пов’язані з цими записами. Цей стовпчик з’єднано із властивістю, що містить позначені у <command
>&lt;varslot&gt;</command
> об’єкти. Отже, для кожного об’єкта, який позначено, <command
>&lt;optionset&gt;</command
> надаватиме змогу вказати колір лінії. </para>
		<note>
			<para
>Зовнішній стовпчик також можна з’єднати за допомогою <parameter
>connect</parameter
> із властивостями у області <command
>&lt;content&gt;</command
>. Втім, варто зауважити, що optioncolumn, оголошені як <parameter
>external="true"</parameter
>, ніколи не слід змінювати з середини <command
>&lt;optionset&gt;</command
>, а optioncolumn, оголошені як <parameter
>external="false"</parameter
> (типово), ніколи не слід змінювати ззовні від <command
>&lt;optionset&gt;</command
>. </para>
		</note>
	</sect2>
	<sect2 id="optionset_alternatives">
		<title
>Альтернативи: коли не слід використовувати optionset</title>
		<para
>Optionset-и — потужний інструмент, але іноді вони здатні наробити більше шкоди, ніж принести користі, оскільки вони значно ускладнюють структуру додатка як з точки зору розробника додатка, так і з точки зору користувача. Тому двічі подумайте, перш ніж користуватися ними. Ось декілька порад: </para>
		<itemizedlist>
			<listitem
><para
>У простих випадках корисною альтернативою, яка не є такою складно, є елемент <command
>&lt;matrix&gt;</command
>.</para
></listitem>
			<listitem
><para
>Не переобтяжуйте ваш додаток зайвими можливостями. У нашому прикладі optionset використовується для створення додатка, який малює на одному кресленні декілька ліній. Але, загалом, не варто створювати додатки, які робитимуть окремі креслення для кожного елемента з optionset. Краще створити додаток, який робитиме одне креслення, щоб користувач міг викликати його декілька разів з різними параметрами. </para
></listitem>
			<listitem
><para
>Якщо у наборі має бути не більше двох-трьох записів, варто просто повторити пункти вручну.</para
></listitem>
		</itemizedlist>
	</sect2>
</sect1>

</chapter>

<chapter id="chapter_dependencies">
<title
>Проблеми залежностей і сумісності</title>
<sect1 id="sect_dependencies_rkward_version"
><title
>Сумісність із версіями &rkward;</title>
	<para
>Ми намагаємося робити так, щоб додатки, які було створено для старих версій &rkward;, могли працювати і у новіших версіях &rkward;. Втім, зі зворотною сумісністю все не так добре, адже у програмі весь час з’являються нові можливості. Оскільки не усі користувачі працюють із найсвіжішою версією &rkward;, ваш додаток може виявитися непрацездатним у деяких системах.</para>
	<para
>Якщо вам відомі такі проблеми сумісності, вам слід документувати їх у вашому файлі &pluginmap; за допомогою елемента <command
>&lt;dependencies&gt;</command
>. Елемент <command
>&lt;dependencies&gt;</command
> можна вказати або як безпосередній дочірній елемент елемента &pluginmap; &lt;document&gt;, або як дочірній елемент окремих визначень <command
>&lt;component&gt;</command
>. У першому випадку залежності буде застосовано до <emphasis
>усіх</emphasis
> додатків з карти. У другому випадку — лише до окремого <command
>&lt;component&gt;</command
>. Ви також можете визначити суміш верхніх «загальних» і «специфічних» залежностей. У цьому випадку загальні залежності буде додано до залежностей індивідуальних компонентів.</para>
	<para
>Розгляньмо невеличкий приклад:</para>
	<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c" /&gt;
        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
        </programlisting>
	<para
>У цьому прикладі від усіх додатків вимагається, щоб було встановлено принаймні версію 0.5.0c &rkward;. Один з додатків, з <replaceable
>id="myplugin"</replaceable
>, постачається у двох альтернативних варіантах. Перший, спрощений, може бути використано для версій &rkward;, які передували версії 0.6.1. Інший же використовує можливості, які з’явилися у &rkward;, починаючи з версії 0.6.1, отже ним можна буде скористатися лише у &rkward; 0.6.1 та наступних версіях.</para>
	<para
>Надання таких альтернативних варіантів, як у наведеному прикладі, є дружнім до користувача способом скористатися новими можливостями, зберігши можливість користування у попередніх версіях &rkward;. У альтернативних версій має бути однакове значення <parameter
>id</parameter
> (якщо вказати різні, програма показуватиме попередження). Крім того, їх можна визначити лише <emphasis
>у межах одного</emphasis
> файла &pluginmap;.</para>
	<para
>Додаток, який є несумісним із запущеною версією &rkward; і який не має альтернативних версій, буде проігноровано із виведенням відповідного попередження.</para>
	<note
><para
>Насправді, &rkward; 0.6.1 був першою версією, у якій можна було слідкувати за залежностями і повідомляти про проблеми із залежностями взагалі. Отже, на відміну від того, про що можна було б припустити з нашого прикладу, визначення будь-яких версій до 0.6.1 у описі залежностей не матиме ніякого безпосереднього впливу на працездатність додатка (втім, може бути корисним з міркувань документування).</para
></note>
	<para
><emphasis
>Іноді</emphasis
> навіть можна обробляти проблеми з несумісністю версій <emphasis
>всередині</emphasis
> єдиного файла &pluginmap; за допомогою елемента <command
>&lt;dependency_check&gt;</command
>, описаного у наступному розділі.</para>
</sect1>
<sect1 id="sect_dependencies_r_version"
><title
>Сумісність із версіями &R;</title>
	<para
>Подібно до <parameter
>rkward_min_version</parameter
> і <parameter
>rkward_max_version</parameter
>, елемент <command
>&lt;dependencies&gt;</command
> надає змогу визначити атрибути <parameter
>R_min_version</parameter
> і <parameter
>R_max_version</parameter
>. Втім, є такі відмінності:</para>
	<itemizedlist>
		<listitem
><para
>Додатки, які не задовольнятимуть вимогам щодо версії &R; у поточній версії <emphasis
>не пропускатимуться</emphasis
> під час читання файла &pluginmap;. Користувач все одно зможе викликати відповідний додаток, і не побачить негайного попередження (у майбутніх версіях таке попередження, ймовірно, буде показано).</para
></listitem>
		<listitem
><para
>Як наслідок, <emphasis
>не можна</emphasis
> визначати альтернативні версії додатка, робота яких залежатиме від версії &R;.</para
></listitem>
		<listitem
><para
>Втім, часто доволі просто досягнути зворотної сумісності у спосіб, показаний нижче. Якщо ви припускаєте проблеми із сумісністю з &R;, будь ласка, спробуйте цей спосіб замість визначення залежності від певної версії &R;.</para
></listitem>
	</itemizedlist>
	<para
>У багатьох випадках доволі просто надати у розпорядження користувача обмежені функціональні можливості, якщо певна можливість є недоступною у запущеній версії &R;. Розгляньмо такий короткий приклад файла <literal role="extension"
>.xml</literal
> додатка:</para>
	<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;dependency_check id="ris210" R_min_version="2.10.0"/&gt;
                &lt;connect client="compression.xz.enabled" governor="ris210"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;radio id="compression" label="Compression method"&gt;
                &lt;option label="None" value=""&gt;
                &lt;option label="gzip" value="gzip"&gt;
                &lt;option id="xz" label="xz" value="xz"&gt;
        &lt;/radio&gt;
        [...]
&lt;/dialog&gt;
        </programlisting>
	<para
>У цьому випадку параметр стискання «xz» буде просто вимкнено, якщо запущена версія &R; виявиться старішою за 2.10.0 (версію, у якій не передбачено підтримки стискання xz). У елементі <command
>&lt;dependency_check&gt;</command
> передбачено підтримку тих сами атрибутів, що і у елементі <command
>&lt;dependencies&gt;</command
> у файлах &pluginmap;. Він створює булеву властивість, яка має значення true (так), якщо вказану залежність задоволено, і значення false, якщо це не так.</para>
</sect1>
<sect1 id="sect_dependencies_r_packages"
><title
>Залежність від пакунків &R;</title>
<para
>Можна визначати залежності від певних пакунків &R;, але, на час версії &rkward; 0.6.1, ці залежності не перевіряються, не встановлюються або завантажуються автоматично. Втім, їх буде показано у файлах довідки до додатка. Ось приклад визначення:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<note
><para
>Не забувайте завжди додавати відповідні виклики <function
>require()</function
>, якщо для роботи вашого додатка потрібно завантажити певні пакунки.</para
></note>
<note
><para
>Якщо ви <link linkend="external_plugins"
>поширюєте вашу &pluginmap; як пакунок &R;</link
>, і усі додатки залежать від певного пакунка, вам слід визначити цю залежність на рівні пакунка &R;. Визначення залежностей від пакунків &R; на рівні &pluginmap; &rkward; є найкориснішим, якщо залежності потребує лише частина ваших додатків, залежності немає у CRAN або ваша &pluginmap; не поширюється як пакунок &R;.</para
></note>
</sect1>
<sect1 id="sect_dependencies_other_pluginmaps"
><title
>Залежності від інших &pluginmap; &rkward;</title>
	<para
>Якщо ваші додатки залежать від додатків, які визначено у іншому &pluginmap; (тобто від чогось, що <emphasis
>не є</emphasis
> частиною вашого пакунка), ви можете визначити цю залежність ось так:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<para
>У поточній версії не завантажуватиме, не встановлюватиме і навіть не попереджатиме щодо &pluginmap;, яких не вистачає, але дані щодо залежностей (та того, як їх отримати) буде показано на сторінці довідки додатка. Ви не повинні (і цього не слід робити) оголошувати залежності від &pluginmap;-ів, які постачаються разом із офіційним дистрибутивом &rkward;, або від &pluginmap;-ів, які є частиною вашого пакунка. Більше того, якщо потрібний вам &pluginmap; <link linkend="external_plugins"
>поширюється як пакунок &R;</link
>, оголошуйте залежність від пакунка (як показано у попередньому розділі), а не від &pluginmap;-а.</para>
	<para
>Щоб переконатися, що потрібні &pluginmap;-и буде насправді завантажено, скористайтеся теґом <command
>&lt;require&gt;</command
> (зверніться до <link linkend="pluginmapelements"
>довідника</link
>, щоб ознайомитися із докладнішим описом).</para>
</sect1>
<sect1 id="sect_dependencies_example"
><title
>Приклад</title>
	<para
>Щоб прояснити питання поєднання визначень залежностей, наведемо приклад із поєднанням:</para>
<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c"&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
                &lt;package 
                        name="DreamsOfPi"
                        min_version="0.2"
                /&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;dependencies&gt;

        &lt;require map="heisenberg::heisenberg_plugins"/&gt;

        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
</programlisting>
</sect1>
</chapter>

<chapter id="i18n">
	<title
>Переклади додатків</title>
	<para
>Досі ми використовували декілька концепцій щодо перекладів або «i18n» (скорочення від «internationalization», де між «i» і «n» вставлено кількість літер, 18). У цьому розділі ми докладніше розглянемо функціональні можливості i18n для додатків &rkward;. Здебільшого, у вас <emphasis
>не виникатиме</emphasis
> потреби у застосуванні усього цього у ваших додатках. Втім, варто усе ж прочитати цей розділ повністю, оскільки розуміння цих концепцій має допомогти вам у створенні повністю придатних до перекладу додатків та забезпечить вищу якість перекладів. </para>
	<sect1 id="i18n_general"
><title
>Загальні міркування</title>
		<para
>Однією з важливих речей, які слід розуміти, коли ми говоримо про переклад програмного забезпечення, на відміну від перекладу звичайного тексту, є те, що часто перекладачів позбавлено можливості бачити загальну картину того, <emphasis
>що</emphasis
> вони перекладають. Для перекладу програмного забезпечення вимушено використовуються короткі фрагменти тексту: усі мітки, які записано всередині теґів <command
>&lt;option&gt;</command
> у <command
>&lt;radio&gt;</command
>, усі позначені вами для перекладу рядки у викликах функції <command
>i18n()</command
> є окремими «модулями перекладу». Загалом, кожен такий фрагмент перекладач бачитиме ізольовано від коду, який використано у додатку. Якщо бути зовсім точним, ця ізоляція є неповною, оскільки ми намагаємося надати перекладачеві якомога ширший змістовний контекст модуля, автоматично видобуваючи його з коду. Але подекуди перекладачам буде важливим додатковий контекст, потрібний для розуміння рядка, особливо там, де рядки є короткими. </para>
	</sect1>
	<sect1 id="i18n_xml"
><title
>i18n у файлах XML &rkward;</title>
		<para
>Для файлів xml &rkward; i18n здебільшого працює без будь-яких додаткових зусиль. Якщо ви створюєте власну <command
>.pluginmap</command
> (наприклад, для <link linkend="external_plugins"
>зовнішнього додатка</link
>), вам слід вказати <replaceable
>po_id</replaceable
> поряд із <replaceable
>id</replaceable
> у pluginmap. Це визначить «каталог повідомлень», який слід використовувати. Загалом, це має бути рядок, який є ідентичним до <replaceable
>id</replaceable
> вашого <command
>.pluginmap</command
>, але якщо ви надаєте у додатку декілька пов'язаних <command
>.pluginmap</command
> у одному пакунку, вам, ймовірно, варто вказати загальний <replaceable
>po_id</replaceable
> у ваших картах. Значення <replaceable
>po_id</replaceable
> з файла <command
>.pluginmap</command
> успадковується усіма оголошеними у ньому додатками, якщо у них не оголошено інше значення <replaceable
>po_id</replaceable
>. </para>
		<para
>У файлах опису графічного інтерфейсу та на сторінках довідки вам не потрібно повідомляти &rkward;, які саме рядки слід перекладати, оскільки це зрозуміло з використання цих рядків. Втім, як ми вже пояснювали раніше, вам варто слідкувати за тим, щоб не виникало двозначностей, та тим, щоб усі рядки мали достатні для правильного перекладу пояснення. Для рядків із неоднозначним тлумаченням можна вказати контекст <replaceable
>i18n_context</replaceable
> ось так: </para>
		<programlisting
>&lt;checkbox id="scale" label="Scale" i18n_context="Показати шкалу"/&gt;
&lt;checkbox id="scale" label="Scale" i18n_context="Масштабувати креслення"/&gt;
                </programlisting>
		<para
>Надання контексту <replaceable
>i18n_context</replaceable
> забезпечить можливість перекласти два рядки по-різному. Якщо б контекст не було вказано, обидва рядки мали б абсолютно однаковий переклад. Крім того, контекст буде показано перекладачеві. Підтримку атрибута <replaceable
>i18n_context</replaceable
> передбачено для усіх елементів, які можуть містити придатні до перекладу рядки, зокрема елементів, які містять у собі текст (наприклад елементів <command
>&lt;text&gt;</command
>). </para>
		<para
>У інших випадках рядок для перекладу може мати однозначне значення, але все ж потребує роз’яснення. Для таких рядків можна додати коментар, який буде показано перекладачам. Приклад: </para>
		<programlisting
>&lt;!-- i18n: Ні, це не друкарська помилка у слові «screen»! --&gt;
&lt;component id="scree_plot" label="Scree plot"/&gt;

&lt;!-- i18n: Якщо можна, зробіть переклад якомога коротшим. Переклад з понад 15 символів виглядатиме
тут доволі кострубато, значення має бути майже очевидним для користувача
(вибір зі списку значень, показаного поряд із цим елементом) --&gt;
&lt;valueslot id="selected" label="Pick one"/&gt;
                </programlisting>
		<para
>Зауважте, що такі коментарі мають передувати елементу, до якого їх застосовують, і мають починатися з «i18n:» або «TRANSLATORS:». </para>
		<para
>Нарешті, у рідкісних випадках, у вас може виникнути потреба у виключенні деяких рядків з перекладу. Це має сенс, наприклад, якщо ви надаєте користувачеві вибір між певними назвами функцій &R; у елементі <command
>&lt;radio&gt;</command
>. Звичайно ж, назви функцій не можна перекладати, тоді можна зробити так (втім, залежно від контексту, можна просто додати описову мітку функції): </para>
		<programlisting
>&lt;radio id="transformation" label="R function to apply"&gt;
  &lt;option id="as.list" noi18n_label="as.list()"/&gt;
  &lt;option id="as.vector" noi18n_label="as.vector()"/&gt;
  [...]
&lt;/radio&gt;
                </programlisting>
		<para
>Зауважте, що вам слід прибрати атрибут <replaceable
>label</replaceable
> і вказати замість нього атрибут <replaceable
>noi18n_label</replaceable
>. Також зауважте, що на відміну від використання <replaceable
>i18n_context</replaceable
> і коментарів, використання <replaceable
>noi18n_label</replaceable
> зробить ваш додаток несумісним із версіями &rkward; до версії 0.6.3. </para>
	</sect1>
	<sect1 id="i18n_js"
><title
>i18n у файлах і розділах JS &rkward;</title>
		<para
>На відміну від файлів <literal role="extension"
>.xml</literal
>, для уможливлення перекладу файлів <literal role="extension"
>.js</literal
> доведеться серйозно попрацювати. Ключовою відмінністю у цьому випадку є те, що не існує простого способу автоматично визначити, є той чи інший рядок показаною користувачеві текстовою інформацією чи просто фрагментом програмного коду. Отже, вам доведеться позначити відповідні рядки вручну. Вище ми вже наводили приклади цього. Далі наведено повніший опис функцій для перекладу рядків у коді js та деякі підказки щодо складніших випадків: </para>
<variablelist>
<varlistentry>
	<term
><command
>i18n (msgid, [...])</command
></term>
	<listitem
><para
>Найважливіша функція. Позначає рядок для перекладу. Рядок (перекладений чи ні) повертається взятим у подвійні лапки («"»). Можна використовувати довільну кількість замінників у рядку, як це вже показано вище. Використання замінників замість з’єднання коротких рядків значно полегшує роботу перекладача:</para>
		<programlisting
>i18n ("Compare objects %1 and %2", getString ('x'), getString ('y'));
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18nc (msgctxt, msgid, [...])</command
></term>
	<listitem
><para
>Те саме, що і <command
>i18n()</command
>, але із додаванням контексту повідомлення:</para>
		<programlisting
>i18nc ("proper name, not state of mind", "Mood test");
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18np (msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
>Те саме, що і <command
>i18n()</command
>, але для повідомлень, у яких різні форми для однини і множини (у деяких мовах форм множини може бути декілька). Зауважте, що як і у випадку з <command
>i18n()</command
>, ви можете використовувати довільну кількість замінників, але перший з них, за яким розрізнятимуться форми множини («%1»), має бути цілим числом.</para>
		<programlisting
>i18np ("Comparing a single pair", "Comparing %1 distinct pairs", n_pairs);
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18ncp (msgctxt, msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
><command
>i18np()</command
> із доданим контекстом повідомлення.</para
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>comment (коментар, [режим відступу])</command
></term>
	<listitem
><para
>Виводить коментар до коду, позначений для перекладу. На відміну від інших функцій i18n(), дані не беруться у лапки, а на початку кожного рядка коментаря додається символ «#».</para>
		<programlisting
>comment ("Transpose the matrix");
                        echo ('x &lt;- t (x)\n');
                </programlisting
></listitem>
</varlistentry>
</variablelist>
	<para
>Щоб додати коментарі для перекладачів (див. <link linkend="i18n_xml"
>вище</link
> обговорення відмінностей між коментарем і контекстом), додайте коментар, що починатиметься з «i18n:» або «translators:» одразу перед викликом <command
>i18n()</command
>, який слід прокоментувати. Приклад: </para>
	<programlisting
>// i18n: З правописом усе гаразд, так і має бути: Scree plot.
                echo ('rk.header (' + i18n ("Scree plot") + ')\n');
        </programlisting>

		<sect2 id="i18n_js_quoting"
><title
>Інтернаціоналізація і лапки</title>
			<para
>Здебільшого, потреби перейматися тим, як поводить себе i18n() при використанні лапок у перекладі, немає потреби. Оскільки, типово, придатні до перекладу рядки є рядковими літералами, додавання до них лапок є природною річчю, яка навіть заощаджує зусилля на введення коду. Крім того, у функціях, подібних до <command
>makeHeaderCode()/Header()</command
>, у яких, зазвичай, аргументи беруть у лапки, рядки з i18n() захищено від дублювання лапок. З технічної точки зору, ми надсилаємо перекладений рядок спочатку до функції <command
>quote()</command
> (щоб додати лапки), а потім до функції <command
>noquote()</command
> (щоб запобігти появі зайвих лапок). Якщо вам потрібен придатний для перекладу рядок без лапок, скористайтеся конструкцією <command
>i18n(noquote ("Ваше повідомлення"))</command
>. Якщо ж вам потрібен придатний до перекладу рядок із лапками, ще раз пропустіть його крізь <command
>quote()</command
>, <emphasis
>двічі</emphasis
>. </para>
			<para
>Однак, загалом кажучи, навряд чи варто робити придатними до перекладу назви функції або змінних. По-перше, &R;, мова програмування, заснована на словах англійської мови, а самі команди мови не підлягають перекладу. Коментарі у коді можна перекладати, але для них слід використовувати функцію <command
>comment()</command
>. По-друге, якщо ви зробите синтаксично пов’язані частини створеного коду придатним до перекладу, невдалий переклад може зашкодити працездатності додатка. Наприклад, якщо переклад рядка, який є назвою змінної, складатиметься з двох слів із пробілом між ними, отриманий код просто не працюватиме. </para>
		</sect2>
	</sect1>
	<sect1 id="i18n_workflow"
><title
>Супровід перекладів</title>
		<para
>Тепер, коли ми зробили додаток придатним до перекладу, як насправді його перекласти? Загалом, про це слід дбати окремо, лише якщо ви розробляєте <link linkend="external_plugins"
>зовнішній додаток</link
>. Для додатків у основному сховищі коду &rkward; відповідні дії буде виконано автоматично. Нижче наведено основні прийоми обробки для зовнішніх додатків. Зауважте, що вам доведеться встановити пакунок «gettext»: </para>
		<itemizedlist>
			<listitem
><para
>Позначте відповідним форматуванням усі рядки, надаючи потрібний контекст і коментарі.</para
></listitem>
			<listitem
><para
>Віддайте команду <command
>python3 scripts/update_plugin_messages.py --extract-only /шлях/до/вашого.pluginmap</command
>. Скрипт scripts/update_plugin_messages.py не є частиною пакунка з початковими кодами випуску, але його можна знайти у копії сховища з початковим кодом &rkward;.</para
></listitem>
			<listitem
><para
>Надайте доступ до створеного файла <command
>rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.pot</command
> вашим перекладачам. Для зовнішніх додатків, рекомендуємо зберігати цей файл у підкаталозі «po» у inst/rkward.</para
></listitem>
			<listitem
><para
>Перекладач відкриє файл у програмі для перекладу, наприклад у <command
>lokalize</command
>. Насправді, навіть якщо ви не маєте наміру щось перекладати, вам варто спробувати виконати цей крок власноруч. Перегляньте рядки, які було видобуто, і спробуйте знайти серед них проблемні або неоднозначні.</para
></listitem>
			<listitem
><para
>Перекладач зберігає переклад у файлі <command
>rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> (де <replaceable
>xx</replaceable
> — код мови) і надсилає його розробникам.</para
></listitem>
			<listitem
><para
>Скопіюйте файл <command
>rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> до коду вашого додатка, розмістивши його поряд із файлом <command
>rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.pot</command
>. Віддайте команду <command
>python3 scripts/update_plugin_messages.py /шлях/до/вашого.pluginmap</command
> (Зауваження: цього разу без <replaceable
>--extract-only</replaceable
>). Ця команда узгодить переклад з усіма проміжними змінами у рядках, збере його і встановить як файл <command
><replaceable
>КАТАЛОГ_PLUGINMAP</replaceable
>/po/<replaceable
>xx</replaceable
>/LC_MESSAGES/rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.mo</command
> (де, знову ж таки, <replaceable
>xx</replaceable
> — код мови).</para
></listitem>
			<listitem
><para
>Вам також слід включити нескомпільовані переклади (тобто файли <command
>rkward__<replaceable
>Ідентифікатор_PO</replaceable
>.<replaceable
>xx</replaceable
>.po</command
>) до вашого дистрибутива, у підкаталозі «po».</para
></listitem>
			<listitem
><para
>Якщо ви внесли зміни до вашого додатка, віддайте команду <command
>python3 scripts/update_plugin_messages.py /шлях/до/вашого.pluginmap</command
>, щоб оновити файл .pot і наявні файли .po, а також компільовані каталоги повідомлень.</para
></listitem>
		</itemizedlist>
	</sect1>
	<sect1 id="i18n_translators"
><title
>Створення перекладів додатків</title>
		<para
>Ми припускаємо, що ви вмієте перекладати або навчитеся цьому у якийсь інший спосіб. Втім, маємо сказати декілька слів щодо особливостей перекладу додатків &rkward;: </para>
		<itemizedlist>
			<listitem
><para
>У додатках до &rkward; до версії 0.6.3 не було передбачено можливості перекладу. До цієї версії розробники взагалі не передбачали переклад додатків. Тому ви, напевне, зустрінетеся із неоднозначностями у рядках перекладу та іншими проблемами, яких немає у зріліших проєктах. Будь ласка, не мовчіть про проблеми, повідомте про них розробникам (або супровідникам додатків), щоб вони могли усунути ці проблеми.</para
></listitem>
			<listitem
><para
>У багатьох додатках &rkward; використовується високоспеціалізована термінологія, яка походить з галузі обробки даних та статистики, а також з інших галузей науки. У багатьох випадках створення доброго перекладу потребує від перекладача принаймні базових знань у цих галузях. Іноді, <emphasis
>не існує</emphasis
> доброго перекладу для технічних термінів не існує, і варто залишити термін неперекладеним або включити термін англійською у дужках. Не зосереджуйтеся на тому, щоб обов’язково позначити для перекладу 100 % рядків, намагайтеся зосередитися на тому, щоб виконати якісний переклад, навіть якщо це означає, що слід пропустити деякі рядки (або навіть пропустити деякі каталоги повідомлень цілком). Можливо, пробіли у технічних термінах зможуть заповнити інші користувачі.</para
></listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="chapter_about_information">
<title
>Відомості про автора, умови ліцензування та версію</title>
<para
>Отже, нехай вами створено набір додатків, і ви готові <link linkend="external_plugins"
>поділитися вашою роботою</link
>. Щоб повідомити користувачам про призначення вашої роботи, умови ліцензування та поширення та про те, з ким слід зв’язатися, якщо виникає потреба у сповіщенні про вади та побажання, вам слід додати відомості <emphasis
>щодо</emphasis
> ваших додатків. Зробити це можна за допомогою елемента <command
>&lt;about&gt;</command
>. Ним можна скористатися у &pluginmap; або файлах <literal role="extension"
>.xml</literal
> окремих додатків (у обох випадках як безпосереднім дочірнім елементом теґу document). Якщо цей елемент використано у &pluginmap;, він стосуватиметься усіх додатків. Якщо <command
>&lt;about&gt;</command
> вказано у обох місцях, дані у <command
>&lt;about&gt;</command
> .xml окремого додатка матимуть пріоритет над даними з файла &pluginmap;. Ви також можете додати елемент <command
>&lt;about&gt;</command
> у сторінки .rkh, які не з’єднано з додатками, якщо у цьому є потреба.</para>
<para
>Нижче наведено приклад файла &pluginmap; лише з декількома поясненнями. Якщо щось є незрозумілим, будь ласка, зверніться з довідника щодо теґів.</para>
<programlisting
>&lt;document 
        namespace="rkward"
        id="SquaretheCircle_rkward"
&gt;
        &lt;about 
                name="Square the Circle"
                shortinfo="Squares the circle using Heisenberg compensation."
                version="0.1-3"
                releasedate="2011-09-19"
                url="http://eternalwondermaths.example.org/23/stc.html"
                license="GPL"
                category="Geometry"
        &gt;
                &lt;author 
                        given="E.A."
                        family="Dölle"
                        email="doelle@eternalwondermaths.example.org"
                        role="aut"
                 /&gt;
                &lt;author 
                        given="A."
                        family="Assistant"
                        email="alterego@eternalwondermaths.example.org"
                        role="cre, ctb"
                 /&gt;
        &lt;/about&gt;
        &lt;dependencies&gt;
                ...
        &lt;/dependencies&gt;
        &lt;components&gt;
                ...
        &lt;/components&gt;
        &lt;hierarchy&gt;
                ...
        &lt;/hierarchy&gt;
&lt;/document&gt;
</programlisting>
<para
>Більша частина коду доволі очевидна, тому ми не будемо обговорювати усі теґи. Втім, ми розглянемо детально елементи, які потребують пояснень для кращого розуміння. </para>
<para
>Елемент <parameter
>category</parameter
> у <command
>&lt;about&gt;</command
> може визначатися довільним чином, але має бути зрозумілим для програміста, оскільки його має бути використано для упорядковування додатків за групами. Усі інші атрибути у цьому початковому тезі є обов’язковими і мають бути заповнені відповідним чином. </para>
<para
>Має бути також вказано принаймні один елемент <command
>&lt;author&gt;</command
> із коректною адресою електронної пошти і роллю <quote
>aut</quote
> (<quote
>автор</quote
>). Якщо з вашим додатком виникатимуть проблеми або хтось захоче вам подякувати, має бути надійний спосіб зв’язатися із кимось причетним до додатка. Щоб дізнатися більше про інші коректні ролі учасників розробки, зокрема <quote
>ctb</quote
> для програмістів або <quote
>cre</quote
> для супровідників пакунка, будь ласка, зверніться до <ulink url="http://stat.ethz.ch/R-manual/R-patched/library/utils/html/person.html"
>документації R з функції <function
>person()</function
></ulink
>. </para>
<note
><para
>Пам’ятайте, що можна використовувати <command
>&lt;include&gt;</command
> і / або <command
>&lt;insert&gt;</command
> для повторювання інформації у декількох файлах <literal role="extension"
>.xml</literal
> (наприклад, інформації щодо автора, який брав участь у розробці декількох додатків). <link linkend="sect_similar_plugins"
>Докладніша інформація</link
>.</para
></note>
<tip
><para
>Вам не обов’язково писати увесь код XML вручну. Якщо ви скористаєтеся функцією <function
>rk.plugin.skeleton()</function
> з <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
> і вкажете у цій функції усі потрібні дані за допомогою параметра <parameter
>about</parameter
>, програма автоматично створить файл &pluginmap; із готовим розділом &lt;about&gt;.</para
></tip>
</chapter>

<chapter id="external_plugins">
<title
>Оприлюднення результатів вашої роботи</title>
<sect1 id="sect_external_plugins"
><title
>Зовнішні додатки</title>
	<para
>Починаючи з версії 0.5.5, у &rkward; передбачено зручний спосіб встановлення додаткових сторонніх додатків, які не належать до основного пакунка програми. Такі додатки називаються <quote
>зовнішніми додатками</quote
>. Вони постачаються у форматі пакунка &R;. Ними можна безпосередньо керувати за допомогою звичайних можливостей з керування пакунками &R; і/або за допомогою &rkward;. </para>
	<para
>У цьому розділі ви знайдете відомості щодо того, як слід пакувати зовнішні додатки, щоб &rkward; міг їх використовувати. Написання самого додатка є, звичайно ж, ідентичним до наведеного у попередніх розділах. Тобто, вам варто спочатку написати працездатний додаток, а вже потім повернутися до читання цього розділу, щоб дізнатися про те, як його можна поширити. </para>
	<para
>Оскільки зовнішні додатки є доволі новою можливістю, подробиці може бути змінено у наступних випусках. Ми будемо раді ознайомитися із вашими ідеями щодо покращення процесу. </para>
	<tip>
		<para
>У цій документації описано подробиці щодо роботи зовнішніх додатків. Окрім того, ви можете ознайомитися із можливостями <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>, який було створено для автоматизації рутинних дій з написання додатків. </para>
	</tip>
</sect1>
<sect1 id="why_external_plugins">
<title
>Навіщо створювати зовнішні додатки?</title>
	<para
>Кількість пакунків, які розширюють функціональні можливості &R; вже є величезною, і вона продовжує зростати. З одного боку, ми будемо раді, якщо ви писатимете додатки навіть для найбільш спеціалізованих завдань, які ви хочете розв’язати. З іншого боку, пересічний користувач не повинен мати справу зі величезними ієрархіями меню, повними невідомих йому статистичних термінів. Тому ми вважаємо, що підхід до роботи з додатками у &rkward; має бути таким самим модульним, як і у &R;. Команда розробників &rkward; має власне відкрите сховище пакунків за адресою <ulink url="https://files.kde.org/rkward/R/"
>https://files.kde.org/rkward/R/</ulink
>, призначене для зберігання наших зовнішніх додатків. </para>
	<para
>Як правило, додатки, які полегшують виконання широковживаних дій (наприклад t-перевірки) мають стати частиною основного пакунка програми, а ті додатки, які можуть знадобитися доволі обмеженій групі дослідників, які цікавляться вузькоспеціалізованими проблемами, слід постачати як додаткові пакунки. Для вас, як для автора додатків, найкраще розпочати з написання зовнішніх додатків. </para>
</sect1>
  
<sect1 id="structure_of_a_plugin_package">
<title
>Структура пакунка з додатком</title>
	<para
>Щоб зовнішні додатки можна було встановити належним чином, так, щоб вони працювали, їхня ієрархічна файлова структура має відповідати певним правилам. </para>
    
	<sect2 id="file_hierarchy"
><title
>Ієрархія файлів</title>
		<para
>Погляньмо на взірцеву ієрархію файлів у добре спланованому архіві додатка. Вам не обов’язково включати усі ці каталоги і/або файли, щоб додаток міг працювати (прочитайте цей підручник далі, щоб дізнатися про те, які з них є абсолютно необхідними), вважайте це прикладом «найліпшого підходу»: </para>
		<programlisting
>назва_додатка/
                inst/
                        rkward/
                                plugins/
                                        назва додатка.xml
                                        назва_додатка.js
                                        назва_додатка.rkh
                                        ...
                                po/
                                        ll/
                                                LC_MESSAGES/
                                                        rkward__назва_додатка_rkward.mo
                                        rkward__назва_додатка_rkward.ll.po
                                        rkward__назва_додатка_rkward.pot
                                tests/
                                        назва_набору_тестів/
                                                RKTestStandards.назва_якогось_тесту.rkcommands.R
                                                RKTestStandards.назва_якогось_тесту.rkout
                                                ...
                                        набір_тестів.R
                                назва_додатка.pluginmap
                                ...
        ChangeLog
        README
        AUTHORS
        LICENSE
        DESCRIPTION
                </programlisting>
		<note>
			<para
>У цьому прикладі усі записи <token
>назва_додатка</token
>, <token
>назва_набору_тестів</token
> та <token
>назва_якогось_тесту</token
> слід замінити відповідними назвами у вашому додатку. Крім того, записом <token
>ll</token
> позначено код мови (наприклад <quote
>de</quote
>, <quote
>en</quote
> або <quote
>es</quote
>). </para>
		</note>
		<tip>
			<para
>Вам не обов’язково створювати усю цю ієрархію файлів вручну. Якщо ви скористаєтеся функцією <function
>rk.plugin.skeleton()</function
> з <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>, програма сама автоматично створить для вас усі потрібні файли і каталоги, окрім каталогу <filename
>po</filename
>, який створюється і керується <link linkend="i18n_workflow"
>скриптом перекладу</link
>. </para>
		</tip>
		<sect3 id="basic_plugin_components">
		<title
>Базові компоненти додатка</title>
			<para
>Обов’язковим є включення трьох файлів: одного <link linkend="pluginmap"
>&pluginmap;</link
>, одного файла опису <link linkend="mainxml"
>.xml</link
> додатка і одного файла <link linkend="jstemplate"
>.js</link
> додатка. Іншими словами, навіть каталог «plugins» є необов’язковим. Він лише допомагає упорядковувати файли, особливо, якщо ви включаєте до архіву декілька додатків або діалогових вікон, що, звичайно ж, можна робити. Ви можете використовувати будь-яку бажану кількість каталогів для файлів додатків, достатньо лише, щоб вони відповідали <link linkend="pluginmap"
>&pluginmap;</link
>. Ви навіть можете включити декілька файлів &pluginmap;, якщо це відповідає вашим потребам, але тоді їх усі слід включити до файла <quote
>назва_додатка.pluginmap</quote
>. </para>
			<para
>У кожному пакунку &R; має бути коректний файл <filename
>DESCRIPTION</filename
>, який є критично важливим для розпізнавання &rkward; пакунка як пакунка, що містить додаток. Більша частина відомостей, що містяться у цьому файлі, також потрібна для <link linkend="chapter_about_information"
>метаданих</link
> пакунка і для визначення <link linkend="chapter_dependencies"
>залежностей</link
>, але у іншому форматі (докладний <ulink url="http://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file"
>опис файла <filename
>DESCRIPTION</filename
></ulink
> можна знайти у документації до &R;). </para>
			<para
>Окрім звичного вмісту, файл <filename
>DESCRIPTION</filename
> має також містити рядок <quote
>Enhances: rkward</quote
>. Додавання цього рядка підкаже &rkward;, що слід автоматично шукати додатки у пакунку, якщо його встановлено. Приклад файла <filename
>DESCRIPTION</filename
>: </para>
			<programlisting
>Package: SquaretheCircle
        Type: Package
        Title: Square the circle
        Version: 0.1-3
        Date: 2011-09-19
        Author: E.A. Dölle &lt;doelle@eternalwondermaths.example.org&gt;
        Maintainer: A. Assistant &lt;alterego@eternalwondermaths.example.org&gt;
        Enhances: rkward
        Description: Squares the circle using Heisenberg compensation.
        License: GPL
        LazyLoad: yes
        URL: http://eternalwondermaths.example.org/23/stc.html
        Authors@R: c(person(given="E.A.", family="Dölle", role="aut",
                        email="doelle@eternalwondermaths.example.org"),
                        person(given="A.", family="Assistant", role=c("cre",
                        "ctb"), email="alterego@eternalwondermaths.example.org"))
                        </programlisting>
			<tip>
				<para
>Вам не потрібно писати цей файл вручну. Якщо ви скористаєтеся функцією <function
>rk.plugin.skeleton()</function
> з <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
> і вкажете потрібні дані за допомогою параметра <quote
>about</quote
>, придатний до використання файл <filename
>DESCRIPTION</filename
> буде створено автоматично. </para>
			</tip>
		</sect3>
		<sect3 id="additional_information">
		<title
>Додаткові відомості (необов’язкові)</title>
			<para
>Призначення файлів <filename
>ChangeLog</filename
>, <filename
>README</filename
>, <filename
>AUTHORS</filename
>, <filename
>LICENSE</filename
> є очевидним з їхніх назв. Ці файли не є обов’язковими. Зокрема, вони не оброблятимуться &rkward;, отже, там зберігатимуться додаткові дані, які можуть знадобитися, наприклад, супровідникам пакунків для дистрибутивів. Більшість вмісту цих файлів (подяки авторам, умови ліцензування тощо) за будь-яких умов буде включено у файли самого додатка (див. <link linkend="chapter_about_information"
>розділ щодо метаінформації</link
>). Зауважте, що усі ці файли також можна розмістити десь у каталозі «inst», якщо ви хочете, щоб вони були не лише у архіві з початковими кодами додатків, але і у встановленому пакунку. </para>
		</sect3>
		<sect3 id="automated_plugin_testing">
		<title
>Автоматичне тестування додатка (обов’язкове)</title>
			<para
>Ще одним необов’язковим каталогом є каталог «tests». У цьому каталозі можуть міститися файли, потрібні для <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>автоматизованої системи тестування додатків</ulink
>. Такі тести корисні для пришвидшення визначення того, чи є ваші додатки працездатними у нових версіях &R; або &rkward;. Якщо ви маєте намір включити до пакунка тести, вам слід жорстко дотримуватися наведеної у цьому підручнику схеми найменувань та ієрархії. Тобто, ваші тести мають зберігатися у каталозі із назвою <filename
>tests</filename
>, у якому має бути файл <filename
>testsuite.R</filename
> і тека із стандартами тестів, назва якої має збігатися із назвою відповідного комплексу тестів. Якщо ви не хочете збирати усі тести до одного файла <filename
>testsuite.R</filename
>, ви можете поділити їх так, щоб на кожен комплекс тестів припадав один файл, і створити один <filename
>testsuite.R</filename
> із викликами <function
>source()</function
> для кожного з файлів комплексу. За будь-яких умов, створіть окремі підкаталоги із стандартами тестування для кожного визначеного комплексу. </para>
			<para
>Перевагою дотримання такої структури є те, що тестування додатка можна запустити простим викликом з додатковими аргументами функції <function
>rktests.makplugintests()</function
> з пакунка <ulink url="rkward://rhelp/rkwardtests"
>rkwardtests</ulink
>. Докладніший опис можна знайти у документації щодо <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>автоматичного тестування додатків</ulink
>. </para>
		</sect3>
	</sect2>
</sect1>
  
	<sect1 id="building_the_plugin_package">
		<title
>Збирання пакунка з додатком</title>
		<para
>Як ми вже пояснювали раніше, зовнішні додатки &rkward; є, по суті, пакунками &R;, і тому процедура пакування є ідентичною. На відміну від «справжніх» пакунків &R;, чистий пакунок додатка не містить коду &R; (хоча ви, звичайно ж, можете також додати додатки &rkward; до звичайний пакунків &R;, використовуючи ті самі методи, що і наведені у цьому підручнику). Це має ще більше спростити створення працездатного пакунка: достатньо мати коректний файл <filename
>DESCRIPTION</filename
> і дотримуватися ієрархічної структури файлів, описаної у <link linkend="structure_of_a_plugin_package"
>попередніх розділах</link
>.</para>
		<para
>Найпростішим способом збирання і тестування вашого додатка є використання команди <application
>R</application
> у командному рядку. Приклад:</para>
		<para
><userinput
><command
>R</command
> <option
>CMD build</option
> <parameter
><filename
>SquaretheCircle</filename
></parameter
> </userinput
></para>
		<para
><userinput
><command
>R</command
> <option
>CMD INSTALL</option
> <parameter
><filename
>SquaretheCircle_0.1-3.tar.gz</filename
></parameter
> </userinput
></para>
		<tip
><para
>Вам не обов’язково збирати пакунок у цей спосіб з командного рядка. Якщо ви скористаєтеся функцією <function
>rk.build.package()</function
> з <link linkend="rkwarddev"
>пакунка <application
>rkwarddev</application
></link
>, вона збере і/або виконає перевірку пакунка за вас.</para
></tip>
	</sect1>
</chapter>

<chapter id="rkwarddev">
	<title
>Розробка додатка за допомогою пакунка <application
>rkwarddev</application
></title>
	<sect1 id="rkdev_overview"
><title
>Огляд</title>
		<para
>Написання зовнішніх додатків включає створення файлів трьома мовами програмування (XML, JavaScript та R) та стандартизованої ієрархії каталогів. Щоб спростити процедуру для розробників додатків, нами створено пакунок <application
>rkwarddev</application
>. У цьому пакунку реалізовано декілька простих функцій &R; для створення початкових версій коду XML усіх елементів діалогових вікон, зокрема книг з вкладками, пунктів для позначок, спадних списків та панелей вибору файлів, а також функції для створення коду JavaScript та файлів довідки &rkward;. Функція <function
>rk.plugin.skeleton()</function
> створює відповідну ієрархію каталогів та усі потрібні файли там, де вони мають зберігатися.</para>
		<para
>Цей пакунок не встановлюється типово, але його можна встановити вручну із <ulink url="http://files.kde.org/rkward/R/"
>власного сховища &rkward;</ulink
>. Ви можете зробити це або за допомогою графічного інтерфейсу (<menuchoice
><guimenu
>Параметри</guimenu
><guimenuitem
>Налаштувати пакунки</guimenuitem
></menuchoice
>), або скористатися сеансом &R;:</para>
		<programlisting
>install.packages("rkwarddev", repos="https://files.kde.org/rkward/R")
                library(rkwarddev)
                </programlisting>
		<para
><application
>rkwarddev</application
> залежить від іншого невеличкого пакунка із назвою <quote
>XiMpLe</quote
>, який є дуже простим обробником і засобом створення коду XML і який також зберігається у тому самому сховищі пакунків.</para>
		<para
>Там же можна знайти повну <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev.pdf"
>документацію у форматі PDF</ulink
>. Докладніший вступ до роботи з цим пакунком можна знайти у <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev_vignette.pdf"
>короткому описі rkwarddev</ulink
>.</para>
	</sect1>

	<sect1 id="rkdev_example"
><title
>Практичний приклад</title>
		<para
>Щоб зрозуміти, що являє собою <quote
>безпосереднє написання додатка</quote
>, вам слід ознайомитися із попередніми розділами. Ми ж зараз створимо повноцінний додаток t-перевірки ще раз. Цього разу лише за допомогою функцій &R; пакунка <application
>rkwarddev</application
>.</para>

		<tip
><para
>Пакунок додасть нове діалогове вікно &rkward;, доступ до якого можна буде отримати за допомогою пункту меню <menuchoice
><guimenu
>Файл</guimenu
><guimenuitem
>Експортувати</guimenuitem
><guimenuitem
>Створити скрипт додатка &rkward;</guimenuitem
></menuchoice
>. Як можна здогадатися з назви пункту, за його допомогою ви зможете створити каркас скрипту додатка для його подальшого редагування. Відповідне діалогове вікно створюється скриптом <application
>rkwarddev</application
>, який ви можете знайти у каталозі <quote
>demo</quote
> встановленого пакунка, де зберігаються і коди пакунка, як додатковий приклад. Ви також можете запустити цей скрипт за допомогою команди <function
>demo("skeleton_dialog")</function
></para
></tip>

		<sect2 id="rkdev_gui"
><title
>Опис графічного інтерфейсу</title>
		<para
>Тут можна одразу помітити, що принципи роботи є суттєво іншими: замість безпосереднього написання коду XML вручну, ви починаєте не з визначення <command
>&lt;document&gt;</command
>, а безпосередньо з елементів додатка, які ви хочете бачити у діалоговому вікні. Ви можете пов’язати кожен елемент інтерфейсу, — поля для позначок, спадні меню, слоти для змінних або щось інше, — з окремими об’єктами &R;, а потім поєднати ці об’єкти із справжнім графічним інтерфейсом. У пакунку є функції для <link linkend="interfaceelements"
>кожного теґу XML</link
>, якими можна скористатися для визначення графічного інтерфейсу додатка. Більшість з цих функцій мають ті самі назви, що і елементи графічного інтерфейсу, лише додається префікс <function
>rk.XML.*</function
>. Наприклад, щоб визначити <command
>&lt;varselector&gt;</command
> і два елементи <command
>&lt;varslot&gt;</command
> для змінних <replaceable
>x</replaceable
> і <replaceable
>y</replaceable
> прикладу з t-перевіркою, слід написати такий код:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE, id.name="x")
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE, id.name="y")
                </programlisting>
		<para
>Найцікавішою деталлю, ймовірно, є визначення <parameter
>source=</parameter
><replaceable
>variables</replaceable
>: визначною можливістю пакунка є те, що усі функції здатні створювати ідентифікатори автоматично, отже, вам не треба буде вигадувати усі значення <parameter
>id</parameter
> і запам’ятовувати їх для використання у відповідному елементі додатка. Ви можете просто надати еталонні об’єкти &R;, оскільки усі функції, яким потрібен ідентифікатор якогось іншого елемента, також можуть прочитати їх з цих об’єктів. Функція <function
>rk.XML.varselector()</function
> має особливість: зазвичай, у ній немає специфічних елементів, на основі яких можна створити ідентифікатор (це можливо, лише якщо вами вказано мітку), тому доводиться встановлювати назву ідентифікатора. А ось <function
>rk.XML.varslot()</function
> не потрібні аргументи <parameter
>id.name</parameter
>, достатньо написати так:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
                </programlisting>
		<para
>Досі, для створення коду ми встановлювали усі ідентифікатори вручну. Але оскільки пакунок має полегшити наше життя, віднині ми більше цього не робитимемо.</para>
		<tip>
			<para
><application
>rkwarddev</application
> може автоматично виконувати значний обсяг роботи зі створення ваших додатків. Втім, іноді не варто використовувати усю його можливу потужність. Якщо вашою метою є написання коду, який не лише працюватиме, але і буде простим у читанні і порівнянні для інших програмістів, вам варто завжди створювати зручні для розуміння ідентифікатори за допомогою <parameter
>id.name</parameter
>. Іменування ваших об’єктів &R; ідентично до цих ідентифікаторів також допоможе у тому, щоб зробити код скрипту зрозумілішим. </para>
		</tip>
		<para
>Якщо ви хочете побачити, як виглядатиме код XML визначеного елемента, якщо ви експортуєте його до файла, ви можете просто викликати об’єкт за його назвою. Отже, якщо ви тепер виконаєте виклик <quote
>var.x</quote
> у вашому сеансі &R;, ви маєте побачити щось таке:</para>
		<programlisting
>&lt;varslot id="vrsl_compare" label="compare" source="vars" types="number" required="true" /&gt;
                </programlisting>
		<para
>Деякі теґи мають сенс лише у контексті інших теґів. Тому, наприклад, ви не знайдете функцій для теґу <command
>&lt;option&gt;</command
> tag. Замість цього, у списках варіантів і спадних списках пункти визначаються за допомогою <command
>&lt;option&gt;</command
> як іменовані списки, де назви відповідають міткам, які буде показано у діалоговому вікні, а значення є іменованим вектором з двох записів: <parameter
>val</parameter
> для значення пункту та булевого значення <parameter
>chk</parameter
>, яке визначає, чи буде пункт типово позначено.</para>
		<programlisting
>test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
        options=list(
                "Two-sided"=c(val="two.sided"),
                "First is greater"=c(val="greater"),
                "Second is greater"=c(val="less")
        )
)
                </programlisting>
		<para
>Результат виглядає десь так:</para>
		<programlisting
>&lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
        &lt;option label="Two-sided" value="two.sided" /&gt;
        &lt;option label="First is greater" value="greater" /&gt;
        &lt;option label="Second is greater" value="less" /&gt;
&lt;/radio&gt;
                </programlisting>
		<para
>На вкладці <quote
>Basic settings</quote
> не вистачає лише елемента поля для позначки для парних вибірок та упорядковування елементів за рядками і стовпчиками:</para>
		<programlisting
>check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))
                </programlisting>
		<para
><function
>rk.XML.cbox()</function
> є рідкісним виключенням, коли назва функції не містить повної назви теґу. Так зроблено, щоб трохи заощадити час на набиранні цього широковживаного елемента. Ось, що тепер міститиме <function
>basic.settings</function
>:</para>
		<programlisting
>&lt;row id="row_vTFSPP10TF"&gt;
        &lt;varselector id="vars" /&gt;
        &lt;column id="clm_vrsTFSPP10"&gt;
                &lt;varslot id="vrsl_compare" label="compare" source="vars" types="number" required="true" /&gt;
                &lt;varslot id="vrsl_against" label="against" i18n_context="compare against" source="vars" types="number" required="true" /&gt;
                &lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
                        &lt;option label="Two-sided" value="two.sided" /&gt;
                        &lt;option label="First is greater" value="greater" /&gt;
                        &lt;option label="Second is greater" value="less" /&gt;
                &lt;/radio&gt;
                &lt;checkbox id="chc_Pardsmpl" label="Paired sample" value="1" value_unchecked="0" /&gt;
        &lt;/column&gt;
&lt;/row&gt;
                </programlisting>
		<para
>У подібний же спосіб, наступні рядки створять об’єкти &R; для елементів вкладки <quote
>Options</quote
>, впровадивши функції для полів лічильника, рамок та розтягування:</para>
		<programlisting
>check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")
                </programlisting>
		<para
>Тепер нам залишилося лише об’єднати об’єкти у книгу з вкладками (tabbook), тобто додати таке у розділ dialog:</para>
		<programlisting
>full.dialog &lt;- rk.XML.dialog(
        label="Two Variable t-Test",
        rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
)
                </programlisting>
		<para
>Ми також можемо створити розділ майстра з його двома сторінками, використовуючи ті самі об’єкти, їхні ідентифікатори буде видобути з теґів <command
>&lt;copy&gt;</command
>:</para>
		<programlisting
>full.wizard &lt;- rk.XML.wizard(
                label="Two Variable t-Test",
                rk.XML.page(
                        rk.XML.text("As a first step, select the two variables you want to compare against
                                each other. And specify, which one you theorize to be greater. Select two-sided,
                                if your theory does not tell you, which variable is greater."),
                        rk.XML.copy(basic.settings)),
                rk.XML.page(
                        rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                variables have equal variances. An appropriate correction will be applied then.
                                Choosing \"assume equal variances\" may increase test-strength, however."),
                        rk.XML.copy(check.eqvar),
                        rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                the difference in means. Below you can specify whether one should be shown, and
                                which confidence-level should be applied (95% corresponds to a 5% level of
                                significance)."),
                        rk.XML.copy(conf.frame)))
                </programlisting>
		<para
>Ну ось і все з графічним інтерфейсом. Загальний документ буде зібрано у кінці за допомогою <function
>rk.plugin.skeleton()</function
>.</para>
		</sect2>

		<sect2 id="rkdev_jscode"
><title
>Код JavaScript</title>
			<para
>Досі, використання пакунка <application
>rkwarddev</application
> здавалося не дуже корисним. Давайте змінимо цю точку зору зараз же.</para>
			<para
>Перш за все, подібно до того, як ми не маємо дбати про ідентифікатори елементів, коли визначаємо компонування графічного інтерфейсу, нам не потрібно дбати про назви змінних JavaScript на наступному кроці. Якщо вам потрібні додаткові важелі керування, ви можете написати звичайний код JavaScript і вставити його до автоматично створеного файла. Але, ймовірно, найефективнішим способом все ж є використання <application
>rkwarddev</application
>.</para>
			<para
>Найпомітнішим є те, що вам не потрібно буде визначати жодну зі змінних власноруч, оскільки функція <function
>rk.plugin.skeleton()</function
> виконає сканування усього вашого коду XML і автоматично визначить усі потрібні вам змінні. Наприклад, вам не потрібно включати поле для позначки, якщо ви не використовуєте його значення або не встановлюєте його пізніше. Отже, ви зможете негайно розпочати написання дійсного коду JS для створення команд &R;.</para>
			<tip
><para
>Функція <function
>rk.JS.scan()</function
> також може шукати змінні у наявних файлах XML.</para
></tip>
			<para
>У пакунку є декілька функцій для конструктів коду JS code, які часто використовуються у додатках &rkward;, зокрема функція <function
>echo()</function
> та умови <function
>if() {...} else {...}</function
>. Між кодом JS і &R; є певні відмінності. Наприклад, у функції <function
>paste()</function
> &R; для з’єднання символьних рядків використовується кома, а у функції <function
>echo()</function
> JS слід з цією ж метою використовувати <quote
>+</quote
>; крім того рядки у JS слід завершувати крапкою з комою. Якщо ви використовуватимете функції &R;, ви зможете майже забути про ці відмінності і писати просто код мовою &R;.</para>
			<para
>Ці функції можуть отримувати різні класи вхідних об’єктів: звичайні текстові об’єкти, об’єкти &R; із кодом XML, як у наведеному вище прикладі, або результати виконання якихось інших функцій JS у пакунку. Наприкінці завжди слід викликати <function
>rk.paste.JS()</function
>, функцію, яка працює подібно до <function
>paste()</function
>, але, залежно від вхідних об’єктів, замінює їх на ідентифікатори XML, назви змінних JavaScript або навіть блоки коду JavaScript.</para>
			<para
>Для прикладу з t-перевіркою нам знадобляться два об’єкти JS: один для обчислення результатів і один для виведення цих результатів у функції <function
>printout()</function
>:</para>
		<programlisting
>JS.calc &lt;- rk.paste.JS(
        echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
        js(
                if(check.paired){
                        echo(", paired=TRUE")
                },
                if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                },
                if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                },
                linebreaks=TRUE
        ),
        echo(")\n"),
        level=2
)

JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)
                </programlisting>
		<para
>Як можна бачити, у <application
>rkwarddev</application
> передбачено реалізацію мовою &R; функції <function
>echo()</function
>. Ця функція повертає точно один рядок символів із коректною версією самої функції мовою JS. Також можна помітити, що усі об’єкти &R; тут є раніше створеними нами об’єктами. Їх буде автоматично замінено відповідними назвами змінних, отже, ніяких проблем із ускладненням розуміння коду бути не повинно. Якщо вам потрібна буде така заміна, ви можете скористатися функцією <function
>id()</function
>, яка також повертає точно один рядок із символів на основі усіх переданих їй об’єктів (можна сказати, що вона поводить себе подібно до <function
>paste()</function
> із дуже специфічним підставлянням об’єктів).</para>
    <para
>Функція <function
>js()</function
> є обгорткою, яка надає вам змогу використовувати умови &R; <command
>if(){...} else {...}</command
> у звичний спосіб. Такі інструкції буде безпосередньо трансльовано у код JS. Функція також зберігає деякі оператори, зокрема <command
>&lt;</command
>, <command
>&gt;=</command
> або <command
>||</command
>, отже ви зможете виконувати логічне порівняння ваших об’єктів &R; без потреби у взятті їх у лапки. Погляньмо на отриманий об’єкт <quote
>JS.calc</quote
>, у якому тепер зберігається рядок з таким вмістом:</para>
		<programlisting
>echo("res &lt;- t.test (x=" + vrslCompare + ", y=" + vrslAgainst + ", hypothesis=\"" + radUsngtsth + "\"");
        if(chcPardsmpl) {
                echo(", paired=TRUE");
        } else {}
        if(!chcPardsmpl &amp;&amp; chcAssmqlvr) {
                echo(", var.equal=TRUE");
        } else {}
        if(spnCnfdnclv != "0.95") {
                echo(", conf.level=" + spnCnfdnclv);
        } else {}
        echo(")\n");
                </programlisting>
    <note>
      <para
>Крім того, для умов <function
>if()</function
>, які вкладено до <function
>js()</function
>, ви можете скористатися функцією <function
>ite()</function
>, яка працює подібно до <function
>ifelse()</function
> у &R;. Втім, умови, побудовані за допомогою <function
>ite()</function
>, зазвичай важче читати, тому варто використовувати замість неї <function
>js()</function
> усюди, де це можливо. </para>
    </note>
		</sect2>

		<sect2 id="rkdev_pluginmap"
><title
>Карта додатка</title>
		<para
>Цей розділ буде дуже коротким: нам не потрібно взагалі писати &pluginmap;, оскільки ці дані може бути автоматично створено за допомогою <function
>rk.plugin.skeleton()</function
>. Ієрархію меню можна визначити за допомогою параметра <parameter
>pluginmap</parameter
>:</para>
			<programlisting
>[...]
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test"))
        [...]
                        </programlisting>
		</sect2>

		<sect2 id="rkdev_rkh"
><title
>Довідкова сторінка</title>
			<para
>Цей розділ теж дуже короткий: <function
>rk.plugin.skeleton()</function
> не зможе повністю написати довідку на основі отриманої інформації. Але ця функція може виконати сканування документа XML і виявити елементи, які, ймовірно, потребують належного документування. На основі списку таких елементів буде автоматично створено шаблон сторінки довідки для нашого додатка. Нам достатньо буде дописати декілька пояснювальних рядків для кожного із розділів цієї сторінки.</para>
			<tip
><para
>Функція <function
>rk.rkh.scan()</function
> також може шукати дані у наявних файлах XML для створення каркасу файла довідки.</para
></tip>
		</sect2>

		<sect2 id="rkdev_plugin_generator"
><title
>Створення файлів додатка</title>
			<para
>Нарешті, останній крок, на якому ми передамо усі створені об’єкти <function
>rk.plugin.skeleton()</function
>:</para>
			<programlisting
>plugin.dir &lt;- rk.plugin.skeleton("t-Test",
        xml=list(
                dialog=full.dialog,
                wizard=full.wizard),
        js=list(
                results.header="Two Variable t-Test",
                calculate=JS.calc,
                printout=JS.print),
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test")),
        load=TRUE,
        edit=TRUE,
        show=TRUE)
                        </programlisting>
			<para
>Типово, файли буде створено у тимчасовому каталозі. Останні три параметри не є обов’язковими, але значно спрощують роботу: <parameter
>load=</parameter
><replaceable
>TRUE</replaceable
> автоматично додасть новий додаток до налаштувань &rkward; (оскільки це тимчасовий каталог і, отже, його буде спорожнено після закриття &rkward;, запис додатка буде автоматично вилучено &rkward; під час наступного запуску програми), <parameter
>edit=</parameter
><replaceable
>TRUE</replaceable
> відкриє усі створені файли для редагування у вкладках редактора &rkward;, а <parameter
>show=</parameter
><replaceable
>TRUE</replaceable
> спробує безпосередньо запустити додаток, щоб ви могли ознайомитися з його виглядом навіть не клацаючи кнопкою миші. Ви також можете скористатися параметром <parameter
>overwrite=</parameter
><replaceable
>TRUE</replaceable
>, якщо ви запускаєте ваш скрипт повторно (наприклад, після змін у коді), оскільки типово після таких змін файли не перезаписуватимуться.</para>
			<para
>Об’єкт-результат <quote
>plugin.dir</quote
> містить шлях до каталогу, у якому було створено додаток. Він буде корисним у поєднанні з функцією <function
>rk.build.package()</function
>, для створення самого пакунка &R;, яким ви зможете поділитися з іншими користувачами, наприклад, надіслати його команді розробників &rkward; для додавання до нашого сховища додатків.</para>
		</sect2>
		<sect2 id="rkdev_ttest_script"
><title
>Скрипт повністю</title>
		<para
>Підсумовуючи усе сказане вище, наведемо скрипт для створення працездатного прикладу t-перевірки повністю. Окрім вже описаного коду, у скрипті містяться команди завантаження пакунка за запитом та використання середовища <function
>local()</function
>, щоб усі створені об’єкти не потрапили до вашого поточного робочого простору (окрім <quote
>plugin.dir</quote
>):</para>
		<programlisting
>require(rkwarddev)

local({
        variables &lt;- rk.XML.varselector(id.name="vars")
        var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
        var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
        test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
                options=list(
                        "Two-sided"=c(val="two.sided"),
                        "First is greater"=c(val="greater"),
                        "Second is greater"=c(val="less")
                )
        )
        check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
        basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))

        check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
        conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
        check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
        conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")

        full.dialog &lt;- rk.XML.dialog(
                label="Two Variable t-Test",
                rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
        )

        full.wizard &lt;- rk.XML.wizard(
                        label="Two Variable t-Test",
                        rk.XML.page(
                                rk.XML.text("As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater."),
                                rk.XML.copy(basic.settings)),
                        rk.XML.page(
                                rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing \"assume equal variances\" may increase test-strength, however."),
                                rk.XML.copy(check.eqvar),
                                rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance)."),
                                rk.XML.copy(conf.frame)))

        JS.calc &lt;- rk.paste.JS(
                echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
                js(
                        if(check.paired){
                        echo(", paired=TRUE")
                        },
                        if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                        },
                        if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                        },
                        linebreaks=TRUE
                ),
                echo(")\n"), level=2)

        JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)

        plugin.dir &lt;&lt;- rk.plugin.skeleton("t-Test",
                xml=list(
                        dialog=full.dialog,
                        wizard=full.wizard),
                js=list(
                        results.header="Two Variable t-Test",
                        calculate=JS.calc,
                        printout=JS.print),
                pluginmap=list(
                        name="Two Variable t-Test",
                        hierarchy=list("analysis", "means", "t-Test")),
                load=TRUE,
                edit=TRUE,
                show=TRUE,
                overwrite=TRUE)
})
                </programlisting>
		</sect2>

  </sect1>
  <sect1 id="rkwarddev_rkh"
><title
>Додавання сторінок довідки</title>
    <para
>Якщо ви хочете написати сторінку довідки для вашого додатка, найпростішим способом це зробити буде додавання певних інструкцій безпосередньо до визначень елементів XML: </para>
    <programlisting
>variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse.",
  component="Data"
)
    </programlisting>
    <para
>Текст, що передається параметру <parameter
>help</parameter
>, потім можна отримати за допомогою функції <function
>rk.rkh.scan()</function
> і записати до сторінки довідки компонента додатка. Втім, щоб це спрацювало з технічної точки зору, <function
>rk.rkh.scan()</function
> потрібно знати, які об’єкти &R; належать одному компоненту додатка. Ось чому вам слід вказати параметр <parameter
>component</parameter
> і переконатися, що він є однаковим для усіх об’єктів у межах одного компонента. </para>
    <para
>Оскільки у одному діалоговому вікні поєднується багато об’єктів, і у вас може виникнути бажання повторно використати об’єкти, подібні до <command
>&lt;varslot&gt;</command
>, у багатьох компонентах ваших додатків, передбачено можливість визначити компонент на загальному рівні за допомогою функції <function
>rk.set.comp()</function
>. Якщо такий компонент встановлено, припускається, що усі наступні об’єкти, використані у вашому скрипті, належать цьому компоненту, аж доки <function
>rk.set.comp()</function
> не буде викликано знову із іншою назвою компонента. Якщо використано цю функцію, ви можете пропустити параметр <parameter
>component</parameter
>: </para>
    <programlisting
>variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse.",
  component="Data"
)
    </programlisting>
    <para
>Щоб додати до сторінки довідки загальні розділи, зокрема <command
>&lt;summary&gt;</command
> або <command
>&lt;usage&gt;</command
>, скористайтеся відповідною функцією <function
>rk.rkh.summary()</function
> або<function
>rk.rkh.usage()</function
>. Результати роботи цих функцій потім використовуються для встановлення списку елементів, подібного до <parameter
>summary</parameter
> або <parameter
>usage</parameter
>, у параметрі <parameter
>rkh</parameter
> функції <function
>rk.plugin.component()</function
>/<function
>rk.plugin.skeleton()</function
>. </para>
	</sect1>
  <sect1 id="rkwarddev_i18n"
><title
>Переклад додатків</title>
    <para
>Пакунок <application
>rkwarddev</application
> здатний створювати зовнішні додатки з повною підтримкою інтернаціоналізації. Наприклад, усі відповідні функції на основі об’єктів XML матимуть додатковий параметр для визначення <replaceable
>контексту i18n</replaceable
> або <replaceable
>мітки непридатності до перекладу</replaceable
>: </para>
    <programlisting
>varComment &lt;- rk.XML.varselector(id.name="vars", i18n=list(comment="Main variable selector"))
varContext &lt;- rk.XML.varselector(id.name="vars", i18n=list(context="Main variable selector"))
cboxNoi18n &lt;- rk.XML.cbox(label="Power", id.name="power", i18n=FALSE)
    </programlisting>
    <para
>Наведені вище приклад дадуть десь такий результат:</para>
    <programlisting
># varComment
&lt;!-- i18n: Main variable selector --&gt;
  &lt;varselector id="vars" /&gt;

# varContext
&lt;varselector id="vars" i18n_context="Main variable selector" /&gt;

# cboxNoi18n
&lt;checkbox id="power" noi18n_label="Power" value="true" /&gt;
    </programlisting>
    <para
>Передбачено також підтримку перекладів у коді JS. Фактично, пакунок намагається типово додати виклики <function
>i18n()</function
> у місця, де це зазвичай є корисним. Добрим прикладом є функція <function
>rk.JS.header()</function
>: </para>
    <programlisting
>jsHeader &lt;- rk.JS.header("Test results")
    </programlisting>
    <para
>Це дасть нам такий код JS:</para>
    <programlisting
>new Header(i18n("Test results")).print();
    </programlisting>
    <para
>Втім, ви можете позначити рядки у вашому коді JS і вручну за допомогою функції <function
>i18n()</function
> так, як ви б це зробили, якби писали код файла JS з початку.</para>
  </sect1>
</chapter>

<appendix id="reference">
<title
>Довідник</title>

<sect1 id="propertytypes"
><title
>Типи властивостей/Модифікатори</title>
<para
>У деяких фрагмента цього вступу ми згадували <quote
>властивості</quote
> елементів графічного інтерфейсу або інших елементів. Фактично, існує декілька різних типів властивостей. Зазвичай, перейматися цим непотрібно, оскільки ви можете скористатися простим здоровим глуздом для з’єднування між собою властивостей. Втім, на внутрішньому рівні використовуються різні типи властивостей. Це має значення, коли ми отримуємо певні особливі значення у шаблоні JS. У інструкціях getString ("id")/getBoolean ("id")/getList ("id") ви також можете вказати якийсь із так званих <quote
>модифікаторів</quote
> ось так: <function
>getString ("id.модифікатор")</function
>. Цей модифікатор впливатиме на спосіб виведення значення. Ознайомтеся зі списком властивостей та ідентифікаторами, які можна використовувати з цими властивостями: </para>
<variablelist>
<varlistentry>
<term
>Рядкові властивості</term>
<listitem
><para
>Найпростіший тип властивості, використовується для зберігання текстового фрагмента. Модифікатори: <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Рядок, яким його визначено або встановлено.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>quoted</term>
	<listitem
><para
>Рядок у форматі з лапками (придатний для передавання &R; як символу).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Булеві властивості</term>
<listitem
><para
>Властивості, які можуть мати значення «on» («увімкнено») або «off» («вимкнено»), «true» («так») або «false» («ні»). Наприклад, властивості, створені теґами &lt;convert&gt;, також властивість, що супроводжує &lt;checkbox&gt; (див. нижче). Відповідно до вказаного модифікатора, буде повернуто такі значення: <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Типово властивість повертає значення 1, якщо має значення true, і 0, якщо має значення false. Рекомендованим способом отримання булевих значень є використання <function
>getBoolean()</function
>. Зауважте, що <function
>getString()</function
> поверне рядок «0», якщо властивість матиме значення false. Такий рядок вважатиметься у JS значенням true, а не false.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"labeled"</term>
	<listitem
><para
>Повертає рядок «true» якщо має значення «так», і «false», якщо має значення «ні», або будь-які вказані програмістом нетипові рядки (типово використовується у &lt;checkbox&gt;).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"true"</term>
	<listitem
><para
>Повертає рядок, так, наче властивість мала істинне значення, навіть якщо вона його не має</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"false"</term>
	<listitem
><para
>Повертає рядок, так, наче властивість не мала істинного значення, навіть якщо вона його має</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"not"</term>
	<listitem
><para
>Повертає обернене булеве значення властивості, протилежне до поточного (тобто «ні», якщо «так», і «так», якщо «ні»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"numeric"</term>
	<listitem
><para
>Застарілий, зберігається для зворотної сумісності. Те саме, що і модифікатор "". Повертає «1», якщо властивість має значення «так» (true), і «0», якщо властивість має значення «ні» (false).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Цілочисельні властивості</term>
<listitem
><para
>Властивість, яку створення для зберігання цілих значень (але, звичайно ж, вона повертатиме шаблону JS рядок із символів запису чисел). Вона не приймає будь-яких модифікаторів. Використовується у елементах &lt;spinbox&gt; (див. нижче).</para
></listitem>
</varlistentry>
<varlistentry>
<term
>Властивості, які мають дійсні значення</term>
<listitem
><para
>Властивість, яку створення для зберігання дійсних значень (але, звичайно ж, вона повертатиме шаблону JS рядок із символів запису чисел). Використовується у елементах &lt;spinbox&gt; (див. нижче). <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Для функцій <function
>getValue() / getString()</function
> повертає те саме, що і «formatted». У майбутніх версіях можна буде отримати числове представлення.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"formatted"</term>
	<listitem
><para
>Повертає форматоване число (як рядок).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Властивості RObject</term>
<listitem
><para
>Властивість, створена для вибору одного або декількох об’єктів &R;. Найчастіше використовується у varselector-ах та varslot-ах. Повернуто буде такі значення, відповідно до вказаного модифікатора: <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Типово властивість повертає повну назву вибраного об’єкта. Якщо вибрано декілька об’єктів, назви об’єктів буде відокремлено символами розриву рядка ("\n").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"shortname"</term>
	<listitem
><para
>Подібно до попереднього, але повертає лише скорочені назви об’єктів. Наприклад, для об’єкта у списку буде повернуто його назву всередині списку, без назви списку.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"label"</term>
	<listitem
><para
>Подібно до попереднього, але повертає мітки &rkward; об’єктів (якщо мітки немає, повертає те саме, що і shortname)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Властивості зі значеннями, які є списками рядків</term>
<listitem
><para
>Ця властивість містить список рядків. <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Для <function
>getValue()/getString()</function
>. Повертає усі рядки, відокремлені «\n». Усі символи «\n» у окремому записі буде екрановано як літерал «\n». Втім, рекомендованим способом отримання списків є функція <function
>getList()</function
>, яка повертає масив рядків.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"joined"</term>
	<listitem
><para
>Повертає список як єдиний рядок, пункти списку буде відокремлено у такому рядку символами «\n». На відміну від використання без модифікатора (""), вміст окремих рядків не екрануватиметься.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Властивості коду</term>
<listitem
><para
>Властивість, яку мають додатки, які створюють код &R;. Важлива для додатків, до яких вбудовуються інші додатки, власне для вбудовування коду, створеного вбудованим додатком до коду, який створено основним додатком (додатком верхнього рівня). Повертає такі значення, залежно від вказаного модифікатора: <variablelist>
	<varlistentry>
	<term
>Без модифікатора ("")</term>
	<listitem
><para
>Повертає код повністю, тобто розділи «preprocess», «calculate», «printout» (але не «preview»), з’єднані у один рядок.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preprocess"</term>
	<listitem
><para
>Повертає лише розділ preprocess коду</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"calculate"</term>
	<listitem
><para
>Повертає лише розділ calculate коду</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"printout"</term>
	<listitem
><para
>Повертає лише розділ printout коду</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preview"</term>
	<listitem
><para
>Повертає розділ preview коду</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="globalxmlelements">
	<title
>Елементи загального призначення, які можна використовувати у будь-якому файлі XML (<literal role="extension"
>.xml</literal
>, <literal role="extension"
>.rkh</literal
>, &pluginmap;)</title>
	<variablelist>
	<varlistentry>
	<term
>&lt;snippets&gt;</term>
	<listitem
><para
>Можна використовувати як безпосередній дочірній елемент вузла &lt;document&gt;, і лише як такий елемент. Має бути розміщено на початку файла. Див. <link linkend="snippets"
>розділ щодо використання фрагментів коду</link
>. У файлі може бути лише один елемент &lt;snippets&gt;. Необов’язковий, не має атрибутів.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;snippet&gt;</term>
	<listitem
><para
>Визначає окремий фрагмент. Можна використовувати лише як дочірній елемент елемента &lt;snippets/&gt;. Атрибути: <variablelist
> <varlistentry>
		<term
>&lt;id&gt;</term>
		<listitem
><para
>Рядок-ідентифікатор фрагмента. Є обов’язковим.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;insert&gt;</term>
	<listitem
><para
>Вставити вміст &lt;snippet&gt;. Можна використовувати усюди. Атрибути: <variablelist
> <varlistentry>
		<term
>&lt;snippet&gt;</term>
		<listitem
><para
>Ідентифікатор рядка фрагмента, який слід вставити. Є обов’язковим.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;include&gt;</term>
	<listitem
><para
>Включити вміст іншого файла XML (усі дані всередині елемента &lt;document&gt; у цьому файлі). Можна використовувати усюди. Атрибути: <variablelist
> <varlistentry>
		<term
>&lt;file&gt;</term>
		<listitem
><para
>Назва файла відносно каталогу, у якому зберігається поточний файл. Є обов’язковою.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	</variablelist>
</sect1>

<sect1 id="xmlelements"
><title
>Елементи, які буде використано у описі XML додатка.</title>
<para
>Властивості елементів наведено у <link linkend="elementproperties"
>окремому розділі</link
>.</para>

<sect2 id="generalelements"
><title
>Загальні елементи</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Має бути у будь-якому файлі description.xml як кореневий вузол. Не має спеціальних функцій. Не має атрибутів.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Відомості щодо цього додатка (автор, умови ліцензування тощо). Цей елемент можна використовувати у файлах <literal role="extension"
>.xml</literal
> окремих додатків та у файлах &pluginmap;. Докладний опис можна знайти у <link linkend="pluginmapelements"
>довіднику щодо файлів &pluginmap;</link
>, вступні зауваження — у <link linkend="chapter_about_information"
>розділі щодо даних «about»</link
>.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;code&gt;</term>
<listitem
><para
>Визначає, де шукати шаблон JS додатка. Можна використовувати у файлі лише один раз, як дочірній елемент теґу document. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Назва файла шаблона JS відносно каталогу, у якому зберігається файл .xml додатка.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;help&gt;</term>
<listitem
><para
>Визначає, де шукати файл довідки додатка. Можна використовувати у файлі лише один раз, як дочірній елемент теґу document. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Назва файла довідки відносно каталогу, у якому зберігається файл .xml додатка.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;copy&gt;</term>
<listitem
><para
>Можна використовувати як дочірню властивість (безпосередню або опосередковану) елементів основного компонування, тобто &lt;dialog&gt; та &lt;wizard&gt;. Використовується для буквального копіювання цілого блоку елементів xml. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор, який слід шукати. Теґ &lt;copy&gt; шукатиме попередній щодо нього елемент XML, якому надано той самий ідентифікатор і копіюватиме його разом із усіма підлеглими елементами.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>copy_element_tag_name</parameter
></term>
	<listitem
><para
>Іноді, у вас може виникнути потреба у майже буквальній копії, але зі зміною назви теґу елемента, який слід скопіювати. Найважливішим прикладом таких випадків є випадок, коли вам потрібно скопіювати вкладку &lt;tab&gt; з інтерфейсу діалогового вікна на сторінку &lt;page&gt; інтерфейсу майстра. У цьому випадку вам слід встановити copy_element_tag_name="page", щоб виконати перетворення автоматично.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="interfaceelements"
><title
>Визначення інтерфейсу</title>
<variablelist>
<varlistentry>
<term
>&lt;dialog&gt;</term>
<listitem
><para
>Визначає інтерфейс типу діалогового вікна. У цьому тезі ви маєте визначити графічний інтерфейс. Теґ можна використовувати лише один раз у одному файлі, як дочірній елемент теґу document. У додатку має бути принаймні один теґ «dialog» або «wizard». Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Надпис діалогового вікна</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>Визначає, чи має бути використано діалогове вікно як «рекомендований» інтерфейс (тобто інтерфейс, який буде типово показано, якщо користувач не налаштував &rkward; на використання визначеного ним інтерфейсу). Цей атрибут у поточній версії не використовується, оскільки неявним чином він має значення «true», якщо рекомендованим не визначено інтерфейс майстра.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;wizard&gt;</term>
<listitem
><para
>Визначає інтерфейс типу вікна майстра. У цьому тезі ви маєте визначити графічний інтерфейс. Теґ можна використовувати лише один раз у одному файлі, як дочірній елемент теґу document. У додатку має бути принаймні один теґ «dialog» або «wizard». Приймає як безпосередні дочірні елементи лише теґи &lt;page&gt; і &lt;. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Надпис майстра</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>Визначає, чи має бути використано вікно майстра як «рекомендований» інтерфейс (тобто інтерфейс, який буде типово показано, якщо користувач не налаштував &rkward; на використання визначеного ним інтерфейсу). Необов’язковий, типовим значенням є «false» («ні»).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="layoutelements"
><title
>Елементи компонування</title>
<para
>В усіх елемента з цього розділу можна використовувати атрибут id="рядок-ідентифікатор". Цей атрибут є необов’язковим для усіх елементів. Ним можна скористатися, наприклад, для приховування або вимикання цілого елемента компонування та усіх елементів, які у ньому містяться (див. <link linkend="logic"
>розділ щодо логіки графічного інтерфейсу</link
>). Рядок-ідентифікатор не повинен містити символів «.» (крапка) та «;» (крапка з комою), і, загалом, має складатися із літер латинської абетки, цифр та символів підкреслювання («_»). У списках атрибутів наведено лише необов’язкові атрибути.</para>
<variablelist>
<varlistentry>
<term
>&lt;page&gt;</term>
<listitem
><para
>Визначає нову сторінку у майстрі. Може використовуватися лише як дочірній елемент елемента &lt;wizard&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;row&gt;</term>
<listitem
><para
>Усі безпосередні дочірні елементи теґу «row» буде розташовано зліва праворуч.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;column&gt;</term>
<listitem
><para
>Усі безпосередні дочірні елементи теґу «column» буде розташовано згори вниз.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;stretch&gt;</term>
<listitem
><para
>Типово, елементи графічного інтерфейсу займатимуть увесь доступний простір. Наприклад, якщо у інтерфейсі є два стовпчика пунктів, і лівий з них заповнено пунктами, а у правому міститься лише один елемент <command
>&lt;radio&gt;</command
>, елемент <command
>&lt;radio&gt;</command
> буде розгорнуто вертикально, навіть якщо для цього не потрібне усе доступне місце. Це виглядатиме доволі потворно. Щоб уникнути таких проблем, потрібно додати «порожній» елемент під <command
>&lt;radio&gt;</command
>. Для цього використовують елемент &lt;stretch&gt;. Він просто займає місце. Не зловживайте ним, оскільки, зазвичай, графічні елементи найкраще виглядають, коли займають усе доступне місце. Лише іноді це призводить до проблем із компонуванням. Елемент &lt;stretch&gt; не приймає жодних аргументів, навіть «id». Крім того, не можна розташовувати дочірні елементи всередині елемента &lt;stretch&gt; (іншими словами, він використовується лише як «&lt;stretch/&gt;»).</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Малює рамку навколо свого безпосереднього дочірнього елемента. Може бути використаний для візуального групування пов’язаних параметрів. Компонування у рамці виконується згори вниз, якщо ви не вкажете всередині теґу &lt;row&gt;. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Надпис для фрейма (необов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>Рамки можна зробити придатними для позначення. Якщо у рамки є поле для позначки і воно порожнє (не позначено), усі елементи у рамці буде вимкнено аж доти, доки користувач не поставить у полі позначку. (Необов’язковий, типовим значенням є «false».)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Лише для рамок із позначками: визначає, чи має бути пункт рамки типово позначено. Типовим значенням є «true». Не обробляється для рамок без позначок.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tabbook&gt;</term>
<listitem
><para
>Збирає елементи у вікно з вкладками (tabbook). Як дочірні елементи можна використовувати лише елементи &lt;tab&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tab&gt;</term>
<listitem
><para
>Визначає сторінку у tabbook. Усередині цього елемента слід розташовувати визначення графічного інтерфейсу вкладки. Можна використовувати лише як безпосередній дочірній елемент теґу &lt;tabbook&gt;. У &lt;tabbook&gt; має бути принаймні дві визначені вкладки. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Надпис для сторінки із вкладками (обов’язковий)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Показує текст, розташований всередині цього теґу у графічному інтерфейсі. Передбачено підтримку простої розмітки у стилі HTML (зокрема <markup
>&lt;b&gt;</markup
>, <markup
>&lt;i&gt;</markup
>, <markup
>&lt;p&gt;</markup
> та <markup
>&lt;br/&gt;</markup
>). Будь ласка, не зловживайте форматуванням. За допомогою додавання порожнього рядка можна вручну почати новий абзац тексту. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Тип тексту. Одне зі значень: "normal", "warning" або "error". Впливає на вигляд тексту (необов’язковий, типовим є значення «normal»).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="activeelements"
><title
>Активні елементи</title>
<para
>Усім елементам у цьому розділі можна передавати атрибут id="рядок_ідентифікатора". Цей атрибут є обов’язковим для усіх елементів. Нижче наведено лише додаткові атрибути. Рядок ідентифікатора не повинен містить символів «.» (крапок).</para>
<variablelist>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Надає список доступних об’єктів, з який користувач може вибрати один або декілька. Для використання слід вказати всередині елемента один або декілька елементів &lt;varslot&gt;. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка varselector (необов’язкова, типовим є значення «Select variable(s)»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>Використовується у поєднанні з «varselector» для того, щоб вибрати одну або декілька змінних. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка для varslot (рекомендовано вказати, типовим значенням є «Variable:»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source</parameter
></term>
	<listitem
><para
>Елемент varselector, з якого слід отримувати варіанти вибору (обов’язковий, якщо немає з’єднування вручну або використання source_property).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source_property</parameter
></term>
	<listitem
><para
>Довільна властивість, з якої слід скопіювати значення, коли натиснуто кнопку вибору. Якщо вказано, перевизначає атрибут «source».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Визначає для надсилання коду, чи є обов’язковою наявність у varslot коректного значення. Див. <link linkend="elementproperties"
>документацію до властивості required</link
> (необов’язкова, типовим значенням є true).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>multi</parameter
></term>
	<listitem
><para
>Визначає, містить varslot лише один (типовий варіант, «false») чи декілька об’єктів.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_duplicates</parameter
></term>
	<listitem
><para
>Визначає, може varslot приймати лише унікальні об’єкти (типовий варіант, «false») чи той самий об’єкт може бути додано декілька разів.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars</parameter
></term>
	<listitem
><para
>Має значення, лише якщо multi="true": мінімальна кількість змінних, які має бути позначено, щоб позначення вважалося коректним (необов’язковий, типовим значенням є 1).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars_if_any</parameter
></term>
	<listitem
><para
>Має значення, лише якщо multi="true": деякі varslot-и можуть вважатися коректними, якщо, наприклад, varslot є порожнім або містить принаймні два значення. Цей атрибут визначає, скільки змінних має бути позначено, якщо змінні позначено (2 у нашому прикладі). (необов’язковий, типовим значенням є «1»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_vars</parameter
></term>
	<listitem
><para
>Має значення, лише якщо multi="true": максимальна кількість змінних, які може бути позначено (необов’язковий, типовим значенням є 0, що означає, що максимальну кількість не обмежено).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>класи</parameter
></term>
	<listitem
><para
>Якщо у цьому атрибуті ви вкажете одну або декілька назв класів &R; (відокремлених пробілами (« »)), varslot прийматиме лише об’єкти, що належать цим класам (необов’язковий, <emphasis
>користуйтеся дуже обережно</emphasis
>, не можна забороняти користувачеві вибирати коректні варіанти, а у &R; є <emphasis
>багато</emphasis
> різних класів!)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>types</parameter
></term>
	<listitem
><para
>Якщо у цьому атрибуті ви вкажете один або декілька типів змінних (відокремлених пробілами (" ")), varslot прийматиме лише об’єкти вказаних типів. Коректними вважаються такі типи: «unknown», «number», «string», «factor», «invalid». (необов’язковий, <emphasis
>користуйтеся дуже обережно</emphasis
> — не можна забороняти користувачеві вибирати коректні варіанти, а &rkward; не завжди може визначити тип змінної)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>num_dimensions</parameter
></term>
	<listitem
><para
>Кількість розмірностей, які повинен мати об’єкт. «0» (типове значення) означає, що прийнятними є усі розмірності. (Необов’язкова, типовим значенням є «0»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_length</parameter
></term>
	<listitem
><para
>Мінімальна довжина, яку повинен мати об’єкт, щоб бути прийнятним. (Необов’язкова, типовим є значення «0»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_length</parameter
></term>
	<listitem
><para
>Максимальна довжина, яку повинен мати об’єкт для того, щоб бути прийнятним. (Необов’язкова, типовим є значення найбільшого цілого числа, яке може бути представлене операційною системою)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Містить список доступних рядків (не об’єктів &R;), які можна вибрати у одному або декількох пов’язаних &lt;valueslot&gt;. Пункти рядків можна визначити за допомогою безпосередніх дочірніх теґів &lt;option&gt; (див. нижче) або встановити за допомогою динамічних <link linkend="elementproperties"
>властивостей</link
>. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка для поля вибору значень (необов’язкова, типово мітки не буде)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Використовується у поєднанні з &lt;valueselector&gt; для уможливлення вибору користувачем одного або декількох рядкових пунктів. Цей елемент здебільшого ідентичний до &lt;varslot&gt; і має ті самі атрибути, окрім тих, що відповідають властивостям прийнятних пунктів (тобто classes, types, num_dimensions, min_length, max_length).</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Визначає групу взаємовиключних кнопок-варіантів (одночасно позначено може бути лише один пункт варіанта). Потребує принаймні два безпосередніх дочірніх теґи &lt;option&gt;. Інші теґи не можуть бути дочірніми теґами radio. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка для поля вибору з варіантів (рекомендовано вказати, типовою є «Select one:»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Визначає групу пунктів, серед яких можна вибрати один і лише один за допомогою спадного списку. Функціонально еквівалентний до &lt;radio&gt;, але виглядає інакше. Потребує визначення принаймні двох безпосередніх дочірніх теґів &lt;option&gt;. Інші дочірні теґи використовувати не можна. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка для спадного списку (рекомендовано вказати, типовою є «Select one:»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Містить список доступних рядків з яких користувач може вибрати довільну кількість рядків. Пункти рядків можна визначити за допомогою безпосередніх дочірніх теґів &lt;option&gt; (див. нижче) або встановити за допомогою динамічних <link linkend="elementproperties"
>властивостей</link
>. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка для &lt;select&gt; (необов’язкова, типово її не буде)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>single</parameter
></term>
	<listitem
><para
>Якщо встановлено значення «true», вибрати можна буде лише одне значення, а не декілька значень одразу (булевий параметр, типове значення — «false»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Можна використовувати лише як безпосередній дочірній теґ елемента &lt;radio&gt;, &lt;dropdown&gt;, &lt;valueselector&gt; або &lt;select&gt;. Відповідає одному придатному для вибору пункту у списку вибору з варіантів або спадному списку. Оскільки елементи &lt;option&gt; завжди є частиною списку елементів, зазвичай, у них немає власного ідентифікатора (атрибута «id»), але можливі варіанти і з таким атрибутом (див. нижче). Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка варіанта (обов’язкова)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>Рядкове значення, яке повертатиме батьківський елемент, якщо пункт буде позначено або вибрано (обов’язкове)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Визначає, чи має бути типово позначено пункт, «true» або «false». У &lt;radio&gt; і &lt;dropdown&gt; значення <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
> може бути використано лише для одного пункту. Якщо для жодного пункту не встановлено «checked», автоматично буде позначено перший пункт у батьківському елементі. У &lt;select&gt; може бути встановлено значення «checked» для довільної кількості пунктів. (необов’язкове, типовим значенням є «false»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Визначення параметра «id» для елементів &lt;option&gt; є необов’язковим (фактично, не рекомендуємо вам встановлювати «id», якщо у цьому немає нагальної потреби). Втім, визначення «id» надасть вам змогу вмикати або вимикати &lt;option&gt; у динамічному режимі, встановивши з’єднання із булевою властивістю <replaceable
>ідентифікатор_radio.ідентифікаор_пунктуX.enabled</replaceable
>. У поточній версії програми це працює лише у елементах &lt;radio&gt; і &lt;dropdown&gt;; для пунктів &lt;valueselector&gt; і &lt;select&gt; підтримки ідентифікаторів для пунктів не передбачено.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Визначає пункт для позначки, тобто однозначну відповідь (так чи ні) на певне питання, яку дають позначенням пункту або зняттям з нього позначки. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка поля для позначки (обов’язкова)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>Значення, яке повертатиме пункт для позначки, якщо його позначено (обов’язкове)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value_unchecked</parameter
></term>
	<listitem
><para
>Значення, яке буде повернуто, якщо пункт для позначки не позначено (необов’язкове, типовим є "", тобто порожній рядок)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Визначає, чи має бути пункт типово позначено, «true» (так) чи «false» (необов’язкова, типовим є значення «false»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Елемент рамки, загалом, використовується як суто елемент компонування. Його опис розміщено у розділі щодо <link linkend="layoutelements"
>елементів компонування</link
>. Втім, його можна також зробити придатним для позначення, щоб він працював як звичайний пункт для позначки. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Визначає поле для введення довільного тексту. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка поля введення (обов’язкова)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Початковий текст у полі (необов’язковий, типовим значенням є «», тобто порожній рядок)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>size</parameter
></term>
	<listitem
><para
>Одне з таких значень: «small» (малий), «medium» (середній) та «large» (великий). «large» визначає багаторядкове поле для введення, «small» і «medium» — однорядкові (необов’язковий, типовим є значення «medium»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Визначає для надсилання коду, чи є обов’язковим заповнення цього поля. Див. <link linkend="elementproperties"
>документацію до властивості required</link
> (необов’язкова, типовим значенням є true).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;matrix&gt;</term>
<listitem
><para
>Таблиця для введення даних матриць (або векторів) у форматі графічного інтерфейсу.</para
> <note
><para
>Цей елемент введення даних <emphasis
>не оптимізовано</emphasis
> для редагування великих масивів даних. Хоча немає строгих обмежень щодо розміру &lt;matrix&gt;, загалом, розмірності не повинні перевищувати десять рядків на десять стовпчиків. Якщо вам потрібен більший масив даних, дозвольте користувачам вибирати його як об’єкт &R; (цим варто скористатися як альтернативним варіантом майже <emphasis
>всюди</emphasis
>, де використовуються матриці).</para
></note
> <para
>Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка таблиці (обов’язкова)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Одне зі значень, «integer», «real» або «string». Тип даних, які будуть прийнятними для таблиці (обов’язковий).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Мінімальне прийнятне значення (для матриць типу «integer» або «real») (необов’язкове, типовим значенням є найменше придатне для представлення число)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Максимальне прийнятне значення (для матриць типу «integer» або «real») (необов’язкове, типовим значенням є найбільше придатне для представлення число)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_missings</parameter
></term>
	<listitem
><para
>Визначає, чи можна використовувати пропуски (порожні значення) у матриці. Використовується у матрицях з рядкових значень або у режимі «string» (необов’язковий параметр, типовим є значення «false» або не можна).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_columns</parameter
></term>
	<listitem
><para
>Якщо встановлено значення «true», користувач може додавати стовпчики введенням значень у найправіші (неактивні) комірки (необов’язковий параметр, типовим значенням є «true» або може).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_rows</parameter
></term>
	<listitem
><para
>Якщо встановлено значення «true», користувач може додавати рядки введенням значень у найнижчі (неактивні) комірки (необов’язковий параметр, типовим значенням є «true» або може).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>rows</parameter
></term>
	<listitem
><para
>Кількість рядків у матриці. Не працює, якщо allow_user_resize_rows="true". <note
><para
>Цим значенням можна керувати за допомогою властивості "rows".</para
></note
> (Необов’язковий параметр, типовим є значення 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>columns</parameter
></term>
	<listitem
><para
>Кількість стовпчиків у матриці. Не працює, якщо allow_user_resize_columns="true". <note
><para
>Цим значенням можна керувати за допомогою властивості "columns".</para
></note
> (Необов’язковий параметр, типовим є значення 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Мінімальна кількість рядків у матриці. Матрицю не можна буде стиснути до розміру, який є меншим за це значення. (Необов’язковий параметр, типовим є значення 0; див. також <parameter
>allow_missings</parameter
>.)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_columns</parameter
></term>
	<listitem
><para
>Мінімальна кількість стовпчиків у матриці. Матрицю не можна буде стиснути до розміру, який є меншим за це значення. (Необов’язковий параметр, типовим є значення 0; див. також <parameter
>allow_missings</parameter
>.)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_height</parameter
></term>
	<listitem
><para
>Примусово встановити для елемента графічного інтерфейсу його початкову висоту. Не використовуйте у поєднанні з матрицями, у яких у якийсь спосіб може змінитися кількість рядків. Особливо корисно, якщо створюються елементи введення векторів (columns="1"). Якщо для цього параметра встановлено значення «true», програма не показуватиме горизонтальної смужки гортання, навіть якщо матриця буде ширшою за доступну у вікні ширину (оскільки це впливатиме на висоту). (необов’язкова, типовим значенням є «false»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_width</parameter
></term>
	<listitem
><para
>Трохи оманлива назва: припустімо, що кількість стовпчиків не зміниться. Останній (або типово єдиний) стовпчик буде розтягнуто так, щоб він зайняв усю доступну ширину. Не використовуйте у поєднанні з матрицями, де кількість рядків може змінитися. Особливо корисно під час створення елементів введення векторів (rows="1"). (необов’язкова, типовим значенням є «false»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>horiz_headers</parameter
></term>
	<listitem
><para
>Рядки, які слід використовувати для горизонтального заголовка, відокремлені символом «;». Якщо встановити значення "", заголовок буде приховано. (Необов’язковий параметр, типовим значенням є номер стовпчика).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>vert_headers</parameter
></term>
	<listitem
><para
>Рядки, які слід використовувати для вертикального заголовка, відокремлені символом «;». Якщо встановити значення "", заголовок буде приховано. (Необов’язковий параметр, типовим значенням є номер рядка).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;optionset&gt;</term>
<listitem
><para
>Інтерфейс користувача для повторення набору параметрів для довільної кількості елементів (<link linkend="optionset"
>вступ до наборів параметрів</link
>). Атрибути:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Якщо вказано, набір буде позначено як некоректний, якщо у ньому менше вказаної кількості рядків (необов’язковий атрибут, ціле число).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows_if_any</parameter
></term>
	<listitem
><para
>Подібний до min_rows, але перевірка щодо нього виконуватиметься, лише якщо існує принаймні один рядок (необов’язковий атрибути, ціле число).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_rows</parameter
></term>
	<listitem
><para
>Якщо вказано, набір буде позначено як некоректний, якщо у ньому більше вказаної кількості рядків (необов’язковий атрибут, ціле число).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>keycolumn</parameter
></term>
	<listitem
><para
>Ідентифікатор стовпчика, який працюватиме як keycolumn. optionset із (коректним) keycolumn працюватиме як «керований» optionset. optionset без keycolumn надаватиме змогу вручну вставляти або вилучати записи. keycolumn має бути позначено як зовнішній (необов’язковий, типовою є відсутність keycolumn).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Дочірні елементи:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;optioncolumn&gt;</term>
	<listitem
><para
>Оголошує один елемент optioncolumn набору. Для кожного значення, яке ви хочете отримати з optionset вам слід оголосити окремий елемент &lt;optioncolumn&gt;. Атрибути: <variablelist>
			<varlistentry
><term
><parameter
>id</parameter
></term>
			<listitem
><para
>Ідентифікатор optioncolumn (обов’язковий атрибут, рядок).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>external</parameter
></term>
			<listitem
><para
>Встановіть значення true (так), якщо optioncolumn керується з-поза меж optionset (необов’язкова, булева, типовим значенням є false).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>label</parameter
></term>
			<listitem
><para
>Якщо вказано, optioncolumn буде показано у стовпчику з цією міткою (необов’язковий, рядок, типово не показано).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>connect</parameter
></term>
			<listitem
><para
>Властивість, з якою слід з’єднати цей optioncolumn, задана як ідентифікатор у області &lt;content&gt;. Для зовнішніх &lt;optioncolumn&gt; відповідне значення буде встановлено у зовнішньо встановлене значення. Для звичайних (не зовнішніх) &lt;optioncolumn&gt; буде встановлено значення відповідного рядка властивості &lt;optioncolumn&gt;, якщо властивість змінюється у області вмісту. (необов’язкова, рядкова, типове значення — «не з’єднано»).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>default</parameter
></term>
			<listitem
><para
>Лише для зовнішніх стовпчиків: значення, яке є типовим для цього стовпчика, якщо значення у комірці немає. Використання є рідкісним. (необов’язкова, типовим значенням є порожній рядок)</para
></listitem
></varlistentry>
		</variablelist>
	</para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;content&gt;</term>
	<listitem
><para
>Оголошує вміст або графічний інтерфейс набору. Не має атрибутів. Як дочірні елементи можна використовувати усі звичайні активні, пасивні елементи та елементи компонування. Крім того, у ранніх версіях &rkward; (аж до 0.6.3) можна було використовувати спеціальний дочірній елемент <command
>&lt;optiondisplay&gt;</command
>. Цей елемент вважається застарілим з часу &rkward; 0.6.4, його слід просто вилучити з наявних додатків. </para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;logic&gt;</term>
	<listitem
><para
>Додаткова специфікація логіки інтерфейсу, яку слід застосувати <emphasis
>всередині</emphasis
> області вмісту optionset. Див. <link linkend="logicelements"
>довідкові матеріали щодо &lt;logic&gt;</link
> </para
></listitem
></varlistentry>
	</variablelist>
</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Елемент призначено для вибору одної назви файла (або назви каталогу). Зауважте, що це поле приймає будь-який рядок, хоча його призначено лише для назв файлів: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка вікна вибору файла (необов’язкова, типовим значенням є «Enter filename»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Початковий текст у засобі вибору файлів (необов’язковий, типовим значенням є «», тобто порожній рядок)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Одне зі значень: "file", "dir" або "savefile". Щоб вибрати наявний файл, наявний каталог або файл, якого не існує, відповідно (необов’язковий аргумент, типовим значенням є "file")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_urls</parameter
></term>
	<listitem
><para
>Визначає, чи можна вибирати (нелокальні) адреси (необов’язковий аргумент, типовим є значення "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>filter</parameter
></term>
	<listitem
><para
>Фільтр типу файлів, наприклад ("*.txt *.csv" для файлів .txt і .csv). Автоматично буде додано запис "All files" (усі файли) (необов’язкова, типовим значенням є "", тобто «усі файли»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Визначає для полів надсилання коду, чи обов’язково поле має бути заповнено. Зауважте, що це не обов’язково значить, що назва файла є коректною! Див. <link linkend="elementproperties"
>документацію щодо властивості required</link
> (необов’язкова, типовим значенням є true).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Елемент призначено для вибору назви об’єкта &R; для збереження даних (тобто об’єкта, якого, загалом, ще не існує, на відміну від varslot): <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка поля введення (необов’язкова, типовим є значення «Save to:»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Початковий текст у полі введення (необов’язковий, типовим значенням є «my.data»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Визначає для надсилання коду, чи є обов’язковою наявність у полі прийнятної назви об’єкта. Див. <link linkend="elementproperties"
>документацію до властивості required</link
> (необов’язкова, типовим значенням є true).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>У багатьох випадках збереження до об’єкта &R; є необов’язковим. У таких випадках поле для позначки можна інтегрувати до елемента saveobject за допомогою цього атрибута. Якщо для нього встановлено значення true, saveobject буде активовано або деактивовано цим полем для позначки. Див. <link linkend="elementproperties"
>документацію щодо властивості active</link
> saveobject (необов’язковий, типовим значенням є false).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Лише для saveobject з позначкою: визначає, чи буде пункт позначено типово (необов’язковий, типовим значенням є false (не позначено))</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Поле лічильника, у яке користувач може або безпосередньо ввести числове значення, або скористатися для того, щоб вказати значення, маленькими стрілочками вгору і вниз ліворуч від поля значення. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка поля лічильника (рекомендуємо вказати, типовим значенням є «Enter value:»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Найменше значення, яке користувач має право ввести до поля лічильника (необов’язкове, типовим значенням є найменше значення, яке технічно може бути показано у полі лічильника).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Найбільше значення, яке користувач має право ввести до поля лічильника (необов’язкове, типовим значенням є найбільше значення, яке технічно може бути показано у полі лічильника).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Початкове значення, яке буде показано у полі лічильника (необов’язкове, типовим значенням є «0»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Одне зі значень: "real" або "integer". Визначає, можна у полі лічильника вказувати дійсні числа чи лише цілі (необов’язковий аргумент, типовим значенням є "real")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default_precision</parameter
></term>
	<listitem
><para
>Має значення, лише якщо поле лічильника належить до типу «real». Впливає на кількість десяткових цифр, які може бути показано у полі лічильника (саме цю кількість кінцевих нулів буде показано). Після натискання користувачем кнопочки зі стрілкою вгору або вниз, ці десяткові знаки буде змінено. Втім, користувач може вручну ввести і значення із вищою точністю (див. нижче) (необов’язковий, типовим є значення «2»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_precision</parameter
></term>
	<listitem
><para
>Максимальна кількість цифр, які може бути введено (необов’язковий аргумент, типовим є значення «8»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>За допомогою цього елемента із розширеними можливостями користувач може вибрати формулу або набір взаємодій на основі вибраних змінних. Наприклад, для узагальненої лінійної моделі користувач може вказати елементи взаємодії у моделі. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>fixed_factors</parameter
></term>
	<listitem
><para
>Ідентифікатор varslot, що містить вибрані фіксовані фактори (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dependent</parameter
></term>
	<listitem
><para
>Ідентифікатор varslot, що містить вибрану залежну змінну (обов’язковий)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Вбудовування іншого додатка у поточний (див <link linkend="embedding"
>розділу щодо вбудовування</link
>). Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>component</parameter
></term>
	<listitem
><para
>Зареєстрована назва компонента для вбудовування (див. <link linkend="pluginmap"
>розділ щодо реєстрування компонентів</link
>) (обов’язкова)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>as_button</parameter
></term>
	<listitem
><para
>Якщо встановлено значення «true», у графічному інтерфейсі, до якого вбудовується графічний інтерфейс, буде показано лише кнопку, натискання якої відкриватиме (у окремому вікні) вбудований інтерфейс (необов’язковий, типовим значенням є «false»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Має значення, лише якщо as_button="true": мітка кнопки (рекомендуємо вказати, типовою є мітка "Options")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Поле для позначки для вмикання або вимикання функціональної можливості попереднього перегляду. Зауважте, що починаючи з версії 0.6.5 &rkward; елементи попереднього перегляду, <command
>&lt;preview&gt;</command
>, виокремлюються у діалогових вікнах додатків (не майстрів): вони розташовуються у стовпчику з кнопками, незалежно від того, де їх було визначено у описі графічного інтерфейсу. Втім, варто визначати їх у відповідному місці компонування з міркувань зворотної сумісності. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка панелі (необов’язкова, типовим є значення "Preview")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Тип попереднього перегляду. Підтримувані типи: «plot» (див. <link linkend="preview_plots"
>розділ щодо попереднього перегляду графіків</link
>), «output» (див. <link linkend="preview_output"
>розділ щодо попереднього перегляду виведених даних (HTML)</link
>), «data» (див. <link linkend="preview_data"
>розділ щодо попереднього перегляду даних</link
>) і «custom» (див. <link linkend="preview_custom"
>розділ щодо нетипових попередніх переглядів</link
>) (необов’язковий, типовим є тип «plot»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>placement</parameter
></term>
	<listitem
><para
>Розташування області попереднього перегляду: «attached» (у основній робочій області), «detached» (у окремому вікні), «docked» (у діалоговому вікні додатка) і «default» (у поточній версії те саме, що і «docked», але може стати чимось визначеним користувачем у майбутньому). Загалом, рекомендуємо лишити типовий варіант з міркувань збереження однорідності графічного інтерфейсу (необов’язковий, типовим є значення «default»).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>active</parameter
></term>
	<listitem
><para
>Визначає, чи буде панель попереднього перегляду типово активною. Загалом, типово варто робити активними лише панелі попереднього перегляду у вікні додатка (docked), і навіть для цих панелей є причина не робити їх активними (необов’язковий, типовим значенням є «false»).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="logicelements"
><title
>Розділ логіки</title>
<variablelist>
<varlistentry>
<term
>&lt;logic&gt;</term>
<listitem
><para
>Елемент, що визначає розділ «logic». Усі наведені нижче елементи можна використовувати лише всередині елемента &lt;logic&gt;. Елемент &lt;logic&gt; можна використовувати лише як безпосередній дочірній елемент елемента &lt;document&gt; (не більше одного на документ) або елемента &lt;optionset&gt; (не більше одного на optionset). Розділ logic документа одночасно стосується графічних інтерфейсів &lt;dialog&gt; і &lt;wizard&gt;.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;external&gt;</term>
<listitem
><para
>Створює (рядкову) властивість, яка призначається для з’єднування із зовнішньою властивістю, якщо додаток вбудовують. Див. <link linkend="embedding_incomplete"
>розділ щодо «незавершених» додатків</link
>. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор нової властивості (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default</parameter
></term>
	<listitem
><para
>Типове рядкове значення нової властивості, тобто значення, яке використовується, якщо властивість не з’єднано із зовнішньою властивість (необов’язкове, типовим значенням є порожній рядок).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;i18n&gt;</term>
<listitem
><para
>Створює нову (рядкову) властивість, яка має забезпечувати роботу придатної до перекладу мітки. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор нової властивості (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Мітка. Її можна буде перекладати. (обов’язкова)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;set&gt;</term>
<listitem
><para
>Встановлює для властивості фіксоване значення (звичайно ж, якщо ви додатково з’єднаєте властивість із якоюсь іншою властивістю, значення не залишатиметься фіксованим). Наприклад, якщо вами вбудовано додаток, але ви хочете приховати якісь з його елементів, ви можете встановити для властивості «visibility» цих елементів значення «false». Це особливо корисно для вбудованих додатків та додатків, до яких відбувається вбудовування. Зауваження: якщо для одного <parameter
>id</parameter
> вказано декілька &lt;set&gt;, пріоритет матиме останнє з визначень. Це іноді буває корисним, якщо використовуються фрагменти коду за допомогою &lt;include&gt;. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор властивості для встановлення (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>to</parameter
></term>
	<listitem
><para
>Рядкове значення, яке слід встановити для властивості to (обов’язкове). Зауваження: для булевих властивостей, зокрема видимості, увімкненості, вам типово слід встановити для атрибута або to="true" або to="false".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Створити нові булеві властивості, які залежать від стану однією або декількох різних властивостей. Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор нової властивості (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>sources</parameter
></term>
	<listitem
><para
>Ідентифікатори властивостей, від яких залежатиме ця властивість. Можна вказати одну властивість або декілька властивостей, відокремлених крапками з комами, «;» (обов’язковий).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Режим перетворення або дії. Одне з таких значень: «equals», «notequals», «range», «and», «or». У режимі equals властивість матиме значення «true», лише якщо значення обох операндів дорівнюють атрибуту «standard» (див. нижче). У режимі notequals властивість матиме значення «true», лише якщо значення усіх операндів буде відмінним від атрибута «standard» (див. нижче). У режимі «range» усі операнди мають бути числовими (цілими або дійсними значеннями). Властивість матиме значення «true», лише якщо усі операнди належатимуть діапазону, що визначається атрибутами min і max (див. нижче). У режимі «and» операнди мають бути булевими властивостями. Властивість-результат матиме значення «true», лише якщо усі операнди одночасно дорівнюють «true». У режимі «or» усі операнди мають бути булевими властивостями. Властивість-результат матиме значення «true», якщо принаймні один з операндів матиме значення «true». (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Має значення лише у режимах equals або notequals: рядкове значення з яким слід виконати порівняння (обов’язковий, якщо використано один з цих режимів).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Має значення лише у режимі range: мінімальне значення, з яким слід виконувати порівняння (необов’язкове, типовим є найменше число із рухомою крапкою, яке може бути представлено на комп’ютері).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Має значення лише у режимі range: максимальне значення, з яким слід виконувати порівняння (необов’язкове, типовим є найбільше число із рухомою крапкою, яке може бути представлено на комп’ютері).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>require_true</parameter
></term>
	<listitem
><para
>Якщо встановлено значення «true», властивість стане обов’язковою і вважатиметься встановленою коректно, якщо її станом буде true/увімкнено. Отже, якщо властивість має значення false,  натискання кнопки <guibutton
>Надіслати</guibutton
> блокуватиметься (необов’язкова, типовим значенням є «false»). <caution
><para
>Якщо ви використовуєте цей атрибут, переконайтеся, що користувач зможе легко визначити, що слід робити, наприклад, покажіть йому пояснювальний текст за допомогою &lt;text&gt;.</para
></caution
></para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Створити нову властивість, яку буде пов’язано із різними іншими властивостями (або сталими рядками) на основі умов щодо певного значення властивості. Надає змогу створювати логічні конструкції, подібні до <function
>if()</function
> або <function
>switch()</function
>. Атрибути:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Ідентифікатор нової властивості (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>condition</parameter
></term>
	<listitem
><para
>Ідентифікатор властивості condition (обов’язковий)</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Дочірні елементи:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;true&gt;</term>
	<listitem
><para
>Властивість, що визначає виконання умови, є булевою, ви можете вказати два дочірні елементи &lt;true&gt; і &lt;false&gt; (і лише ці елементи). (Обов’язковий, якщо також вказано &lt;false&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;false&gt;</term>
	<listitem
><para
>Якщо властивість, що визначає виконання умови, є булевою, ви можете вказати два дочірні елементи &lt;true&gt; і &lt;false&gt; (і лише ці елементи). (Обов’язковий, якщо також вказано &lt;true&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;case&gt;</term>
	<listitem
><para
>Якщо властивість в умові не є булевою, ви можете вказати довільну кількість елементів &lt;case&gt;, по одному на кожне значення властивості (обов’язково слід вказати принаймні один такий елемент, якщо властивість в умові не є булевою).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;default&gt;</term>
	<listitem
><para
>Якщо властивість, яка визначає умову, не є булевою, поведінку у випадку, якщо жоден з елементів &lt;case&gt; не відповідає значенню властивості в умові, можна визначити за допомогою додаткового елемента &lt;default&gt;. (необов’язковий, можна використовувати лише один раз у поєднанні із одним або декількома елементами &lt;case&gt;)</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Дочірні елементи &lt;true&gt;, &lt;false&gt;, &lt;case&gt; і &lt;default&gt; приймають такі атрибути:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Лише для елементів &lt;case&gt;: значення, з яким слід порівнювати властивість умови (обов’язковий, рядок).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_value</parameter
></term>
	<listitem
><para
>Фіксований рядок, який має бути надано як значення властивості &lt;switch&gt;, якщо справджується поточна умова (обов’язковий, якщо не вказано dynamic_value).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dynamic_value</parameter
></term>
	<listitem
><para
>Ідентифікатор <parameter
>id</parameter
> властивості призначення, який має бути надано як значення властивості &lt;switch&gt;, якщо справджується поточна умова (обов’язковий, якщо не вказано fixed_value).</para
></listitem>
	</varlistentry>
	</variablelist>
	</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;connect&gt;</term>
<listitem
><para
>З’єднує дві властивості. Клієнтську властивість буде змінено при зміні керівної властивості (але не навпаки!). Атрибути: <variablelist>
	<varlistentry>
	<term
><parameter
>client</parameter
></term>
	<listitem
><para
>Ідентифікатор клієнтської властивості, тобто властивості, яку буде скориговано (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>governor</parameter
></term>
	<listitem
><para
>Ідентифікатор керівної властивості, тобто властивості, яка змінює клієнтську властивість. Може включати модифікатор (обов’язковий)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>reconcile</parameter
></term>
	<listitem
><para
>Якщо має значення «true», клієнтська властивість скоригує керівну властивість під час з’єднання так, щоб керівна властивість приймала лише ті значення, які є прийнятними для клієнтської (наприклад, припустімо, що керівна властивість є числовою із мінімальним значенням «0», а клієнтська — числовою властивістю із мінімальним значенням «100». Мінімальне значення обох властивостей стане рівним 100, якщо reconcile="true"). Загалом, працює лише для властивостей, які належать до одного базового типу (необов’язковий, типовим значенням є «false»).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dependency_check&gt;</term>
<listitem
><para
>Створює булеву властивість, яка має значення true, якщо вказані залежності задоволено, і значення false, якщо це не так. Синтаксис xml цього елемента є таким самим, як і у елемента <command
>&lt;dependencies&gt;</command
>, описаного у <link linkend="pluginmapelements"
>довіднику щодо &pluginmap;</link
>. У версії &rkward; 0.6.1, до уваги беруться лише специфікації версій &rkward; і &R;, а не залежності від пакунків або pluginmap-ів.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;script&gt;</term>
<listitem
><para
>Визначає код скрипту для керування логікою графічного інтерфейсу. Докладніший опис можна знайти у <link linkend="logic_scripted"
>розділі щодо керування логікою графічного інтерфейсу за допомогою скриптів</link
>. Код скрипту, який слід виконати, може бути подано або за допомогою атрибута <parameter
>"file"</parameter
>, або як (коментований) текст у елементі. Елемент <command
>&lt;script&gt;</command
> не можна використовувати у розділі <command
>&lt;logic&gt;</command
> optionset. Атрибути: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Назва файла скрипту. (обов’язкова)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

</variablelist>
</sect2>

</sect1
>	<!-- Elements in main XML -->

<sect1 id="elementproperties"
><title
>Властивості елементів додатка</title>
<para
>Усі <link linkend="layoutelements"
>елементи компонування</link
> і усі <link linkend="activeelements"
>активні елементи</link
> мають вказані нижче властивості, доступ до яких можна отримати за допомогою синтаксичної конструкції «ідентифікатор_елемента.назва_властивості»: </para>
<variablelist>
<varlistentry>
<term
>visible</term>
<listitem
><para
>Визначає, чи є видимим елемент графічного інтерфейсу (boolean)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>enabled</term>
<listitem
><para
>Визначає, чи увімкнено елемент графічного інтерфейсу (boolean)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>required</term>
<listitem
><para
>Визначає, чи є елемент графічного інтерфейсу обов’язковим (чи повинен отримати коректне значення). Зауважте, що будь-який елемент, який вимкнено чи приховано, неявним чином є необов’язковим. (булеве значення)</para
></listitem>
</varlistentry>
</variablelist>
<para
>Крім того, деякі елементи мають додаткові властивості для з’єднання. У більшості активних елементів є також властивість «default», чиє значення буде повернуто у відповідь на виклики <function
>getBoolean/getString/getList ("...")</function
>, якщо не вказано певної властивості за назвою, як це описано нижче. </para>

<variablelist>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Типовою є властивість «text» <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Показаний текст (text)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Немає типової властивості <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Поточні позначені об’єкти. Ймовірно, цим не слід користуватися. Використовується для внутрішніх потреб (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>root</term>
	<listitem
><para
>Кореневий або батьківський об’єкт об’єктів, які пропонуються до вибору (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>Типовою є властивість «available» <variablelist>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Усі об’єкти, що зберігаються у varslot (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>З об’єктів, які містяться у varslot, ті, які позначено. Ймовірно, цим не слід користуватися. Використовується для внутрішніх потреб (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>source</term>
	<listitem
><para
>Копія об’єктів, позначених у відповідному varselector. Ймовірно, цим не слід користуватися. Використовується для внутрішніх потреб (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Типовою є властивість «selected» <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Поточні позначені рядки. Скористайтеся модифікатором «labeled», щоб отримати відповідні мітки. У &lt;valueselector&gt; безпосередньо цим, ймовірно, користуватися не слід (лише у &lt;select&gt;). (читання і запис StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Список рядкових значень, з якого слід вибирати (StringList, читання-запис)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Мітки, які слід показувати для значень рядків. (StringList, читання-запис)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Те саме, що і &lt;varslot&gt;, але властивостями є списки рядків, а не RObject-и.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Типовою є властивість «string» <variablelist>
	<varlistentry>
	<term
>string</term>
	<listitem
><para
>Значення поточного позначеного пункту (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>number</term>
	<listitem
><para
>Номер поточного позначеного пункту (пункти нумеруються згори вниз, починаючи з 0) (integer)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Те саме, що і &lt;radio&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Те саме, що і &lt;valueselector&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Не має типової властивості. «enabled» є єдиною властивістю, і у поточній версії ця властивість недоступна для параметрів всередині &lt;select&gt; або &lt;valueselector&gt;. &lt;option&gt; не має властивостей «visible» і «required». <variablelist
> <varlistentry>
	<term
>enabled</term>
	<listitem
><para
>Визначає, чи має бути цей пункт увімкнено. Втім, у більшості випадків його зміна вмикає або вимикає увесь список &lt;radio&lt; або &lt;dropdown&lt;. Попри це, може бути використано для динамічного встановлення окремого пункту у &lt;radio&lt; або &lt;dropdown&lt; (булеве значення).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Типовою властивістю є «state.labeled», що означає, що повертаються значення, вказані атрибутами <parameter
>value</parameter
> і <parameter
>value_unchecked</parameter
>, а <emphasis
>не</emphasis
> показана мітка поля для позначки. <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Стан поля для позначки (позначено чи ні). Зауважте, що для цієї властивості (як і для усіх булевих властивостей) можна використовувати модифікатори «not» і «labeled» (див. <link linkend="propertytypes"
>типи властивостей</link
>). Втім, найкориснішим варіантом є з’єднання властивості без жодних модифікаторів, тобто варіант «<emphasis
>ідентифікатор_поля_для_позначки</emphasis
>.state», за якого буде повернуто стан поля у форматі, зручному для використання у інструкції if (0 або 1). (булевий тип)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Типовою властивістю є «checked», якщо і лише якщо для рамки передбачено властивість позначення. Для рамок без позначок типової властивості немає. <variablelist
> <varlistentry>
	<term
>checked</term>
	<listitem
><para
>Доступна лише для придатних до позначення рамок: стан позначки (позначено чи ні). Зауважте, що для цієї властивості (як і для усіх булевих властивостей) можна використовувати модифікатори «not» та «numeric» (див. <link linkend="propertytypes"
>типи властивостей</link
>). (булевий тип)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Типовою є властивість «text» <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Поточний текст у полі для введення (string)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;matrix&gt;</term>
	<listitem
><para
>Типовою властивістю є «cbind». <variablelist>
		<varlistentry>
			<term
>rows</term>
			<listitem
><para
>Кількість рядків у матриці (integer). Якщо матриця дозволяє додавання або вилучення рядків користувачем, цю властивість слід вважати придатною лише для читання. Якщо ж це не так, зміна значення цієї властивості призводитиме до зміни розміру матриці.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>columns</term>
			<listitem
><para
>Кількість стовпчиків у матриці (integer). Якщо матриця дозволяє додавання або вилучення стовпчиків користувачем, цю властивість слід вважати придатною лише для читання. Якщо ж це не так, зміна значення цієї властивості призводитиме до зміни розміру матриці.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>tsv</term>
			<listitem
><para
>Дані у матриці у форматі tsv (рядок; читання і запис). Зауважте, що порівняно зі звичайним компонуванням tsv, символами нового рядка відокремлено <emphasis
>стовпчики</emphasis
>, а не рядки, а комірки у одному стовпчику відокремлено символами табуляції.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>0,1,2...</term>
			<listitem
><para
>Дані з окремого стовпчика ( для найвищого рядка) <function
>getValue()</function
>/<function
>getString()</function
> повертає це як єдиний рядок, відокремлений «\n». Втім, рекомендованим способом отримання є використання функції <function
>getList()</function
>, яка повертає цей стовпчик як масив рядків.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>row.0,row.1,row.2...</term>
			<listitem
><para
>Дані з окремого рядка (0 для найвищого рядка). <function
>getValue()</function
>/<function
>getString()</function
> повертає це як єдиний рядок, відокремлений «\n». Втім, рекомендованим способом отримання є використання функції <function
>getList()</function
>, яка повертає цей рядок як масив рядків.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>cbind</term>
			<listitem
><para
>Дані у форматі, придатному до вставляння до &R; у обгортці інструкції cbind (string; лише читання).</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;optionset&gt;</term>
	<listitem
><para
>Немає типової властивості. <variablelist>
		<varlistentry>
			<term
>row_count</term>
			<listitem
><para
>Кількість пунктів у наборі пунктів (integer). Можна лише читати.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>current_row</term>
			<listitem
><para
>Поточний активний пункт у наборі пунктів (integer). -1, якщо немає активного пункту. Можна читати і записувати.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
><emphasis
>optioncolumn_ids</emphasis
></term>
			<listitem
><para
>Для кожної визначеної вами &lt;optioncolumn&gt; буде створено властивість типу списку рядків із вказаним ідентифікатором.</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Типовою властивістю є «selection» <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Поточний текст (назва позначеного файла) у навігаторі файловою системою (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>overwrite</parameter
></term>
	<listitem
><para
>Визначає, чи позначено пункт «перезапис» (булеве значення, лише читання, тобто ви можете лише програмно читати стан позначення, але не змінювати його)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Типовою властивістю є «selection» <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Назва позначеного об’єкта повністю (string; лише для читання, щоб встановити програмно, скористайтеся «parent» і «objectname»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>parent</term>
	<listitem
><para
>Батьківський об’єкт позначеного об’єкта. Це завжди наявний об’єкт &R; типу, який може містити інші об’єкти (наприклад list або data.frame). Якщо вказано порожній рядок або некоректний об’єкт, використовується «.GlobalEnv» (RObject).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>objectname</term>
	<listitem
><para
>Базова назва позначеного об’єкта, тобто рядок, введений користувачем (буде змінено до коректної назви &R;, якщо потрібно) (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>active</term>
	<listitem
><para
>Лише для saveobject з позначкою: визначає, чи позначено пункт. Завжди має значення true для saveobject без пункту позначки. (булеве значення)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Типовою є властивість «int» або «real.formatted» залежно від режиму роботи лічильника <variablelist>
	<varlistentry>
	<term
>int</term>
	<listitem
><para
>Ціле значення, що міститься у полі лічильника, або найближче ціле, якщо лічильник працює у режимі дійсних чисел (integer)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>real</term>
	<listitem
><para
>Дійсне значення, що міститься у полі лічильника (або ціле значення, якщо лічильник для цілих чисел) (real)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>Типовою властивістю є «model» <variablelist>
	<varlistentry>
	<term
>model</term>
	<listitem
><para
>Рядок поточної моделі (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>table</term>
	<listitem
><para
>data.frame, що містить потрібні змінні. Якщо використано змінні лише з одного data.frame, буде повернуто назву цього data.frame. Якщо ж це не так, буде побудовано новий data.frame із відповідними параметрами (рядок).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Якщо використовуються змінні з декількох data.frames, програма може сплутати їхні назви (наприклад, якщо обидва data.frame містять змінну із назвою «x»). Це повертає список з неоднозначними назвами як індексами та описову мітку як значення (рядок).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>fixed_factors</term>
	<listitem
><para
>Фіксовані фактори. Ймовірно, цим не слід користуватися. Використовується для внутрішніх потреб (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>dependent</term>
	<listitem
><para
>Залежні змінні. Ймовірно, цим не слід користуватися. Використовується для внутрішніх потреб (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Немає типової властивості <variablelist
> <varlistentry>
	<term
>code</term>
	<listitem
><para
>Код, створений вбудованим додатком (code)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Типовою властивістю є «state» <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Визначає, чи позначено пункт попереднього перегляду (не обов’язково, чи вже показано попередній перегляд) (boolean)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Цей елемент (використовується у розділі &lt;logic&gt;) є особливим, оскільки з технічної точки зору це одна (рядкова) властивість, а не комплект зі однієї або декількох властивостей. Він належить до булевого типу. Зауважте, що придатними до використання модифікаторами цієї властивості (які і усіх булевих властивостей) є «not» і  «numeric» (див. <link linkend="propertytypes"
>типи властивостей</link
>).</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Цей елемент (використовується у розділі &lt;logic&gt;) є особливим, оскільки з технічної точки зору це одна (рядкова) властивість, а не комплект зі однієї або декількох властивостей. Він надає змогу перемикатися між декількома властивостями-цілями, залежно від значення властивості в умові, або змінювати прив’язку властивості в умові. Усі вказані вами модифікатор буде передано властивостям-цілям. Отже, якщо, наприклад, усі властивості-цілі є властивостями RObject, ви можете також використовувати для перемикання модифікатор «shortname». Втім, якщо властивості-цілі належать до різних типів, використання модифікаторів може призвести до помилок. Для <replaceable
>fixed_value</replaceable
> усі модифікатори без попередження буде відкинуто. Зауважте, що під час доступу до властивостей-цілей у switch можливе лише читання цих властивостей!</para
></listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="standard_embeddable_plugins"
><title
>Вбудовувані додатки, які є частиною офіційного пакунка &rkward;</title>
<para
>Декілька придатних до вбудовування додатків постачаються разом із основною програмою &rkward;. Ви можете використовувати ці додатки у ваших власних додатках. Докладна документація щодо цих додатків у поточній версії доступна лише у початкових кодах додатків та на їхніх сторінках довідки. Втім, ось список із коротким оглядом доступних додатків:</para>
<table frame='all'
><title
>Стандартні вбудовувані додатки</title>
<tgroup cols='4'>
<thead>
<row>
  <entry
>Ідентифікатор</entry>
  <entry
>Pluginmap</entry>
  <entry
>Опис</entry>
  <entry
>Приклад використання</entry>
</row>
</thead>
<tbody>
<row>
  <entry
>rkward::plot_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Надає доступ до широкого спектру параметрів креслень. Використовується більшістю додатків для створення креслень.</entry>
  <entry
>Креслення -> Блокова діаграма, більшість інших додатків для креслення</entry>
</row>
<row>
  <entry
>rkward::color_chooser</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Дуже простий додаток для задання кольору. У поточній реалізації надає користувачеві список назв кольорів. У майбутніх реалізаціях може надавати ширші можливості з вибору кольору.</entry>
  <entry
>Креслення -> Гістограма</entry>
</row>
<row>
  <entry
>rkward::plot_stepfun_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Параметри креслення сходинкової функції</entry>
  <entry
>Креслення -> Креслення ECDF</entry>
</row>
<row>
  <entry
>rkward::histogram_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Параметри гістограми (креслення)</entry>
  <entry
>Креслення -> Гістограма</entry>
</row>
<row>
  <entry
>rkward::barplot_embed</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Параметри стовпчикової діаграми</entry>
  <entry
>Креслення -> Блокова діаграма</entry>
</row>
<row>
  <entry
>rkward::one_var_tabulation</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Табуляція для однієї змінної.</entry>
  <entry
>Креслення -> Блокова діаграма</entry>
</row>
<row>
  <entry
>rkward::limit_vector_length</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Обмеження на довжину вектора (до n найбільших або найменших елементів).</entry>
  <entry
>Креслення -> Блокова діаграма</entry>
</row>
<row>
  <entry
>rkward::level_select</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Створює &lt;valueselector&gt;, заповнений рівнями (або неповторюваними значеннями) вектора.</entry>
  <entry
>Дані -> Перекодувати категоріальні дані</entry>
</row>
<row>
  <entry
>rkward::multi_input</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Поєднує поле лічильника, поле введення та пункти варіантів для надання можливостей з введення символьних, числових і логічних даних.</entry>
  <entry
>Дані -> Перекодувати категоріальні дані</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>

<sect1 id="pluginmapelements"
><title
>Елементи, які можна використовувати у файлах &pluginmap;</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Має бути у будь-якому файлі &pluginmap; як кореневий вузол (лише один раз). Атрибути: <variablelist>
	<varlistentry>
	<term
>base_prefix</term>
	<listitem
><para
>Назви файлів, вказані у файлі &pluginmap;, вважаються визначеними відносно каталогу файла &pluginmap; + префікс, вказаний вами тут. Особливо корисний, якщо усі ваші компоненти розташовано у одному підкаталозі.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>namespace</term>
	<listitem
><para
>Простір назв для ідентифікаторів компонентів. Під час пошуку компонентів для вбудовування програма отримуватиме компоненти за допомогою рядка «namespace::ідентифікатор_компонента». У поточній версії встановлено у значення «rkward».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Додатковий рядок ідентифікатора цієї &pluginmap;. Визначення такого ідентифікатора надасть змогу стороннім авторам посилатися на вашу &pluginmap; і завантажувати її з власних (див. <link linkend="chapter_dependencies"
>розділ щодо обробки залежностей</link
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>priority</term>
	<listitem
><para
>Одне з таких значень: <replaceable
>"hidden"</replaceable
>, <replaceable
>"low"</replaceable
>, <replaceable
>"medium"</replaceable
> або <replaceable
>"high"</replaceable
>. Файли &pluginmap; з рівнем пріоритетності «medium"» або «high» автоматично активуються, щойно їх буде вперше виявлено &rkward;. Рівнем <replaceable
>priority="hidden"</replaceable
> слід користуватися для &pluginmap;-ів, які не слід активувати, каталогів (які призначено лише для включення). Втім, у поточній реалізації це, насправді, не приховує &pluginmap;. (необов’язковий, типовим значенням є «medium»).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;dependencies&gt;</term>
<listitem
><para
>Цей елемент, що вказує залежності, можна використовувати як безпосередній дочірній елемент елемента &lt;document&gt; (лише один раз) або як дочірній елемент елементів &lt;component&gt; (по одному на кожен елемент &lt;component&gt;). Визначає залежності, які має бути задоволено для того, щоб додатком (або додатками) можна було користуватися. Огляд питань щодо залежностей наведено у <link linkend="chapter_dependencies"
>відповідному розділі</link
>. Атрибути:</para>
	<variablelist>
	<varlistentry>
	<term
>rkward_min_version, rkward_max_version</term>
	<listitem
><para
>Мінімальна і максимальна дозволені версії &rkward;. Специфікація версій може включати нечислові суфікси, наприклад «0.5.7z-devel1». Якщо вказані умови залежності не виконуються, додаток, який їх використовуватиме, <emphasis
>буде проігноровано</emphasis
>. <link linkend="sect_dependencies_rkward_version"
>Докладніші відомості</link
>. Необов’язковий, якщо не вказано, вимог щодо мінімальної і максимальної версій &rkward; не висуватиметься.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>R_min_version, R_max_version</term>
	<listitem
><para
>Мінімальна і максимальна дозволені версії &R;. У специфікації версій <emphasis
>не можна</emphasis
> включати нечислові суфікси, зокрема не можна визначати версію так: «0.5.7z-devel1». Дані щодо залежності від версії &R; буде показано на сторінках довідки додатка, але самі залежності не враховуватимуться (версія &rkward; 0.6.1). <link linkend="sect_dependencies_r_version"
>Докладніші відомості</link
>. Необов’язковий, якщо не вказано, вимог щодо мінімальної і максимальної версій &R; не висуватиметься.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Дочірні елементи:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;package&gt;</term>
	<listitem
><para
>Додає залежність від вказаного пакунка &R;. Атрибути: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Назва пакунка (обов’язкова).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Мінімальна або максимальна дозволена версія (необов’язкова).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>repository</term>
		<listitem
><para
>Сховище, у якому зберігається пакунок. Необов’язкове, але дуже рекомендоване, якщо пакунок не можна отримати з CRAN.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;pluginmap&gt;</term>
	<listitem
><para
>Додає залежність від вказаної &pluginmap; &rkward;. Атрибути: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Рядок-ідентифікатор потрібної &pluginmap; (обов’язковий).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Мінімальна або максимальна дозволена версія (необов’язкова).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>Адреса, за якою можна знайти &pluginmap;. Обов’язкова.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Можна використовувати лише один раз як дочірній елемент елемента &lt;document&gt;. Містить метаінформацію щодо &pluginmap; (або додатка). Див. <link linkend="chapter_about_information"
>розділ щодо відомостей про додаток</link
>, щоб дізнатися більше. Атрибути:</para>
	<variablelist>
	<varlistentry>
	<term
>name</term>
	<listitem
><para
>Видима назва для користувачів. Необов’язкова. Може бути іншою, ніж вказано у «id».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>version</term>
	<listitem
><para
>Номер версії. Необов’язковий. Формат номера не обмежено, але щоб ним можна було користуватися, варто дотримуватися типової нумерації версій, зокрема «x.y.z».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>releasedate</term>
	<listitem
><para
>Специфікація дати випуску. Необов’язкова. Формат: «РРРР-ММ-ДД».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>shortinfo</term>
	<listitem
><para
><emphasis
>Короткий</emphasis
> опис додатка або &pluginmap;. Необов’язковий.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>url</term>
	<listitem
><para
>Адреса, за якою можна знайти додаткову інформацію. Необов’язкова, але рекомендована.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>copyright</term>
	<listitem
><para
>Специфікація авторських прав, наприклад «2012-2013 by Ivan Ivanenko». Необов’язкова, але рекомендована.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>licence</term>
	<listitem
><para
>Специфікація умов ліцензування, наприклад «GPL» або «BSD». Будь ласка, не забувайте додавати до ваших файлів текст відповідних умов ліцензування повністю! Необов’язкова, але рекомендована.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>category</term>
	<listitem
><para
>Категорія додатків, наприклад «Item response theory». З &rkward; 0.6.1 немає попередньо визначеного жорсткого набору категорій. Необов’язкова.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Дочірні елементи:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;author&gt;</term>
	<listitem
><para
>Додає відомості щодо автора. Атрибути: <variablelist>
		<varlistentry>
		<term
>name, given, family</term>
		<listitem
><para
>Або вкажіть ім’я повністю за допомогою <parameter
>name</parameter
>, або визначте <parameter
>given</parameter
> (ім’я) та <parameter
>family</parameter
> (прізвище) окремо.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>role</term>
		<listitem
><para
>Опис ролі автора (необов’язковий).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>email</term>
		<listitem
><para
>Адреса електронної пошти, за допомогою якої можна зв’язатися з автором. Можна вказати адресу списку листування rkward-devel, якщо ви підписані на нього, а ваш додаток призначено для включення до офіційного випуску &rkward;.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>Адреса сторінки із додатковою інформацією про автора, наприклад домашньої сторінки (необов’язкова).</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;components&gt;</term>
<listitem
><para
>Має бути використано лише один раз як безпосередній дочірній елемент елемента &lt;document&gt;. Містить окремі елементи &lt;component&gt;, які описано нижче. Не має атрибутів.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;component&gt;</term>
<listitem
><para
>Безпосередніми дочірніми елементами елемента &lt;components&gt; мають бути один або декілька елементів &lt;component&gt;. Їх можна використовувати лише так. Реєструє компонент або додаток у &rkward;. Атрибути: <variablelist>
	<varlistentry>
	<term
>type</term>
	<listitem
><para
>Для подальшого розширення можливостей, тип компонента або додатка. У поточній версії завжди має значення «standard» (єдиний тип, підтримку якого зараз передбачено).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор, за яким можна отримати цей компонент (для розташовування його у меню (див. нижче) або для вбудовування). Див. простір назв &lt;document&gt; вище.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Обов’язковий принаймні для компонентів з type="standard": назва файла XML з описом графічного інтерфейсу.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Мітка для цього компонента, яка використовується для розташування компонента у ієрархії меню.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;attribute&gt;</term>
<listitem
><para
>Визначає атрибути компонента. Поки має значення лише для <link linkend="context_import"
>додатків імпортування</link
>. Можна використовувати лише як безпосередній дочірній елемент &lt;component&gt;. Атрибути: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор атрибута</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>value</term>
	<listitem
><para
>Значення атрибута</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Мітка, яку пов’язано з атрибутом</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;hierarchy&gt;</term>
<listitem
><para
>Має бути використано точно один раз як безпосередній дочірній елемент елемента &lt;document&gt;. Описує, де у ієрархії меню має бути розташовано оголошені вище компоненти. Приймає як безпосередні дочірні елементи лише елементи &lt;menu&gt;. Не має атрибутів.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;menu&gt;</term>
<listitem
><para
>Як безпосередні дочірні елементи елемента &lt;hierarchy&gt; має бути вказано один або декілька елементів &lt;menu&gt;. Якщо меню із вказаним ідентифікатором (див. нижче) вже існує, меню буде об’єднано. Елемент &lt;menu&gt; можна використовувати лише як безпосередній дочірній елемент елемента &lt;hierarchy&gt; (меню верхнього рівня) або як безпосередній дочірній елемент іншого елемента &lt;menu&gt; (підменю). Сам же елемент &lt;menu&gt; приймає як дочірні елементи лише інші елементи &lt;menu&gt; або елементи &lt;entry&gt;. Атрибути: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Рядок-ідентифікатор меню. Є корисним, якщо визначення меню читаються з декількох файлів &pluginmap;, для забезпечення розташовування пунктів додатків у тих самих меню. Деякі ідентифікатори меню, зокрема «file» стосуються попередньо визначених типових меню (у цьому випадку на меню «Файл»). Щоб використовувати узгоджену систему ідентифікаторів пунктів меню, ознайомтеся із кодом наявних файлів &pluginmap;.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Мітка меню.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Надає змогу керувати упорядковуванням пунктів меню. Див. <link linkend="pluginmap_grouping"
>упорядковування пунктів меню</link
>. Необов’язковий.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;entry&gt;</term>
<listitem
><para
>Пункт меню, тобто пункт, за допомогою якого можна викликати додаток. Можна використовувати лише як безпосередній дочірній елемент елемента &lt;menu&gt;, не має дочірніх елементів. Атрибути: <variablelist>
	<varlistentry>
	<term
>component</term>
	<listitem
><para
>Ідентифікатор компонента, який має бути викликано, якщо задіяно відповідний пункт меню.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Надає змогу керувати упорядковуванням пунктів меню. Див. <link linkend="pluginmap_grouping"
>упорядковування пунктів меню</link
>. Необов’язковий.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;group&gt;</term>
<listitem
><para
>Оголошує групу пунктів у меню. Див. <link linkend="pluginmap_grouping"
>упорядковування пунктів меню</link
>. Атрибути: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Назва цієї групи.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>separated</term>
	<listitem
><para
>Необов’язковий. Якщо встановлено значення «true» пункт у цій групі буде візуально відділено від навколишніх пунктів.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Назва групи, до якої слід долучити цю групу (необов’язкова).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;context&gt;</term>
<listitem
><para
>Оголошує записи у <link linkend="contextualized_plugins"
>контексті</link
>. Можна використовувати лише як безпосередній дочірній елемент вузла &lt;document&gt;. Приймає як дочірні елементи лише теґи &lt;menu&gt;. Атрибути: <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор контексту. Поки що реалізовано лише два контексти: «x11» і «import».</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;require&gt;</term>
<listitem
><para
>Включити інший файл &pluginmap;. Цей файл &pluginmap; буде завантажено лише один раз, навіть якщо його буде визначено за допомогою &lt;require&gt; у якихось інших файлах. Найважливішим випадком використання є включення файла &pluginmap;, у якому оголошено певні компоненти, які вбудовуються компонентами, які оголошено у поточному файлі &pluginmap;. Елементи &lt;require&gt; можна використовувати лише як безпосередні дочірні елементи вузла &lt;document&gt;. Атрибути: <variablelist>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Назва файла &pluginmap;, який слід включити. Визначається відносно каталогу поточного файла &pluginmap; + base_prefix (див. вище у описі елемента &lt;document&gt;). Якщо вам невідомий відносний шлях до файла &pluginmap;, який слід включити, скористайтеся атрибутом <parameter
>map</parameter
> для посилання на нього за його ідентифікатором.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>map</term>
	<listitem
><para
>Щоб включити файл &pluginmap; з іншого пакунка (або &pluginmap; &rkward; з вашого зовнішнього &pluginmap;), ви можете послатися на нього за його значенням <replaceable
>назва_простору_назв::ідентифікатор</replaceable
>, який вказано у елементі &lt;document&gt; файла &pluginmap;. Включення не відбудеться, що програма не виявить &pluginmap; з таким ідентифікатором (наприклад, його не встановлено у системі користувача). Вам слід використовувати цей метод лише для включення &pluginmap;, якого немає у вашому пакунку. Для карт у вашому пакунку швидшим і надійнішим способом є визначення відносного шляху (атрибута <parameter
>file</parameter
>). </para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="helpfileelements"
><title
>Елементи, які можна використовувати у файлах довідки .rkh</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Має бути в усіх файлах <literal role="extension"
>.xml</literal
> як кореневий вузол (лише один раз). Не має атрибутів.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;title&gt;</term>
<listitem
><para
>Заголовок сторінки довідки. <emphasis
>Не</emphasis
> береться до уваги для сторінок довідки з додатків (для таких сторінок заголовком завжди буде назва самого додатка). Використовується лише для самодостатніх сторінок. Не має атрибутів. Як заголовок сторінки довідки буде використано вміст теґу &lt;title&gt;. Можна використовувати лише один раз як безпосередній дочірній елемент вузла &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;summary&gt;</term>
<listitem
><para
>Коротка анотація сторінки довідки (або опис того, для чого призначено цей додаток). Цей розділ завжди буде показано на початку сторінки довідки. Не має атрибутів. Буде показано текст, що міститься у тезі &lt;summary&gt;. Є рекомендованим, але не є обов’язковим. Можна визначати лише один раз як безпосередній дочірній елемент вузла &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;usage&gt;</term>
<listitem
><para
>Дещо докладніша анотація щодо користування. Завжди буде показано безпосередньо після розділу &lt;summary&gt;. Не має атрибутів. Буде показано текст, що міститься у тезі &lt;usage&gt;. Рекомендовано для сторінок довідки з додатків, але не є обов’язковим. Можна визначати лише один раз як безпосередній дочірній елемент вузла &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;section&gt;</term>
<listitem
><para
>Розділ загального призначення. Можна використовувати довільну кількість разів як безпосередній дочірній елемент вузла &lt;document&gt;. Розділи, визначені цим теґом, розташовуватимуться у порядку їхнього визначення, але усі <emphasis
>після</emphasis
> розділу &lt;usage&gt; і <emphasis
>перед</emphasis
> розділом &lt;settings&gt;. Буде показано текст, що міститься у тезі &lt;section&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор, потрібний для переходу до цього розділу з панелі навігації (або за посиланням). Має бути неповторюваним у межах одного файла. Обов’язковий, не має типового значення.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Заголовок розділу. Обов’язковий, не має типового значення.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>short_title</term>
	<listitem
><para
>Короткий заголовок для панелі навігації. Необов’язковий, типовим значенням є повна версія заголовка.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;settings&gt;</term>
<listitem
><para
>Визначає розділ, який містить довідкові дані щодо різноманітних параметрів графічного інтерфейсу. Має сенс і використовується лише для сторінок довідки, пов’язаних із додатками. Використовується як безпосередній дочірній елемент вузла &lt;document&gt;. Може містити як дочірні елементи лише елементи &lt;setting&gt; і &lt;caption&gt;. Не має атрибутів.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;setting&gt;</term>
<listitem
><para
>Стосується окремого параметра у графічному інтерфейсі. Можна використовувати лише як безпосередній дочірній елемент елемента &lt;settings&gt;. У інтерфейсі буде показано текст, який міститься у цьому елементі. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор параметра у <literal role="extension"
>.xml</literal
> додатка. Обов’язковий, не має типового значення.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Додатковий заголовок параметра. Якщо не вказано (у більшості випадків рекомендовано не вказувати), заголовок буде запозичено з файла <literal role="extension"
>.xml</literal
> додатка.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;caption&gt;</term>
<listitem
><para
>Надпис для візуального групування декількох параметрів. Можна використовувати лише як безпосередній дочірній елемент елемента &lt;settings&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор відповідного елемента (типово &lt;frame&gt;, &lt;page&gt; або &lt;tab&gt;) у файлі <literal role="extension"
>.xml</literal
> додатка.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Додатковий заголовок надпису. Якщо не вказано (у більшості випадків рекомендовано не вказувати), заголовок буде запозичено з файла <literal role="extension"
>.xml</literal
> додатка.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;related&gt;</term>
<listitem
><para
>Визначає розділ, що містить посилання на додаткову пов’язану з темою інформацію. Завжди буде показано після розділу &lt;settings&gt;. Не має атрибутів. Буде показано текст, що міститься у тезі &lt;related&gt;. Типово, там має міститися список у форматі &HTML;. Рекомендовано для сторінок довідки з додатків, але не є обов’язковим. Можна визначати лише один раз, як безпосередній дочірній елемент вузла &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;technical&gt;</term>
<listitem
><para
>Визначає розділ, що містить технічні дані, які не потрібні кінцевому користувачеві (зокрема про внутрішню структуру додатка). Цей розділ на сторінці довідки завжди буде показано останнім. Не має атрибутів. Показано буде текст, що міститься всередині теґу &lt;related&gt;. Не є обов’язковим і не рекомендується для більшості сторінок довідки з додатків. Можна визначати лише один раз як безпосередній дочірній елемент вузла &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;link&gt;</term>
<listitem
><para
>Посилання. Може бути використано у будь-якому з описаних вище розділів. <variablelist
> <varlistentry>
	<term
>href</term>
	<listitem
><para
>Адреса посилання. Зауважте, що можна використовувати декілька специфічних для &rkward; адрес. Див. <link linkend="pluginhelp"
>розділ щодо написання сторінок довідки</link
>, щоб дізнатися більше.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;label&gt;</term>
<listitem
><para
>Вставляє значення мітки інтерфейсу користувача. Може бути використано у будь-якому з описаних вище розділів. <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>Ідентифікатор елемента у додатку, з якого слід скопіювати атрибут <replaceable
>label</replaceable
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;різноманітні теґи &HTML;&gt;</term>
<listitem
><para
>У цих розділах можна використовувати більшість теґів &HTML;. Втім, не слід зловживати форматуванням вручну.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="guilogic_functions"
><title
>Функції для керування логікою графічного інтерфейсу за допомогою скриптів</title>
<variablelist>
<varlistentry
><term
>Клас "Component"</term>
<listitem
><para
>Клас, який відповідає одному компоненту або властивості компонента. Найважливішим екземпляром цього класу є змінна «gui», яку попередньо визначено як кореневу властивість поточного компонента. Для екземплярів класу «Component» доступні такі методи: <variablelist>
	<varlistentry
><term
>absoluteId(base_id)</term
><listitem
><para
>Повертає абсолютний ідентифікатор <emphasis
>base_id</emphasis
> або, якщо базовий ідентифікатор base_id не вказано, ідентифікатор компонента.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getValue(ідентифікатор)</term
><listitem
><para
>Не рекомендовано. Навзамін слід користуватися <function
>getString()</function
>, <function
>getBoolean()</function
> або <function
>getList()</function
>. Повертає значення вказаної дочірньої властивості. Повертає значення поточної властивості, якщо ідентифікатор не вказано.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getString(ідентифікатор)</term
><listitem
><para
>Повертає значення вказаної дочірньої властивості у форматі рядка. Повертає значення поточної властивості, якщо ідентифікатор не вказано.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getBoolean(ідентифікатор)</term
><listitem
><para
>Повертає значення вказаної дочірньої властивості у форматі булевого значення (якщо це можливо). Повертає значення поточної властивості, якщо ідентифікатор не вказано.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getList(ідентифікатор)</term
><listitem
><para
>Повертає значення вказаної дочірньої властивості у форматі масиву рядків (якщо це можливо). Повертає значення поточної властивості, якщо ідентифікатор не вказано.</para
></listitem
></varlistentry>
	<varlistentry
><term
>setValue(ідентифікатор, значення)</term
><listitem
><para
>Встановити вказане значення дочірньої властивості.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getChild(ідентифікатор)</term
><listitem
><para
>Повертає екземпляр дочірньої властивості із вказаним <emphasis
>ідентифікатором</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>addChangeCommand(ідентифікатор, команда)</term
><listitem
><para
>Виконати <emphasis
>команду</emphasis
> кожного разу, коли вносяться зміни до дочірньої властивості <emphasis
>ідентифікатор</emphasis
>.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Клас "RObject"</term>
<listitem
><para
>Клас, який відповідає одному окремому об’єкту &R;. Екземпляр цього класу можна отримати за допомогою команди <command
>makeRObject(назва_об’єкта)</command
>. Для екземплярів класу RObject доступні такі методи: <warning
><para
>Якщо у черзі модуля обробки є якісь команди, дані, які може бути отримано за допомогою цих методів, можуть бути застарілими на час запуску коду додатка. <emphasis
>Не покладайтеся</emphasis
> на них, якщо це критично (існує ризик втрати даних).</para
></warning>
	<variablelist>
	<varlistentry
><term
>getName()</term
><listitem
><para
>Повертає абсолютну назву об’єкта.</para
></listitem
></varlistentry>
	<varlistentry
><term
>exists()</term
><listitem
><para
>Повертає true, якщо об’єкт існує. Вам слід виконати таку перевірку, перш ніж використовувати методи з наведеного нижче списку.</para
></listitem
></varlistentry>
	<varlistentry
><term
>dimensions()</term
><listitem
><para
>Повертає масив розмірностей (подібна до команди <command
>dim()</command
> у R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>classes()</term
><listitem
><para
>Повертає масив класів (подібна до команди <command
>class()</command
> у R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>isClass(клас)</term
><listitem
><para
>Повертає true, якщо об’єкт є класом <emphasis
>клас</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFrame()</term
><listitem
><para
>Повертає true, якщо об’єкт належить до типу data.frame.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isMatrix()</term
><listitem
><para
>Повертає true, якщо об’єкт є матрицею.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isList()</term
><listitem
><para
>Повертає true, якщо об’єкт є списком.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isFunction()</term
><listitem
><para
>Повертає true, якщо об’єкт є функцією.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isEnvironment()</term
><listitem
><para
>Повертає true, якщо об’єкт є середовищем.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataNumeric()</term
><listitem
><para
>Повертає true, якщо об’єкт є вектором числових даних.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFactor()</term
><listitem
><para
>Повертає true, якщо об’єкт є вектором даних факторів.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataCharacter()</term
><listitem
><para
>Повертає true, якщо об’єкт є вектором символьних даних.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataLogical()</term
><listitem
><para
>Повертає true, якщо об’єкт є вектором булевих даних.</para
></listitem
></varlistentry>
	<varlistentry
><term
>parent()</term
><listitem
><para
>Повертає екземпляр RObject, який є батьківським щодо цього об’єкта.</para
></listitem
></varlistentry>
	<varlistentry
><term
>child(назва дочірнього об’єкта)</term
><listitem
><para
>Повертає екземпляр RObject, що відповідає дочірньому об’єкту <emphasis
>назва дочірнього об’єкта</emphasis
> поточного об’єкта.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Клас "RObjectArray"</term>
<listitem
><para
>Масив екземплярів RObject. Екземпляр цього класу можна отримати за допомогою команди <command
>makeRObjectArray(назви об’єктів)</command
>. Може бути корисним при роботі з varslot, у яких можна вибирати декілька об’єктів.</para
></listitem>
</varlistentry>
<varlistentry
><term
>Функція include()</term>
<listitem
><para
><command
>include(назва файла)</command
> можна скористатися для включення окремого файла JS.</para
></listitem>
</varlistentry>
<varlistentry
><term
>Функція doRCommand()</term>
<listitem
><para
>Функцією <command
>doRCommand(команда, зворотній виклик)</command
> можна скористатися для отримання від &R; інформації. Будь ласка, ознайомтеся із розділом щодо <link linkend="querying_r_for_info"
>отримання даних &R; з додатка</link
>, щоб дізнатися більше.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

</appendix>

<appendix id="troubleshooting">
<title
>Діагностика проблем при розробці додатків</title>
<para
>Отже, ви ознайомилися з усією документацією, зробили все як слід, і все ж воно не працює? Не хвилюйтеся — ми зможемо з усім розібратися. По-перше, слід зробити ось що: активуйте вікно <guilabel
>Діагностичні повідомлення &rkward;</guilabel
> (це можна зробити за допомогою меню <guimenu
>Вікна</guimenu
> або клацання правою кнопкою миші на одній з панелей інструментів), а потім запустіть ще раз ваш додаток. Зазвичай, у вікні повідомлень після виклику вашого додатка або інших дій ніяких повідомлень не з’являтиметься. Якщо з’явилися повідомлення, ймовірно, їх пов’язано із роботою вашого додатка. Можливо, вони допоможуть вам розібратися із проблемами. </para>
<para
>Якщо у консолі усе добре, спробуйте підвищити рівень діагностики (з командного рядка, за допомогою команди <command
>rkward --debug-level 3</command
>, або встановивши для рівня діагностики значення 3 на сторінці <menuchoice
><guimenu
>Параметри</guimenu
> <guimenuitem
>Налаштувати &rkward;</guimenuitem
> <guimenuitem
>Діагностика</guimenuitem
></menuchoice
>). Не усі повідомлення, які буде показано на високих рівнях діагностики, обов’язково свідчать про проблеми, але, може бути, серед них є і повідомлення, які вкажуть на джерело проблеми. </para>
<para
>Якщо ви попри усе не можете розібратися з тим, де помилка, не зневірюйтеся. Ми знаємо, що це не проста справа, і, крім усього, причиною може бути просто вада у &rkward;, і для вирішення треба її виправити у &rkward;. Просто повідомте про свої проблеми до списку листування розробників. Ми будемо раді вам допомогти. </para>
<para
>Нарешті, навіть якщо ви в усьому розібралися самі, але вважаєте, що у цій документації чогось немає, або вона є навіть помилковою у певних аспектах, повідомте нам про це за допомогою списку листування розробників, щоб ми могли виправити або поліпшити документацію. </para>
</appendix>

<appendix id="license">
<title
>Умови ліцензування</title>
<para
>Переклад українською: Юрій Чорноіван <email
>yurchor@ukr.net</email
></para
> 
&underFDL;
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
