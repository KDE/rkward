<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [
  <!ENTITY rkward '<application
>RKWard</application
>'>
  <!ENTITY R '<application
>R</application
>'>
  <!ENTITY javascript 'JavaScript'>
  <!ENTITY pluginmap '<literal role="extension"
>.pluginmap</literal
>'>
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Brazilian-Portuguese "INCLUDE"
><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!--- This file is part of the RKWard project (https://rkward.kde.org).
SPDX-FileCopyrightText: by Thomas Friedrichsmeier <thomas.friedrichsmeier@kdemail.net>
SPDX-FileCopyrightText: by Meik Michalke <meik.michalke@hhu.de>
SPDX-FileContributor: The RKWard Team <rkward@kde.org>
SPDX-License-Identifier: GFDL-1.2-no-invariants-or-later OR GPL-2.0-or-later
-->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title
>Introdução à escrita de plugins para o &rkward;</title>

<authorgroup>
<author
><firstname
>Thomas</firstname
> <surname
>Friedrichsmeier</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>

<author
><firstname
>Meik</firstname
> <surname
>Michalke</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>
<!-- Additional authors go here -->

<othercredit role="translator"
><firstname
>Marcus</firstname
><surname
>Gama</surname
><affiliation
><address
><email
>marcus.gama@kde.org</email
></address
></affiliation
><contrib
>Tradução</contrib
></othercredit
> 
</authorgroup>



<copyright>
<year
>2006-2024</year>
<holder
>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice
>&FDLNotice;</legalnotice>

<date
>03/05/2025</date>
<releaseinfo
>0.8.2</releaseinfo>

<abstract>
<para
>Este é um guia para escrever plugins para o &rkward;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>R</keyword>
<keyword
>rkward</keyword>
<keyword
>plugins</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title
>Introdução</title>

	<para
>Este documento descreve como escrever seus próprios plugins. A documentação cresceu bastante ao longo do tempo. Não se assuste com isso. Recomendamos que você leia os quatro passos básicos (conforme descrito abaixo) para ter uma ideia geral de como as coisas funcionam. Depois disso, você pode consultar o sumário para verificar quais tópicos avançados podem ser relevantes para você. </para>
	<para
>Para perguntas e comentários, escreva para a lista de discussão de desenvolvimento do &rkward;. </para>
	<para
><emphasis
>Você não precisa ler isto para usar o &rkward;.</emphasis
> Este documento trata da extensão do &rkward;. Ele é direcionado a usuários avançados, ou pessoas dispostas a ajudar a aprimorar o &rkward;. </para>
	<para
>Escrever um plugin padrão é basicamente um processo de quatro etapas: </para>
		<itemizedlist>
			<listitem
><para
><link linkend="pluginmap"
>Colocar uma nova Ação na hierarquia do menu</link
></para
></listitem>
			<listitem
><para
><link linkend="mainxml"
>Descrever a aparência e o comportamento da &GUI; do  plugin</link
></para
></listitem>
			<listitem
><para
><link linkend="jstemplate"
>Definir como o código R deve ser gerado a partir das configurações que o usuário faz na &GUI;</link
></para
></listitem>
			<listitem
><para
><link linkend="pluginhelp"
>Adicionar uma página de ajuda ao seu plugin</link
></para
></listitem>
		</itemizedlist>
	<para
>Essas etapas serão tratadas em sequência. </para>
	<para
>Alguns conceitos avançados podem ser usados ​​nessas quatro etapas, mas são tratados em capítulos separados, para simplificar: <itemizedlist>
			<listitem
><para
><link linkend="logic"
>Lógica da &GUI;</link
></para
></listitem>
			<listitem
><para
><link linkend="embedding"
>Embutindo plugins dentro de plugins</link
></para
></listitem>
			<listitem
><para
><link linkend="plugin_series"
>Conceitos úteis para a criação de várias séries de plugins semelhantes</link
></para
></listitem>
		</itemizedlist>
	</para>
	<para
>Além disso, nenhum dos capítulos mostra todas as opções, mas sim apenas os conceitos básicos. Uma <link linkend="reference"
>referência</link
> completa das opções é fornecida separadamente. </para>
</chapter>

<chapter id="whatareplugins">
<title
>Preliminares: O que são plugins no &rkward;? Como eles funcionam?</title>
	<para
>Claro que a primeira pergunta que você pode ter é: quais partes da funcionalidade do &rkward; são implementadas usando plugins? Ou: o que os plugins podem fazer? </para>
	<para
>Uma maneira de responder a isso é: desmarque todos os arquivos &pluginmap; em <menuchoice
><guimenu
>Configurações</guimenu
><guimenuitem
>Configurar &rkward;</guimenuitem
><guimenuitem
>Plugins</guimenuitem
></menuchoice
> e veja o que está faltando. Uma resposta um pouco mais útil: a maioria das funções estatísticas reais acessíveis pela &GUI; são implementadas usando plugins. Além disso, você pode criar &GUI;s bastante flexíveis para todos os tipos de operações usando plugins. </para>
	<para
>O paradigma básico por trás dos plugins do &rkward; é aquele que explicaremos neste documento: um arquivo &XML; descreve a aparência da &GUI;. Um arquivo &javascript; adicional é usado para gerar a sintaxe &R; a partir das configurações da &GUI;. Ou seja, os plugins não precisam realizar cálculos estatísticos. Em vez disso, eles geram a sintaxe &R; necessária para executar esses cálculos. A sintaxe &R; é então enviada ao backend &R; para avaliação e, normalmente, um resultado é exibido na janela de saída. </para>
	<para
>Continue a leitura nos próximos capítulos para ver como isso é feito. </para>
</chapter>

<chapter id="pluginmap">
<title
>Criando entradas no menu</title>
	<para
>Ao criar um novo plugin, você precisa informá-lo ao &rkward;. Portanto, a primeira coisa a fazer é escrever um arquivo &pluginmap; (ou modificar um existente). O formato do &pluginmap; é &XML;. Vou mostrar um exemplo (e, claro, certifique-se de ter configurado o &rkward; para carregar seu &pluginmap; -- <menuchoice
><guimenu
>Configurações</guimenu
><guimenuitem
>Configurar &rkward;</guimenuitem
><guimenuitem
>Plugins</guimenuitem
></menuchoice
>): </para>
	<tip>
		<para
>Após ler este capítulo, dê uma olhada também no <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
>. Ele fornece algumas funções &R; para criar a maioria das tags &XML; do &rkward; para você. </para>
	</tip>
	<programlisting
>&lt;!DOCTYPE rkpluginmap&gt;
        </programlisting>
	<para
>O doctype não é realmente interpretado, mas defina-o como <replaceable
>"rkpluginmap"</replaceable
> mesmo assim. </para>
	<programlisting
>&lt;document base_prefix="" namespace="meusplugins" id="meupluginmap"&gt;
        </programlisting>
	<para
>O atributo <parameter
>base_prefix</parameter
> pode ser usado se todos os seus plugins estiverem em um diretório comum. Basicamente, você pode omitir esse diretório dos nomes de arquivo especificados abaixo. É seguro deixá-lo como <replaceable
>""</replaceable
>. </para
><para
>Como você verá abaixo, todos os plugins recebem um identificador único, <parameter
>id</parameter
>. O <parameter
>namespace</parameter
> é uma forma de organizar esses IDs e reduzir a probabilidade de criar identificadores duplicados acidentalmente. Internamente, basicamente o namespace e, em seguida, uma <quote
>::</quote
> são adicionados a todos os identificadores que você especificar neste &pluginmap;. Em geral, se você pretende <link linkend="sect_external_plugins"
>distribuir seus plugins em um pacote &R;</link
>, é uma boa prática usar o nome do pacote como parâmetro <parameter
>namespace</parameter
>. Os plugins distribuídos com a distribuição oficial &rkward; têm <replaceable
>namespace="rkward"</replaceable
>. </para>
	<para
>O atributo <parameter
>id</parameter
> é opcional, mas especificar um id para o seu &pluginmap; permite que outras pessoas façam com que seus &pluginmap;s carreguem o seu &pluginmap; automaticamente (consulte <link linkend="chapter_dependencies"
>a seção sobre dependências</link
>). </para>
	<programlisting
>&lt;componentes&gt;
        </programlisting>
	<para
>Componentes? Não estamos falando de plugins? Sim, mas no futuro, os plugins serão apenas uma classe especial de componentes. O que fazemos aqui, então, é registrar todos os componentes/plugins com &rkward;. Vejamos um exemplo de entrada: </para>
	<programlisting
>&lt;component type="standard" id="t_test_duas_vars" file="t_test_duas_vars.xml" label="t-Test com duas variáveis" /&gt;
        </programlisting>
	<para
>Primeiro, o atributo <parameter
>type</parameter
>: Deixe-o com <replaceable
>"standard"</replaceable
> por enquanto. Outros tipos ainda não foram implementados. O <parameter
>id</parameter
> já foi mencionado. Cada componente precisa de um identificador único (em seu namespace). Escolha um que seja facilmente reconhecível. Evite espaços e caracteres especiais. Eles não são proibidos, até o momento, mas podem ter significados especiais. Com o atributo <parameter
>file</parameter
>, você especifica onde a <link linkend="mainxml"
>descrição do próprio plugin</link
> está localizada. Isso é relativo ao diretório onde o arquivo &pluginmap; está localizado e ao <parameter
>base_prefix</parameter
> acima. Finalmente, dê ao componente um rótulo. Este rótulo será exibido onde quer que o plugin seja colocado no menu (ou, no futuro, talvez em outros lugares também). </para>
	<para
>Normalmente, um arquivo &pluginmap; contém vários componentes, então aqui estão mais alguns: </para>
	<programlisting
>&lt;component type="standard" id="teste_nao_implementado" file="means/nao_implementado.xml" /&gt;
                &lt;component type="standard" id="t_test_ficticio" file="means/ttests/ficticio.xml" label="Este é um t-test fictício" /&gt;
                &lt;component type="standard" id="descritivo" file="descritivo.xml" label="Estatísticas descritivas" /&gt;
                &lt;component type="standard" id="corr_matriz" file="corr_matriz.xml" label="Correlação da matriz" /&gt;
                &lt;component type="standard" id="simples_anova" file="simples_anova.xml" label="Simples Anova" /&gt;
        &lt;/components&gt;
        </programlisting>
	<para
>OK, este foi o primeiro passo. O &rkward; agora sabe que esses plugins existem. Mas como invocá-los? Eles precisam ser colocados em uma hierarquia de menus: </para>
	<programlisting
>&lt;hierarchy&gt;
                &lt;menu id="analysis" label="Análise"&gt;
        </programlisting>
	<para
>Logo abaixo da tag <command
>&lt;hierarchy&gt;</command
>, você começa a descrição de em qual <command
>&lt;menu&gt;</command
> seus plugins devem estar. Com a linha acima, você basicamente diz que seu plugin deve estar no menu <menuchoice
><guimenu
>Análise</guimenu
></menuchoice
> (não necessariamente diretamente lá, mas em um submenu). O menu <menuchoice
><guimenu
>Análise</guimenu
></menuchoice
> é padrão no &rkward;, então ele não precisa ser criado do zero. No entanto, se ele ainda não existir, você pode usar o atributo <parameter
>label</parameter
> para dar um nome a ele. Finalmente, o <parameter
>id</parameter
> identifica novamente este <command
>&lt;menu&gt;</command
>. Isso é necessário para que vários arquivos &pluginmap; possam colocar seus plugins nos mesmos menus. Eles fazem isso procurando por um <command
>&lt;menu&gt;</command
> com o <parameter
>id</parameter
> fornecido. Se o ID ainda não existir, um novo menu será criado. Caso contrário, as entradas serão adicionadas ao menu existente. </para>
	<programlisting
>&lt;menu id="means" label="Métodos"&gt;
        </programlisting>
	<para
>Basicamente a mesma coisa aqui: Agora definimos um submenu para o menu <menuchoice
><guimenu
>Análise</guimenu
></menuchoice
>. Ele será chamado <menuchoice
><guimenuitem
>Métodos</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="ttests" label="Testes-t"&gt;
        </programlisting>
	<para
>E um nível final na hierarquia do menu: Um submenu do submenu <menuchoice
><guimenuitem
>Métodos</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;entry component="teste_t_duas_vars" /&gt;
        </programlisting>
	<para
>Agora, finalmente, este é o menu em que queremos colocar o plugin. A tag <command
>&lt;entry&gt;</command
> indica que este é realmente o item, e não outro submenu. O atributo <parameter
>component</parameter
> refere-se ao <parameter
>id</parameter
> que você atribuiu ao plugin/componente acima. </para>
	<programlisting
>&lt;entry component="teste_t_ficticio" /&gt;
                                &lt;/menu&gt;
                                &lt;entry component="teste_t_ficticio" /&gt;
                        &lt;/menu&gt;
                        &lt;menu id="frequency" label="Frequência" index="2"/&gt;
        </programlisting>
	<para
>Caso você tenha se perdido: Este é outro submenu do menu <menuchoice
><guimenu
>Análise</guimenu
></menuchoice
>. Veja a captura de tela abaixo. Vamos pular algumas opções que não estão visíveis, marcadas com [...]. </para>
	<programlisting
>[...]
                        &lt;/menu&gt;
                        &lt;entry component="corr_matrix"/&gt;
                        &lt;entry component="descriptive"/&gt;
                        &lt;entry component="simple_anova"/&gt;
                &lt;/menu&gt;
        </programlisting>
	<para
>Estas são as entradas finais visíveis nas capturas de tela abaixo. </para>
	<programlisting
>&lt;menu id="plots" label="Gráficos"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>É claro que você também pode colocar seus plugins em menus diferentes de <menuchoice
><guimenu
>Análise</guimenu
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="file" label="Arquivo"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Mesmo em menus padrão como <menuchoice
><guimenu
>Arquivo</guimenu
></menuchoice
>. Tudo o que você precisa é do <parameter
>id</parameter
> correto. </para>
	<programlisting
>&lt;/hierarchy&gt;        
&lt;/document&gt;
        </programlisting>
	<para
>É assim que se faz. E esta captura de tela mostra o resultado: </para>
	<screenshot>
	<screeninfo
>Hierarquia de menus criada pelo código mostrado acima</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Hierarquia de menus criada pelo código mostrado acima</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Confuso? A maneira mais fácil de começar provavelmente é pegar alguns dos arquivos &pluginmap; existentes que acompanham a distribuição e modificá-los de acordo com suas necessidades. Além disso, se precisar de ajuda, não hesite em escrever para a lista de discussão de desenvolvimento. </para>
	<sect1 id="pluginmap_grouping"
><title
>Controlar a ordem dos itens do menu</title>
		<para
>Por padrão, todos os itens (entradas/submenus) dentro de um menu serão classificados alfabeticamente, automaticamente. Em <emphasis
>alguns</emphasis
> casos, você pode querer ter mais controle. Nesse caso, você pode agrupar os elementos da seguinte forma:</para>
		<itemizedlist>
			<listitem>
				<para
>Você pode definir grupos dentro de qualquer menu desta forma. Todos os elementos pertencentes ao mesmo grupo serão agrupados:</para>
				<programlisting
>&lt;group id="algumgrupo"/&gt;
                                </programlisting>
			</listitem
><listitem>
			<para
>Se você deseja que o grupo seja visualmente separado das outras entradas, use:</para>
				<programlisting
>&lt;group id="algumgrupo" separated="true"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Entradas, menus e grupos podem ser adicionados a um grupo específico, usando:</para>
				<programlisting
>&lt;entry component="..." group="algumgrupo"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Na verdade, também é possível definir grupos (sem linhas separadoras) implicitamente:</para>
				<programlisting
>&lt;entry component="primeiro" group="a"/&gt;
                &lt;entry component="terceiro"/&gt;
                &lt;entry component="segundo" group="a"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Os nomes dos grupos são específicos para cada menu. O grupo "a" no menu "Dados" não entra em conflito com o grupo "a" no menu "Análise", por exemplo.</para>
			</listitem
><listitem>
				<para
>O caso de uso mais comum é a definição de grupos na parte superior ou inferior de um menu. Para isso, existem grupos predefinidos "superior" e "inferior" em cada menu.</para>
			</listitem
><listitem>
				<para
>As entradas dentro de cada grupo são classificadas em ordem alfabética. Os grupos aparecem na ordem de declaração (a menos que sejam anexados a outro grupo, é claro).</para>
			</listitem
><listitem>
				<para
>Menus e entradas sem especificação de grupo formam logicamente um grupo (""), também.</para>
			</listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="mainxml">
<title
>Definir a &GUI;</title>
<sect1 id="sect_defining_the_GUI"
><title
>Definir um diálogo</title>
	<para
>No <link linkend="pluginmap"
>capítulo anterior</link
> você viu como registrar um plugin com o &rkward;. O ingrediente mais importante foi especificar o caminho para um arquivo &XML; com uma descrição de como o plugin realmente se parece. Neste capítulo, você aprenderá como criar este arquivo &XML;. </para>
	<tip>
		<para
>Após ler este capítulo, dê uma olhada também no <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
>. Ele fornece algumas funções &R; para criar a maioria das tags &XML; do &rkward; para você. </para>
	</tip>
	<para
>Mais uma vez, vamos apresentar um exemplo. O exemplo é uma versão (ligeiramente simplificada) do teste t de duas variáveis. </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
        </programlisting>
	<para
>O doctype não é realmente interpretado. Defina-o como <replaceable
>rkplugin</replaceable
>, mesmo assim. </para>
	<programlisting
>&lt;document&gt;
        &lt;code file="t_test_duas_vars.js"/&gt;
        </programlisting>
	<para
>Todos os plugins geram algum código. Atualmente, a única maneira de fazer isso é usando JS, como detalhado no <link linkend="jstemplate"
>próximo capítulo</link
>. Isso define onde procurar o código JS. O nome do arquivo é relativo ao diretório onde o plugin &XML; está localizado. </para>
	<programlisting
>&lt;help file="t_test_duas_vars.rkh"/&gt;
        </programlisting>
	<para
>Geralmente é uma boa ideia também fornecer uma página de ajuda para o seu plugin. O nome do arquivo dessa página de ajuda é fornecido aqui, relativo ao diretório onde o plugin &XML; está localizado. A criação de páginas de ajuda está documentada <link linkend="pluginhelp"
>aqui</link
>. Se você não fornecer um arquivo de ajuda, omita esta linha. </para>
	<programlisting
>&lt;dialog label="Teste t com duas variáveis"&gt;
        </programlisting>
	<para
>Como você sabe, os plugins podem ter uma interface de diálogo, uma interface de assistente ou ambas. Aqui, começamos a definir uma interface de diálogo. O atributo <parameter
>label</parameter
> especifica o título do diálogo. </para>
	<programlisting
>&lt;tabbook&gt;
                        &lt;tab label="Configurações básicas"&gt;
        </programlisting>
	<para
>Os elementos da &GUI; podem ser organizados usando um catálogo de abas. Aqui, definimos um catálogo de abas como o primeiro elemento da caixa de diálogo. Use <command
>&lt;tabbook&gt;</command
>[...]<command
>&lt;/tabbook&gt;</command
> para definir o catálogo de abas e, em seguida, para cada página do catálogo de abas, use <command
>&lt;tab&gt;</command
>[...]<command
>&lt;/tab&gt;</command
>. O atributo <parameter
>label</parameter
> no elemento <command
>&lt;tab&gt;</command
> permite especificar uma legenda para essa página do catálogo de abas. </para>
	<programlisting
>&lt;row id="main_settings_row"&gt;
        </programlisting>
	<para
>As tags <command
>&lt;row&gt;</command
> e <command
>&lt;column&gt;</command
> especificam o layout dos elementos da &GUI;. Aqui, você indica que gostaria de colocar alguns elementos lado a lado (da esquerda para a direita). O atributo <parameter
>id</parameter
> não é estritamente necessário, mas o utilizaremos posteriormente, ao adicionar uma interface de assistente ao nosso plugin. O primeiro elemento a ser colocado na linha é: </para>
	<programlisting
>&lt;varselector id="vars"/&gt;
        </programlisting>
	<para
>Usando esta tag simples, você cria uma lista da qual o usuário pode selecionar variáveis. Você precisa especificar um <parameter
>id</parameter
> para este elemento, para que o &rkward; saiba como encontrá-lo. </para>
	<warning>
		<para
>Você NÃO pode usar um ponto (.) na string <parameter
>id</parameter
>. </para>
	</warning>
	<programlisting
>&lt;column&gt;
        </programlisting>
	<para
>Em seguida, aninhamos uma <command
>&lt;column&gt;</command
> dentro da linha. Ou seja, os elementos seguintes serão colocados uns acima dos outros (de cima para baixo), e todos ficarão à direita do <command
>&lt;varselector&gt;</command
>. </para>
	<programlisting
>&lt;varslot types="number" id="x" source="vars" required="true" label="comparar"/&gt;
                                                &lt;varslot types="number" id="y" source="vars" required="true" label="contra" i18n_context="comparar contra"/&gt;
        </programlisting>
	<para
>Esses elementos são a contraparte do <command
>&lt;varselector&gt;</command
>. Eles representam <quote
>slots</quote
> nos quais o usuário pode inserir variáveis. Você notará que o <parameter
>source</parameter
> é definido com o mesmo valor que o <parameter
>id</parameter
> do <command
>&lt;varselector &gt;</command
>. Isso significa que os <command
>&lt;varslot&gt;</command
>s obterão suas variáveis ​​do varselector. Os <command
>&lt;varslot&gt;</command
>s também precisam receber um <parameter
>id</parameter
>. Eles podem ter um <parameter
>label</parameter
> e podem ser definidos como <parameter
>required</parameter
>. Isso significa que o botão <guibutton
>Enviar</guibutton
> não será habilitado até que o <command
>&lt;varslot&gt;</command
> contenha um valor válido. Finalmente, o atributo <parameter
>type</parameter
> ainda não foi interpretado, mas será usado para garantir que apenas os tipos corretos de variáveis ​​sejam permitidos no <command
>&lt;varslot&gt;</command
>. </para>
	<para
>Caso você esteja se perguntando sobre o atributo <parameter
>i18n_context</parameter
>: Ele serve para fornecer contexto e auxiliar na tradução correta da palavra "against", usada como rótulo do <command
>&lt;varslot&gt;</command
>, mas não afeta diretamente a funcionalidade do plugin. Mais informações sobre isso em <link linkend="i18n_general"
>um capítulo separado</link
>. </para>
	<programlisting
>&lt;radio id="hypothesis" label="usar hipótese de teste"&gt;
                                                        &lt;option value="two.sided" label="Dois lados"/&gt;
                                                        &lt;option value="greater" label="Primeiro é maior"/&gt;
                                                        &lt;option value="less" label="Segundo é maior"/&gt;
                                                &lt;/radio&gt;
        </programlisting>
	<para
>Aqui, você define um grupo de botões exclusivos <command
>&lt;radio&gt;</command
>. O grupo possui um <parameter
>label</parameter
> e um <parameter
>id</parameter
>. Cada <command
>&lt;option&gt;</command
> (botão) possui um <parameter
>label</parameter
> e recebe um <parameter
>value</parameter
>. Este é o valor que o elemento <command
>&lt;radio&gt;</command
> retornará quando a opção for selecionada. </para>
	<programlisting
>&lt;/column&gt;
                                &lt;/row&gt;
                        &lt;/tab&gt;
        </programlisting>
	<para
>Cada tag precisa ser fechada. Colocamos todos os elementos que queríamos (os dois <command
>&lt;varslots&gt;</command
> e o <command
>&lt;radio&gt;</command
>) no <command
>&lt;column&gt;</command
>. Colocamos todos os elementos que queríamos (o <command
>&lt;varselector&gt;</command
> e o <command
>&lt;column&gt;</command
> com esses elementos) no <command
>&lt;row&gt;</command
>. E colocamos todos os elementos que queríamos na primeira página no <command
>&lt;tabbook&gt;</command
>. Ainda não terminamos de definir o <command
>&lt;tabbook&gt;</command
> (mais páginas virão), e é claro que também há mais por vir no <command
>&lt;dialog&gt;</command
>. Mas esta captura de tela mostra basicamente o que fizemos até agora: </para>
	<screenshot>
	<screeninfo
>Plugin de Teste t</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="t_test_plugin_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Plugin de Teste t</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Observe que não especificamos os botões <guibutton
>Submit</guibutton
>, <guibutton
>Close</guibutton
>, &etc;, nem a visualização do código. Esses elementos são gerados automaticamente. Mas, é claro, ainda precisamos definir a segunda página do <command
>&lt;tabbook&gt;</command
>: </para>
	<programlisting
>&lt;tab label="Options"&gt;
                                &lt;checkbox id="varequal" label="assumir variâncias iguais" value=", var.equal=TRUE"/&gt;
        </programlisting>
	<para
>Por padrão, os elementos serão dispostos de cima para baixo, como em uma <command
>&lt;column&gt;</command
>. Como é isso que queremos aqui, não precisamos declarar explicitamente um layout <command
>&lt;row&gt;</command
> ou <command
>&lt;column&gt;</command
>. O primeiro elemento que definimos é uma caixa de seleção. Assim como os <command
>&lt;radio&gt;</command
><command
>&lt;option&gt;</command
>s, a caixa de seleção tem um <parameter
>label</parameter
> e um <parameter
>value</parameter
>. O <parameter
>value</parameter
> é o que é retornado se a caixa de seleção estiver marcada. Obviamente, a caixa de seleção também precisa de um <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;frame label="Intervalo de confiança" id="frame_conf_int"&gt;
        </programlisting>
	<para
>Aqui está mais um elemento de layout: Para sinalizar que os dois elementos abaixo pertencem ao mesmo conjunto, desenhamos uma <command
>&lt;frame&gt;</command
> (caixa). Esse quadro pode ter um <parameter
>label</parameter
> (legenda). Como o quadro é apenas um elemento de layout passivo, ele não precisa de um <parameter
>id</parameter
>, mas ainda assim definimos um aqui, pois nos referiremos a ele mais tarde, ao definir uma interface de assistente adicional. </para>
	<programlisting
>&lt;checkbox id="confint" label="imprimir intervalo de confidência" value="1" checked="true"/&gt;
                                        &lt;spinbox type="real" id="conflevel" label="nível de confidência" min="0" max="1" initial="0.95"/&gt;
                                &lt;/frame&gt;
        </programlisting>
	<para
>Dentro do <command
>&lt;frame&gt;</command
>, colocamos outro <command
>&lt;checkbox&gt;</command
> (usando <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, sinalizamos que a caixa de seleção deve estar marcada por padrão) e um <command
>&lt;spinbox&gt;</command
>. O spinbox permite que o usuário selecione um valor entre <replaceable
>"min"</replaceable
> e <replaceable
>"max"</replaceable
>, com o valor padrão/inicial <replaceable
>"0.95"</replaceable
>. Definir o parâmetro <parameter
>type</parameter
> como <replaceable
>"real"</replaceable
> indica que números reais são aceitos em oposição a <parameter
>type=</parameter
><replaceable
>"integer"</replaceable
>, que aceitaria apenas números inteiros. </para>
	<note
><para
>Também é possível, e muitas vezes preferível, tornar o próprio <command
>&lt;frame&gt;</command
> selecionável, em vez de adicionar um <command
>&lt;checkbox&gt;</command
> dentro dele. Consulte a referência para obter detalhes. Isso não foi feito aqui, para fins ilustrativos. </para
></note>
	<programlisting
>&lt;/tab&gt;
                &lt;/tabbook&gt;
        &lt;/dialog&gt;
        </programlisting>
	<para
>Isso é tudo para a segunda página do <command
>&lt;tabbook&gt;</command
>, todas as páginas do <command
>&lt;tabbook&gt;</command
> e todos os elementos do <command
>&lt;dialog&gt;</command
>. Terminamos de definir a aparência do diálogo. </para>
	<programlisting
>&lt;/document&gt;
        </programlisting>
	<para
>Finalmente, fechamos a tag <command
>&lt;document&gt;</command
>, e isso é tudo. A &GUI; está definida. Você pode salvar o arquivo agora. Mas como a sintaxe &R; é gerada a partir das configurações da &GUI;? Abordaremos isso no <link linkend="jstemplate"
>próximo capítulo</link
>. Primeiro, porém, vamos examinar a adição de uma interface de assistente e algumas considerações gerais. </para>
</sect1>

<sect1 id="wizard_interface">
	<title
>Adicionar uma interface de assistente</title>
	<para
>Na verdade, não precisamos definir uma interface adicional <command
>&lt;wizard&gt;</command
>, mas aqui está como isso seria feito. Para adicionar uma interface de assistente, você adicionará uma tag <command
>&lt;wizard&gt;</command
> no mesmo nível da tag <command
>&lt;dialog&gt;</command
>: </para>
	<programlisting
>&lt;wizard label="Teste t com duas variáveis"&gt;
                        &lt;page id="firstpage"&gt;
                                &lt;text&gt;Como primeiro passo, selecione as duas variáveis que deseja comparar.
                                        E especifique qual você irá teorizar como a maior. Selecione dois lados,
                                        se sua teoria não te informa qual variável é maior.&lt;/text&gt;
                                &lt;copy id="main_settings_row"/&gt;
                        &lt;/page&gt;
        </programlisting>
	<para
>Parte disso é bastante autoexplicativo: adicionamos uma tag <command
>&lt;wizard&gt;</command
> com um <parameter
>label</parameter
> para o assistente. Como um assistente pode conter várias páginas que são exibidas uma após a outra, em seguida, definimos a primeira <command
>&lt;page&gt;</command
> e inserimos uma nota explicativa <command
>&lt;text&gt;</command
> nela. Depois, usamos uma tag <command
>&lt;copy&gt;</command
>. O que isso faz é, na verdade, nos poupar de definir novamente o que já escrevemos para o <command
>&lt;dialog&gt;</command
>: a tag copy procura outra tag com o mesmo <parameter
>id</parameter
> anteriormente no &XML;. Isso é definido na seção <command
>&lt;dialog&gt;</command
> e é uma <command
>&lt;row&gt;</command
> na qual estão o <command
>&lt;varselector&gt;</command
>, <command
>&lt;varslots&gt;</command
> e o <quote
>hypothesis</quote
> <command
>&lt;radio&gt; </command
> controle. Tudo isso é copiado 1:1 e inserido diretamente no elemento <command
>&lt;copy&gt;</command
>. </para>
	<para
>Agora a segunda página: </para>
	<programlisting
>&lt;page id="secondpage"&gt;
                                &lt;text&gt;Abaixo estão algumas opções avançadas. É normalmente seguro não considerar que as
                                        variáveis possuam variâncias iguais. Uma correção apropriada será aplicada então.
                                        Escolher "assumir variâncias iguais" pode aumentar a força do teste, no entanto.&lt;/text&gt;
                                &lt;copy id="varequal"/&gt;
                                &lt;text&gt;Algumas vezes é útil estimar o intervalo de confidência da
                                        diferença em significado. Abaixo você pode especificar se uma deve ser exibida, e
                                        qual nível de confidência deve ser aplicado (95% corresponde a um nível de significância de 
                                        5%).&lt;/text&gt;
                                &lt;copy id="frame_conf_int"/&gt;
                        &lt;/page&gt;
                &lt;/wizard&gt;
        </programlisting>
	<para
>Aqui, praticamente a mesma coisa. Adicionamos alguns textos e, entre eles, <command
>&lt;copy&gt;</command
> outras seções da interface de diálogo. </para>
	<para
>Você pode, é claro, fazer com que a interface do assistente tenha uma aparência muito diferente da caixa de diálogo simples, e até mesmo não usar a tag <command
>&lt;copy&gt;</command
>. Certifique-se, no entanto, de atribuir o mesmo <parameter
>id</parameter
> aos elementos correspondentes em ambas as interfaces. Isso não só é usado para transferir configurações da interface da caixa de diálogo para a interface do assistente e vice-versa, quando o usuário alterna entre as interfaces (o que ainda não acontece na versão atual do &rkward;), mas também simplifica a escrita do seu modelo de código (veja abaixo). </para>
</sect1>

<sect1 id="mainxmltips">
	<title
>Algumas considerações sobre design da &GUI;</title>
	<para
>Esta seção contém algumas considerações gerais sobre quais elementos da &GUI; usar e onde usá-los. Se esta for sua primeira tentativa de criar um plugin, sinta-se à vontade para pular esta seção, pois ela não é relevante para o funcionamento básico da &GUI;. Volte aqui mais tarde para ver se você consegue refinar a interface gráfica do seu plugin de alguma forma. </para>
	
	<sect2 id="radio_vs_checkbox_vs_dropdown">
		<title
>&lt;radio&gt; vs. &lt;checkbox&gt; vs. &lt;dropdown&gt;</title>
		<para
>Os três elementos <command
>&lt;radio&gt;</command
>, <command
>&lt;checkbox&gt;</command
>, <command
>&lt;dropdown&gt;</command
>, todos têm uma função semelhante: selecionar uma entre várias opções. Obviamente, uma caixa de seleção (checkbox) permite escolher apenas entre duas opções: marcada ou desmarcada, portanto, você não pode usá-la se houver mais de duas opções para escolher. Mas quando usar cada um dos elementos? Algumas regras práticas: </para>
		<para
>Se você se deparar com a criação de um <command
>&lt;radio&gt;</command
> ou <command
>&lt;dropdown&gt;</command
> com apenas duas opções, pergunte-se se a pergunta é essencialmente uma questão de sim/não. Por exemplo, uma escolha entre <quote
>ajustar resultados</quote
> e <quote
>não ajustar resultados</quote
>, ou entre <quote
>remover valores ausentes</quote
> e <quote
>manter valores ausentes</quote
>. Nesse caso, um <command
>&lt;checkbox&gt;</command
> é a melhor opção: ocupa pouco espaço, terá o menor número de palavras nos rótulos e é mais fácil de ler para o usuário. Existem pouquíssimas situações em que você deve escolher um <command
>&lt;radio&gt;</command
> ao invés de um <command
>&lt;checkbox&gt;</command
>, quando há apenas duas opções. Um exemplo disso seria: <quote
>Método de cálculo: 'pearson'/'spearman'</quote
>. Aqui, outros métodos podem ser considerados, e eles não formam exatamente um par de opostos. </para>
		<para
>A escolha entre um <command
>&lt;radio&gt;</command
> e um <command
>&lt;dropdown&gt;</command
> é, em grande parte, uma questão de espaço. O <command
>&lt;dropdown&gt;</command
> tem a vantagem de ocupar pouco espaço, mesmo que haja muitas opções para escolher. Por outro lado, um <command
>&lt;radio&gt;</command
> tem a vantagem de tornar todas as opções possíveis visíveis ao usuário de uma só vez, sem precisar clicar na seta do menu suspenso. Geralmente, se houver seis ou mais opções para escolher, um <command
>&lt;dropdown&gt;</command
> é preferível. Se houver cinco ou menos opções, um <command
>&lt;radio&gt;</command
> é a melhor escolha. </para>
	</sect2>
</sect1>
</chapter>

<chapter id="jstemplate">
<title
>Gerar código &R; a partir de configurações da &GUI;</title>
<sect1 id="sect_generating_R_code"
><title
>Usar &javascript; em plugins do &rkward;</title>
	<para
>Agora temos uma &GUI; definida, mas ainda precisamos gerar algum código &R; a partir dela. Para isso, precisamos de outro arquivo de texto, <filename
>code.js</filename
>, localizado no mesmo diretório que o arquivo <link linkend="mainxml"
><filename
>description.xml</filename
></link
>. Você pode ou não estar familiarizado com o &javascript; (ou, para ser tecnicamente preciso: ECMA-script). A documentação sobre JS pode ser encontrada em abundância, tanto impressa quanto na internet (&eg;: <ulink url="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide"
>https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide</ulink
>). Mas, para a maioria dos propósitos, você não precisará saber muito sobre JS, pois usaremos apenas alguns recursos básicos. </para>
	<tip>
		<para
>Após ler este capítulo, dê uma olhada também no pacote <link linkend="rkwarddev"
><application
>rkwarddev</application
></link
>. Ele fornece algumas funções em &R; para criar código &javascript; comumente usado no &rkward;. Ele também pode detectar automaticamente variáveis ​​usadas em um arquivo &XML; de plugin e criar código &javascript; básico a partir disso para você começar. </para>
	</tip>
	<note>
		<para
>Os arquivos de plugin <literal role="extension"
>.js</literal
> são considerados codificados em UTF-8. Verifique a codificação do seu editor caso esteja usando caracteres não-ASCII. </para>
	</note>
	<para
>Para o teste t de duas variáveis, o arquivo <filename
>code.js</filename
> tem a seguinte aparência (com comentários entre as linhas): </para>
	<sect2 id="sect_JS_preprocess"
><title
>preprocess()</title>
		<programlisting
>function preprocess () {
}
                </programlisting>
		<para
>O arquivo JS está organizado em três funções separadas: <function
>preprocess()</function
>, <function
>calculate()</function
> e <function
>printout()</function
>. Isso ocorre porque nem todo o código é necessário em todos os estágios. Atualmente, a função preprocess não é realmente usada em muitos lugares (normalmente você a omitirá completamente). </para>
	</sect2>
	<sect2 id="sect_JS_calculate"
><title
>calculate()</title>
		<programlisting
>function calculate () {
        echo ('res &lt;- t.test (x=' + getString ("x") + ', y=' + getString ("y") + ', hypothesis="' + getString ("hypothesis") + '"' + getString ("varequal"));
        var conflevel = getString ("conflevel");
        if (conflevel != "0.95") echo (', conf.level=' + conflevel);
        echo (')\n');
}
                </programlisting>
		<para
>Esta função gera a sintaxe real do &R; a ser executada a partir das configurações da &GUI;. Vamos analisar isso em detalhes: O código a ser usado é gerado usando a instrução <function
>echo()</function
>. Analisando a instrução <function
>echo()</function
> passo a passo, a primeira parte dela é </para>
		<screen
>res &lt;- t.test (
                </screen>
		<para
>como texto simples. Em seguida, precisamos preencher o valor que o usuário selecionou como a primeira variável. Buscamos isso usando <function
>getString ("x")</function
>, e o anexamos à string a ser <quote
>exibida</quote
>. Isso imprime o valor do elemento &GUI; com <parameter
>id=</parameter
><replaceable
>"x"</replaceable
>: nosso primeiro <command
>&lt;checkbox&gt;</command
>. Em seguida, acrescentamos um ', ' e fazemos o mesmo para buscar o valor do elemento <replaceable
>"y"</replaceable
> - o segundo <command
>&lt;checkbox&gt;</command
>. Para a hipótese (o grupo <command
>&lt;radio&gt;</command
>), e a <command
>&lt;checkbox&gt;</command
> das variâncias iguais, o procedimento é muito semelhante. </para>
		<note>
			<para
>Em vez de concatenar strings usando o operador <command
>+</command
>, você também pode usar um "template literal", como este (observe que a string está entre crases (`)):</para>
			<programlisting
>echo(`res &lt;- t.test (x=${ getString("x") }, y=${ getString("y") }, hypothesis="${ getString("hypothesis") }"`); // etc.
                        </programlisting>
		</note>
		<para
>Observe que, em vez de concatenar os trechos de saída com <quote
>+</quote
>, você também pode usar várias instruções <function
>echo()</function
>. Tudo é impresso em uma única linha. Para inserir uma quebra de linha no código gerado, insira um <replaceable
>"\n"</replaceable
> na string exibida. Em teoria, você pode até mesmo gerar várias linhas com uma única instrução echo, mas, por favor, limite-se a uma linha (ou menos) de código gerado por cada <function
>echo()</function
>. </para>
		<note>
			<para
>Além de <function
>getString()</function
>, também existem as funções <function
>getBoolean()</function
>, que tentará retornar o valor como um booleano lógico (adequado para uso em uma instrução <function
>if()</function
>), e <function
>getList()</function
>, que tentará retornar dados em formato de lista em um <function
>Array()</function
> do JavaScript. Mostraremos exemplos dessas funções mais adiante.</para>
			<para
>Ao analisar os plugins existentes, você também encontrará muitos plugins usando <function
>getValue()</function
>, em vez de <function
>getString()</function
>, e na verdade os dois são <emphasis
>quase</emphasis
> idênticos. No entanto, usar <function
>getString()</function
>, <function
>getBoolean()</function
> e <function
>getList()</function
> é a prática recomendada desde a versão 0.6.1. </para>
		</note>
		<para
>A situação fica um pouco mais complexa para o nível de confiança. Por razões estéticas, não queremos especificar explicitamente o nível de confiança a ser usado, caso ele corresponda ao valor padrão. Portanto, em vez de imprimir o valor incondicionalmente, primeiro o armazenamos em uma variável. Em seguida, verificamos se essa variável difere de <replaceable
>0,95</replaceable
> e, em caso afirmativo, imprimimos um argumento adicional. Finalmente, exibimos um colchete de fechamento e uma quebra de linha: <replaceable
>")
"</replaceable
>. Isso é tudo para a função de cálculo. </para>
	</sect2>
	<sect2 id="sect_JS_printout"
><title
>printout()</title>
		<programlisting
>function printout () {
        echo ('rk.header (' + i18n ("Teste t com duas variáveis") + ')\n');
        echo ('rk.print (res)\n');
}
                </programlisting>
		<para
>E isso era tudo o que havia na função printout na maioria dos casos. <function
>rk.header()</function
> imprime um cabeçalho padrão para os resultados. Observe que nos arquivos <literal role="extension"
>.js</literal
>, você precisa marcar todas as strings traduzíveis manualmente, usando <command
>i18n()</command
> ou alguns comandos alternativos. Mais sobre isso no <link linkend="i18n_js"
>capítulo sobre internacionalização</link
>. Você também pode adicionar mais informações a isso, se desejar, por exemplo: </para>
		<programlisting
>function printout () {
        new Header (i18n ("Teste t com duas variáveis"))
                  .addFromUI ("varequal")
                  .add (i18n ("Nível de confiança"), getString ("conflevel"))  // Nota: escrito assim para fins ilustrativos. Mais automático:
        //        .addFromUI ("conflevel")
                  .print ();
echo ('rk.print (res)\n');
}
                </programlisting>
		<para
><function
>rk.print()</function
> utiliza o pacote R2HTML para fornecer saída formatada em &HTML;. Outra função útil é <function
>rk.results()</function
>, que também pode gerar diferentes tipos de tabelas de resultados. Em caso de dúvida, use <function
>rk.print()</function
> e pronto. A classe JS <function
>Header</function
> é uma função auxiliar em nível de JS para gerar uma chamada para <function
>rk.header()</function
> (basta dar uma olhada no código gerado). Em alguns casos, você pode querer chamar <function
>echo ('rk.header(...)')</function
> diretamente para imprimir um cabeçalho para sua saída. </para>
		<para
>Observe que, internamente, a saída é apenas um documento &HTML; simples neste momento. Portanto, você pode ser tentado a adicionar &HTML; personalizado usando <function
>rk.cat.output()</function
>. Embora isso funcione, por favor, não faça isso. O formato de saída pode mudar (&eg;, para ODF) no futuro, então é melhor não introduzir código específico de &HTML;. Em vez disso, mantenha as coisas simples com <function
>rk.header()</function
>, <function
>rk.print()</function
>, <function
>rk.results()</function
> e -- se necessário -- <function
>rk.print.literal()</function
>. Se esses não atenderem às suas necessidades de formatação, entre em contato conosco na lista de discussão para obter ajuda. </para>
		<para
>Parabéns! Você criou seu primeiro plugin. Continue lendo nos próximos capítulos para conhecer conceitos mais avançados. </para>
	</sect2>
</sect1>

<sect1 id="jsconventions">
<title
>Convenções, políticas e contexto</title>
	<para
>Existem muitas maneiras de escrever código &R; para uma determinada tarefa, e existem ainda mais maneiras de gerar esse código &R; a partir de JS. Como exatamente você fará isso, fica a seu critério. Ainda assim, existem algumas considerações que você deve seguir e informações básicas que você deve compreender. </para>

	<sect2 id="policylocal">
	<title
>Compreendendo o ambiente <function
>local()</function
></title>
		<para
>Na maioria das vezes, você precisará criar um ou mais objetos &R; temporários no código gerado pelo seu plugin. Normalmente, você não quer que eles sejam colocados no espaço de trabalho do usuário, podendo até mesmo sobrescrever variáveis ​​do usuário. Portanto, todo o código gerado pelo plugin é executado em um ambiente <function
>local()</function
> (consulte a página de ajuda do &R; sobre a função <function
>local()</function
>). Isso significa que todas as variáveis ​​que você criar serão temporárias e não serão salvas permanentemente. </para>
		<para
>Se o usuário solicitar explicitamente que uma variável seja salva, você precisará atribuir a esse objeto usando <function
>.GlobalEnv$objectname &lt;- valor</function
>. Em geral, não use o operador <function
>&lt;&lt;-</function
>. Ele não atribuirá necessariamente um valor em .GlobalEnv. </para>
		<para
>Uma armadilha importante é usar <function
>eval()</function
>. Aqui, você precisa observar que, por padrão, `eval` usará o ambiente atual para avaliação, &ie;, o ambiente local. Isso funcionará bem na maioria das vezes, mas nem sempre. Portanto, se você precisar usar <function
>eval()</function
>, provavelmente desejará especificar o parâmetro <parameter
>envir</parameter
>: <function
>eval(..., envir=globalenv()</function
>). </para>
	</sect2>

	<sect2 id="policyformatting">
	<title
>Formatação do código</title>
		<para
>O mais importante é que o seu código &R; gerado funcione, mas ele também deve ser fácil de ler. Portanto, preste atenção também à formatação. Algumas considerações: </para>
		<para
>As instruções &R; de nível superior normais devem ser alinhadas à esquerda. </para>
		<para
>As declarações em um bloco inferior devem ser recuadas com uma tabulação (veja o exemplo abaixo). </para>
		<para
>Se você fizer cálculos muito complexos, adicione comentários aqui e ali, especialmente para marcar seções lógicas. Observe que existe uma função dedicada <command
>comment()</command
> para inserir comentários traduzíveis no código gerado. </para>
		<para
>Por exemplo, o código gerado pode ter esta aparência. O mesmo código sem indentação ou comentários seria bastante difícil de ler, apesar de sua modesta complexidade: </para>
		<programlisting
># primeiro determine a oscilação e a rotação
my.wobble &lt;- wobble (x, y)
my.rotation &lt;- wobble.rotation (my.wobble, z)

# o método de seleção deve ser escolhido de acordo com a rotação
if (my.rotation &gt; wobble.rotation.limit (x)) {
        method &lt;- "foo"
        result &lt;- boggle.foo (my.wobble, my.rotation)
} else {
        method &lt;- "bar"
        result &lt;- boggle.bar (my.wobble, my.rotation)
}
                </programlisting>
	</sect2>

	<sect2 id="policysimplicity">
	<title
>Lidar com opções complexas</title>
		<para
>Muitos plugins podem fazer mais de uma coisa. Por exemplo, o plugin <quote
>Estatísticas Descritivas</quote
> pode calcular média, amplitude, soma, produto, mediana, comprimento, &etc; No entanto, normalmente o usuário escolherá apenas realizar alguns desses cálculos. Nesse caso, tente manter o código gerado o mais simples possível. Ele deve conter apenas partes relevantes para as opções que foram selecionadas. Para conseguir isso, aqui está um exemplo de um padrão de design comum de como você o usaria (em JS; aqui, "domean", "domedian" e "dosd" seriam elementos &lt;checkbox&gt;): </para>
		<programlisting
>function calculate () {
        echo ('x &lt;- &lt;' + getString ("x") + ')\n');
        echo ('results &lt;- list ()\n');

        if (getBoolean ("domean.state")) echo ("results$" + i18n ("Valor médio") + " &lt;- mean (x)\n");
        if (getBoolean ("domedian.state")) echo ("results$" + i18n ("Mediana") + " &lt;- median (x)\n");
        if (getBoolean ("dosd.state")) echo ("results$" + i18n ("Desvio padrão") + " &lt;- sd (x)\n");
        //...
}
                </programlisting>
	</sect2>
</sect1>

<sect1 id="jstips">
<title
>Dicas e truques</title>
	<para
>Aqui estão alguns truques variados que podem tornar a escrita de plugins menos tediosa: </para>
	<para
>Se você precisar do valor de uma configuração da &GUI;em vários lugares no código do seu plugin, considere atribuí-lo a uma variável em JS e usá-la em vez de buscá-lo repetidamente com <function
>getString()/getBoolean()/getList()</function
>. Isso é mais rápido, mais legível e requer menos digitação. </para>
	<programlisting
>function calculate () {
        var narm = "";        // na.rm=FALSE é o padrão em todas as funções abaixo
        if (getBoolean ("remove_nas")) {
                $narm = ", na.rm=TRUE";
        }
        // ...
        echo ("results$foo &lt;- foo (x" + narm + ")\n");
        echo ("results$bar &lt;- bar (x" + narm + ")\n");
        echo ("results$foobar &lt;- foobar (x" + narm "\n");
        // ...
}
        </programlisting>
	<para
>A função auxiliar simples <function
>makeOption()</function
> pode facilitar a omissão de parâmetros que já possuem seus valores padrão, em muitos casos: </para>
	<programlisting
>function calculate () {
        var options
        //...
        // Isso não fará nada se VALUE for 0,95 (o padrão). Caso contrário, adicionará ', conf.int=VALUE' às opções.
        options += makeOption ("conf.int", getString ("confint"), "0.95");
        //...
}
        </programlisting>
</sect1>
</chapter>

<chapter id="pluginhelp">
	<title
>Escrevendo uma página de ajuda</title>
	<para
>Quando seu plugin estiver basicamente funcionando, chegou a hora de fornecer uma página de ajuda. Embora normalmente você não queira explicar todos os conceitos subjacentes em detalhes, você pode querer adicionar mais explicações para algumas das opções, e links para plugins e funções relacionados. </para>
	<tip>
		<para
>Após ler este capítulo, dê uma olhada também no pacote <link linkend="rkwarddev"
><application
>rkwarddev</application
></link
>. Ele fornece algumas funções &R; para criar a maioria das tags &XML; do &rkward; para você. Ele também é capaz de criar estruturas básicas de arquivos de ajuda a partir de arquivos &XML; de plugins existentes para você começar. </para>
	</tip>
	<para
>Você deve se lembrar de ter colocado isso dentro do seu plugin &XML; (se você ainda não colocou isso, faça isso agora): </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;help file="nomearquivo.rkh" /&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>Onde, obviamente, você substituiria <filename
>nomearquivo</filename
> por um nome mais apropriado. Agora é hora de criar este arquivo <literal role="extension"
>.rkh</literal
>. Aqui está um exemplo autoexplicativo: </para>
	<programlisting
>&lt;!DOCTYPE rkhelp&gt;
&lt;document&gt;
        &lt;summary&gt;
Nesta seção, você colocará algumas informações básicas e resumidas sobre o que o plugin faz. Esta seção sempre aparecerá no topo da página de ajuda.
        &lt;/summary&gt;

        &lt;usage&gt;
A seção de uso pode conter informações um pouco mais práticas. Ela não explica todas as configurações
em detalhes (isso é feito na seção "configurações").

Para iniciar um novo parágrafo, insira uma linha em branco, como mostrado acima.
Esta linha, por outro lado, estará no mesmo parágrafo.

Em todas as seções, você pode inserir um código HTML simples, como &lt;b&gt;negrito&lt;b&gt; ou
texto &lt;i&gt;itálico&lt;i&gt;. Mantenha a formatação ao mínimo necessário.

A seção de uso é sempre a segunda seção exibida em uma página de ajuda.
        &lt;/usage&gt;

        &lt;section id="sectionid" title="Seção genérica" short_title="Genérica"&gt;
Se necessário, você pode adicionar seções adicionais entre as seções de uso e configurações.
No entanto, geralmente, você não precisará disso ao documentar plugins. O atributo "id"
fornece um ponto de ancoragem para acessar esta seção a partir do menu de navegação.
O atributo "short_title"
fornece um título curto para usar na barra de navegação. Isso é opcional. Por padrão,
o "title" principal será usado como cabeçalho da seção e como nome do link na
barra de navegação.

Em qualquer seção, você pode inserir links para mais informações. Para isso, adicione:

&lt;link href="URL"&gt;nome do link&lt;/link&gt;

Onde URL pode ser um link externo, como https://rkward.kde.org.

Vários URLs especiais são suportados nas páginas de ajuda:

&lt;link href="rkward://pagina/caminho/id_pagina"/&gt;

Este link leva a uma página de ajuda do rkward de nível superior (não para um plugin).

&lt;link href="rkward://componente/[namespace/]id_componente"/&gt;

Este link leva à página de ajuda de outro plugin. A parte [namespace/] pode ser omitida.
(neste caso, assume-se que rkward é o namespace padrão, por exemplo:
&lt;link href="rkward://componente/import_spss"/&gt; or
&lt;link href="rkward://componente/rkward/import_spss"/&gt; são equivalentes).
O id_componente é o mesmo que você especificou no <link linkend="pluginmap"
>&pluginmap;</link
>.

&lt;link href="rkward://rhelp/rfunction"/&gt;

Links para a página de ajuda do &R; sobre "rfunction".

Observe que os nomes dos links serão gerados automaticamente para esses tipos de links.
        &lt;/section&gt;

        &lt;settings&gt;
                &lt;caption id="id_da_aba_ou_quadro"/&gt;
                &lt;setting id="id_do_elemento"&gt;
Descrição do elemento da GUI identificado pelo ID fornecido
                &lt;/setting&gt;
                &lt;setting id="id_do_elementob" title="descrição"&gt;
Normalmente, o título do elemento da GUI será extraído da
<link linkend="mainxml"
>definição &XML; do plugin</link
> automaticamente. Entretanto,
para alguns elementos da interface gráfica, esta descrição pode não ser suficiente para identificá-los de forma confiável.
Nesse caso, você pode adicionar um título explícito usando o atributo "title".
                &lt;/setting&gt;
                &lt;setting id="id_do_elementoc"&gt;
Descrição do elemento da interface gráfica identificado por "id_do_elementoc"
                &lt;/setting&gt;
                [...]
        &lt;/settings&gt;

        &lt;related&gt;
A seção "related" geralmente contém apenas alguns links, como:

&lt;ul&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/meam"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/median"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://componente/compontente_relacionado"/&gt;&lt;/li&gt;
&lt;/ul&gt;
        &lt;/related&gt;

&lt;technical&gt;
A seção técnica (opcional, sempre a última) pode conter alguns detalhes técnicos da implementação do plugin,
que são de interesse apenas para os desenvolvedores do RKWard. Isso é particularmente relevante
para plugins projetados para serem incorporados em muitos outros plugins e pode detalhar quais
opções estão disponíveis para personalizar o plugin incorporado e quais seções de código contêm qual
código R.
        &lt;/technical&gt;
&lt;/document&gt;
        </programlisting>
</chapter>


<chapter id="logic">
<title
>Interações lógicas entre elementos da &GUI;</title>
<sect1 id="sect_GUI_logic"
><title
>Lógica da &GUI;</title>
	<para
>Todos os conceitos básicos para a criação de um plugin para o &rkward; foram descritos nos capítulos anteriores. Esses conceitos básicos devem ser suficientes para muitos casos, senão para a maioria. No entanto, às vezes você deseja mais controle sobre o comportamento da &GUI; do seu plugin. </para>
	<para
>Por exemplo, suponha que você queira estender o exemplo de teste t usado nesta documentação para permitir ambas as comparações: comparar uma variável com outra variável (como mostrado) e comparar uma variável com um valor constante. Uma maneira de fazer isso seria adicionar um botão de opção que alterna entre os dois modos e adicionar uma caixa de seleção para inserir o valor constante a ser comparado. Considere este exemplo simplificado: </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
&lt;document&gt;
        &lt;code file="code.js"/&gt;

        &lt;dialog label="T-Test"&gt;
                &lt;row&gt;
                        &lt;varselector id="vars"/&gt;
                        &lt;column&gt;
                                &lt;varslot id="x" types="number" source="vars" required="true" label="comparar"/&gt;
                                &lt;radio id="mode" label="Comparar contra"&gt;
                                        &lt;option value="variable" checked="true" label="outra variável (selecionar abaixo)"/&gt;
                                        &lt;option value="constant" label="um valor constante (definir abaixo)"/&gt;
                                &lt;/radio&gt;
                                &lt;varslot id="y" types="number" source="vars" required="true" label="variable" i18n_context="Nome; uma variável"/&gt;
                                &lt;spinbox id="constant" initial="0" label="constant" i18n_context="Nome; uma constante"/&gt;
                        &lt;/column&gt;
                &lt;/row&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Até aqui tudo bem, mas existem alguns problemas com esta &GUI;. Primeiro, tanto o varslot quanto o spinbox são sempre exibidos, embora apenas um dos dois seja realmente usado. Pior ainda, o varslot sempre requer uma seleção válida, mesmo se você comparar com uma constante. Obviamente, se criarmos uma &GUI; multiuso como esta, queremos mais flexibilidade. Insira: a seção <command
>&lt;logic&gt;</command
> (inserida no mesmo nível que <command
>&lt;code&gt;</command
>, <command
>&lt;dialog&gt;</command
> ou <command
>&lt;wizard&gt;</command
>). </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;

        &lt;logic&gt;
                &lt;convert id="varmode" mode="equals" sources="mode.string" standard="variable" /&gt;

                &lt;connect client="y.visible" governor="varmode" /&gt;
                &lt;connect client="constant.visible" governor="varmode.not" /&gt;
        &lt;/logic&gt;

        &lt;dialog label="Teste t"&gt;
        [...]
        </programlisting>
	<para
>A primeira linha dentro da seção de lógica é uma tag <command
>&lt;convert&gt;</command
>. Basicamente, isso fornece uma nova propriedade booleana (ligado ou desligado, verdadeiro ou falso), que pode ser usada posteriormente. Essa propriedade (<replaceable
>"varmode"</replaceable
>) é verdadeira sempre que o botão de opção superior estiver selecionado e falsa sempre que o botão de opção inferior estiver selecionado. Como isso é feito? </para>
	<para
>Primeiro, em <parameter
>sources</parameter
>, as propriedades de origem para trabalhar são listadas (neste caso, apenas uma de cada; você poderia listar várias como <parameter
>sources=</parameter
><replaceable
>"mode.string;somethingelse"</replaceable
>, então <replaceable
>"varmode"</replaceable
> seria verdadeiro apenas se <replaceable
>"mode.string"</replaceable
> e <replaceable
>"somethingelse"</replaceable
> forem iguais à string <replaceable
>"variable"</replaceable
>). Observe que, neste caso, não escrevemos apenas <replaceable
>"mode"</replaceable
> (como faríamos em <function
>getString("mode")</function
>), mas <replaceable
>"mode.string"</replaceable
>. Na verdade, este é o funcionamento interno de um controle remoto: Ele possui uma propriedade `string`, que armazena seu valor de string. `getString("mode")` é apenas uma abreviação e equivalente a `getString("mode.string")`. Consulte a referência para ver todas as propriedades dos diferentes elementos da GUI. </para>
	<para
>Em segundo lugar, definimos o modo de conversão para <parameter
>mode=</parameter
><replaceable
>"equals"</replaceable
>. Isso significa que queremos verificar se a(s) fonte(s) é(são) igual(is) a um determinado valor. Finalmente, o valor padrão é aquele com o qual comparar. Portanto, com <parameter
>standard=</parameter
><replaceable
>"variable"</replaceable
>, verificamos se a propriedade <replaceable
>"mode.string"</replaceable
> é igual à string <replaceable
>"variable"</replaceable
> (o valor da opção de rádio superior). Se for igual, a propriedade varmode será verdadeira; caso contrário, será falsa. </para>
	<para
>Agora vamos ao que interessa: Nós <command
>&lt;conect&gt;</command
> (conectamos) a propriedade <replaceable
>"varmode"</replaceable
> à propriedade y.visible, que controla se o elemento <replaceable
>"y" </replaceable
> do varslot é exibido ou não. Observe que qualquer elemento que se torne invisível é implicitamente não obrigatório. Portanto, se a opção de rádio superior estiver selecionada, o elemento <replaceable
>"y"</replaceable
> do varslot será obrigatório e visível. Caso contrário, ele não será obrigatório e permanecerá oculto. </para>
	<para
>Para o spinbox, queremos exatamente o inverso. Felizmente, não precisamos de outro <command
>&lt;convert&gt;</command
> para isso: propriedades booleanas podem ser negadas facilmente adicionando o modificador <replaceable
>"not"</replaceable
>, então <command
>&lt;connect&gt;</command
> <replaceable
>"varmode.not"</replaceable
> à propriedade visibility do spinbox. Na prática, ou o varslot é exibido e obrigatório, <emphasis
>ou</emphasis
> o spinbox é exibido e obrigatório - dependendo da opção selecionada no botão de opção. A &GUI; se altera de acordo com a opção do botão de opção. Experimente o exemplo, se quiser. </para>
	<para
>Para obter uma lista completa de propriedades, consulte a <link linkend="reference"
>referência</link
>. No entanto, existe mais uma propriedade especial que todos os elementos &GUI; possuem: <quote
>enabled</quote
>. Esta é ligeiramente menos drástica do que <quote
>visible</quote
>. Ela não mostra/oculta o elemento &GUI; mas apenas o ativa/desativa. Elementos desativados são normalmente exibidos em cinza e não reagem à entrada do usuário. </para>
	<note>
		<para
>Além de <command
>&lt;convert&gt;</command
> e <command
>&lt;connect&gt;</command
>, existem vários outros elementos para uso na seção <command
>&lt;logic&gt;</command
>. Por exemplo, construções condicionais também podem ser implementadas usando o elemento <command
>&lt;switch&gt;</command
>. Consulte a <link linkend="logicelements"
>referência sobre elementos lógicos</link
> para obter detalhes.</para>
	</note>
</sect1>
<sect1 id="logic_scripted">
<title
>Lógica da &GUI; com script</title>
	<para
>Embora conectar propriedades conforme descrito acima seja frequentemente suficiente, às vezes é mais flexível ou conveniente usar JS para programar a lógica da &GUI;. Dessa forma, o exemplo acima poderia ser reescrito como: </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;
'
        &lt;logic&gt;
                &lt;script&gt;&lt;![CDATA[
                        // [...] qualquer código no nível superior é chamado apenas uma vez.
                        gui.addChangeCommand("mode.string", function() {
                                // enquanto esta função anônima será chamada sempre que "mode.string" mudar
                                var varmode = (gui.getString("mode.string") == "variable");
                                gui.setValue("y.enabled", varmode);
                                gui.setValue("constant.enabled", !varmode);
                        });
                ]]&gt;&lt;/script&gt;
        &lt;/logic&gt;

        &lt;dialog label="Test t"&gt;
        [...]
        </programlisting>
	<para
>Isso registra uma função anônima a ser chamada sempre que o valor da caixa de seleção <parameter
>id=</parameter
><replaceable
>"mode"</replaceable
> mudar. Dentro dessa função, definimos uma variável auxiliar <replaceable
>"varmode"</replaceable
> que é verdadeira quando o modo é <replaceable
>"variable"</replaceable
> e falsa quando é <replaceable
>"constant"</replaceable
>. Em seguida, usamos <function
>gui.setValue()</function
> para definir as propriedades <quote
>enabled</quote
> de <replaceable
>"y"</replaceable
> e <replaceable
>"constant"</replaceable
>, da mesma forma que fizemos usando as instruções <command
>&lt;connect&gt;</command
> anteriormente. </para>
	<note
><para
>Se a mesma função precisar ser invocada para alterações em vários elementos, você também pode passar um array dos respectivos <parameter
>id=</parameter
>s para <command
>gui.addChangeCommand()</command
>. Além disso, para maior conveniência, <command
>gui.addChangeCommand()</command
> retorna seu segundo parâmetro, o que é útil se você quiser se referir a essa função em outro lugar (por exemplo, para <command
>gui.addChangeCommand()</command
> chamá-la uma vez durante a inicialização). Exemplo: </para>
	<programlisting
>let update = gui.addChangeCommand(["mode.string", "y.available"], function() {
                // faz algo a cada mudança de modo.string ou y.disponível
        });
        update(); // faz o mesmo durante a inicialização
        </programlisting>
	</note>
	<para
>A abordagem com scripts para lógica da &GUI; torna-se particularmente útil quando você deseja alterar a opção disponível de acordo com o tipo de objeto que o usuário selecionou. Consulte a <link linkend="guilogic_functions"
>referência</link
> para obter as funções disponíveis. </para>
	<para
>Observe que a abordagem com script para a lógica da GUI pode ser combinada com instruções <command
>&lt;connect&gt;</command
> e <command
>&lt;convert&gt;</command
> se desejar. Observe também que a tag <command
>&lt;script&gt;</command
> permite especificar um nome de arquivo de script, além de ou como alternativa à inclusão do código de script. Normalmente, a inclusão do código de script, como mostrado acima, é mais conveniente. </para>
</sect1>
</chapter>

<chapter id="embedding">
<title
>Embutindo plugins dentro de plugins</title>
<sect1 id="sect_embedding"
><title
>Casos de uso para embutir</title>
	<para
>Ao escrever plugins, você frequentemente perceberá que está criando vários plugins que diferem apenas em alguns aspectos, mas têm muito mais em comum. Por exemplo, para plotagem, existem várias opções &R; genéricas que podem ser usadas com praticamente todos os tipos de gráficos. Você deveria criar uma interface gráfica e um modelo em JavaScript para essas opções repetidamente? </para>
	<para
>Obviamente, isso seria bastante trabalhoso. Felizmente, você não precisa fazer isso. Em vez disso, você cria a funcionalidade comum uma vez e, posteriormente, pode incorporá-la em vários plugins. Na verdade, é possível incorporar qualquer plugin em qualquer outro plugin, mesmo que o autor original do plugin incorporado nunca tenha imaginado que alguém desejaria incorporar seu plugin em outro. </para>
</sect1>
<sect1 id="embedding_dialog">
<title
>Incorporar dentro de uma caixa de diálogo</title>
	<para
>Ok, chega de conversa. Como funciona? Simples: basta usar a tag <command
>&lt;embed&gt;</command
>. Aqui está um exemplo simplificado: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
                &lt;tab label="Opções de plotagem" i18n_context="Opções relativas à plotagem"&gt;
                        &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;/tab&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
        &lt;/tabbook&gt;
&lt;/dialog&gt;
        </programlisting>
	<para
>O que acontece aqui é que toda a &GUI; ou o plugin de opções de plotagem (exceto, é claro, os elementos padrão como o botão <guibutton
>Enviar</guibutton
>, &etc;) é incorporado diretamente ao seu plugin (experimente!). </para>
	<para
>Como você pode ver, a sintaxe da tag <command
>&lt;embed&gt;</command
> é bastante simples. Ela recebe um <parameter
>id</parameter
> como a maioria dos elementos. O componente especifica qual plugin incorporar, conforme definido no arquivo &pluginmap; (<replaceable
>"rkward::plot_options"</replaceable
> é o resultado da concatenação do namespace <quote
>rkward</quote
>, um separador <quote
>::</quote
> e o nome do componente <quote
>plot_options</quote
>). </para>
</sect1>
<sect1 id="embedding_code">
<title
>Geração de código ao incorporar</title>
	<para
>Até aqui tudo bem, mas e o código gerado? Como o código para o plugin de incorporação e o plugin incorporado são mesclados? No código JS do plugin de incorporação, basta escrever algo como: </para>
	<programlisting
>function printout () {
        // ...
        echo ("myplotfunction ([...]" + getString ("plotoptions.code.printout"); + ")\n");
        // ...
}
        </programlisting>
	<para
>Basicamente, estamos buscando o código gerado pelo plugin incorporado assim como buscamos qualquer outra configuração da &GUI;. Aqui, a string <replaceable
>"plotoptions.code.printout"</replaceable
> pode ser analisada para: <quote
>A seção de impressão do código gerado do elemento com o <parameter
>id</parameter
> plotoptions</quote
> (plotoptions é o ID que demos para a tag <command
>&lt;embed&gt;</command
> acima). E sim, se você quiser controle avançado, pode até buscar os valores de elementos individuais da &GUI; dentro do plugin incorporado (mas não o contrário, pois o plugin incorporado não sabe nada sobre o que está ao seu redor). </para>
</sect1>
<sect1 id="embedding_wizard">
<title
>Incorporação dentro de um assistente</title>
	<para
>Se o seu plugin fornecer um &GUI; de assistente, a incorporação funciona basicamente da mesma maneira. Geralmente você usará: </para>
	<programlisting
>&lt;wizard [...]&gt;
                [...]
                &lt;page id="page12"&gt;
                        [...]
                &lt;/page&gt;
                &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;page id="page13"&gt;
                        [...]
                &lt;/page&gt;
                [...]
        &lt;/wizard&gt;
        </programlisting>
	<para
>Se o plugin incorporado fornecer uma interface de assistente, suas páginas serão inseridas diretamente entre <replaceable
>"page12"</replaceable
> e <replaceable
>"page13"</replaceable
> do seu plugin. Se o plugin incorporado fornecer apenas uma interface de diálogo, uma única nova página será adicionada entre suas páginas <replaceable
>"page12"</replaceable
> e <replaceable
>"page13"</replaceable
>. O usuário nunca perceberá. </para>
</sect1>
<sect1 id="embedding_as_button">
<title
>Menos incorporação embutida: Botão de Opções adicionais</title>
	<para
>Embora incorporar elementos seja interessante, tenha cuidado para não exagerar. Muitas funções dentro de uma &GUI; dificultam a localização das opções relevantes. É claro que, às vezes, você pode querer incorporar muitas opções (como todas as opções de <function
>plot()</function
>), mas como elas são realmente opcionais, você não quer que elas fiquem em destaque na sua &GUI;. </para>
	<para
>Uma alternativa é incorporar essas opções <quote
>como um botão</quote
>: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                [...]
                &lt;tab label="Options"&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Specify plotting options"/&gt;
                &lt;/tab&gt;
                [...]
        &lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
	<para
>Neste caso, um único botão será adicionado ao seu plugin, rotulado como <guibutton
>Especificar opções de plotagem</guibutton
>. Ao pressionar esse botão, uma caixa de diálogo separada será exibida, com todas as opções do plugin incorporado. Mesmo que esta &GUI; incorporada não esteja visível na maior parte do tempo, você pode obter suas configurações conforme descrito <link linkend="embedding_code"
>acima</link
>. </para>
	<para>
		<caution>
			<para
>Provavelmente, a abordagem do <quote
>botão</quote
> só deve ser usada para plugins que nunca podem ser inválidos (por configurações ausentes/incorretas). Caso contrário, o usuário não conseguiria enviar o código, mas poderia ter dificuldade em descobrir o motivo, que está oculto atrás de algum botão. </para
>	
		</caution>
	</para>
</sect1>
<sect1 id="embedding_incomplete">
<title
>Incorporação/definição de plugins incompletos</title>
	<para
>Alguns plugins — e, aliás, o plot_options usado como exemplo acima é um deles — não são completos por si só. Eles simplesmente não têm os elementos de &GUI; para selecionar alguns valores importantes. Eles foram projetados para serem usados ​​apenas incorporados a outros plugins. </para>
	<para
>Até que ponto o plugin plot_options está incompleto? Bem, para algumas configurações de opções, ele precisa saber o nome dos objetos/expressões para os eixos x e y (na verdade, funcionará bem se tiver apenas um deles, mas precisa de pelo menos um para funcionar corretamente). No entanto, ele não possui um mecanismo para selecionar esses objetos ou inseri-los de qualquer outra forma. Então, como ele sabe sobre eles? </para>
	<para
>Na seção de lógica do plugin plot_options, existem duas linhas adicionais, ainda não abordadas: </para>
	<programlisting
>&lt;logic&gt;
                &lt;external id="xvar" /&gt;
                &lt;external id="yvar" /&gt;

                [...]
        &lt;/logic&gt;
        </programlisting>
	<para
>Isso define duas propriedades adicionais no plugin plot_options, cujo único propósito é ser conectado a algumas propriedades (ainda desconhecidas) do plugin de incorporação. No plugin plot_options, essas duas propriedades são simplesmente usadas como quaisquer outras e, por exemplo, existem chamadas para <function
>getString("xvar")</function
> no modelo JS do plot_options. </para>
	<para
>Agora, para o plugin incompleto, não há como saber onde ele será incorporado e quais serão os nomes das configurações relevantes no plugin de incorporação. Portanto, precisamos adicionar duas linhas adicionais na seção de lógica do plugin de incorporação: </para>
	<programlisting
>&lt;logic&gt;
                [...]

                &lt;connect client="plotoptions.xvar" governor="xvarslot.available" /&gt;
                &lt;connect client="plotoptions.yvar" governor="yvarslot.available" /&gt;
        &lt;/logic&gt;
        </programlisting>
	<para
>Em princípio, isso não é novidade; já abordamos as instruções <command
>&lt;connect&gt;</command
> no capítulo <link linkend="logic"
> da seção de lógica da &GUI;</link
>. Basta conectar os valores em dois varlots (chamados <replaceable
>"xvarslot"</replaceable
> e <replaceable
>"yvarslot"</replaceable
> neste exemplo) às propriedades <quote
>external</quote
> receptoras do plugin incorporado. É só isso. Todo o resto é tratado automaticamente. </para>
</sect1>
</chapter>

<chapter id="plugin_series">
<title
>Lidar com muitos plugins semelhantes</title>
<sect1 id="sect_similar_plugins"
><title
>Visão geral das diferentes abordagens</title>
	<para
>Às vezes, você pode querer desenvolver plugins para uma série de funções semelhantes. Por exemplo, considere os gráficos de distribuição. Eles geram código bastante similar e, claro, é desejável que as interfaces gráficas sejam semelhantes entre si. Finalmente, grandes seções dos arquivos de ajuda podem ser idênticas. Apenas alguns parâmetros são diferentes para cada plugin. </para>
	<para
>A abordagem ingênua para isso é desenvolver um plugin e, basicamente, copiar e colar todo o conteúdo dos arquivos <literal role="extension"
>.js</literal
>, <literal role="extension"
>.xml</literal
> e <literal role="extension"
>.rkh</literal
>, alterando apenas as poucas partes que são diferentes. No entanto, e se, algum tempo depois, você encontrar um erro de ortografia que foi copiado e colado em todos os plugins? E se você quiser adicionar suporte para um novo recurso? Você teria que visitar todos os plugins novamente e alterar cada um deles. Um processo cansativo e tedioso. </para>
	<para
>Uma segunda abordagem seria usar <link linkend="embedding"
>incorporação</link
>. No entanto, em alguns casos, isso não se presta bem ao problema em questão, principalmente porque os <quote
>pedaços</quote
> que você pode incorporar são às vezes muito grandes para serem úteis, e isso impõe algumas restrições ao layout. Para esses casos, os conceitos de <link linkend="include_js"
>incluir arquivos <literal role="extension"
>.js</literal
></link
>, <link linkend="include_xml"
>incluir arquivos <literal role="extension"
>.xml</literal
></link
> e <link linkend="snippets"
>snippets</link
> podem ser muito úteis (mas veja as <link linkend="include_snippets_vs_embedding"
>considerações sobre quando é preferível usar incorporação</link
>). </para>
	<para
>Uma palavra de cautela, antes de começar a ler: esses conceitos podem simplificar o gerenciamento de muitos plugins semelhantes e melhorar a manutenção e a legibilidade desses plugins. No entanto, exagerar pode facilmente levar ao efeito contrário. Use com cautela. </para>
</sect1>
<sect1 id="include_js">
<title
>Usando a instrução include do JavaScript</title>
	<para
>Você pode facilmente incluir um arquivo de script em outro em plugins do &rkward;. O valor disso se torna imediatamente óbvio se algumas seções do seu código JS forem semelhantes entre os plugins. Você pode simplesmente definir essas seções em um arquivo <literal role="extension"
>.js</literal
> separado e incluí-lo em todos os arquivos <literal role="extension"
>.js</literal
> do plugin. Por exemplo, como em: </para>
	<programlisting
>// este é um arquivo chamado "common_functions.js"

function doCommonStuff () {
        // talvez recebe algumas opções, etc.
        // ...
        comment ("Este é o código R que você deseja incluir em diversos plugins\n");
        // ...
}
        </programlisting>
	<programlisting
>// este é o do seu dos seus arquivos <literal role="extension"
>.js</literal
> do plugin normal

// inclui as funções comuns
include ("common_functions.js");

function calculate () {
        // faz alguma coisa
        // ...

        // inserir o código comum
        doCommonStuff ();
}
        </programlisting>
	<para
>Observe que, às vezes, é ainda mais útil inverter isso e definir o <quote
>esqueleto</quote
> das funçóes <function
>preprocess()</function
>, <function
>calculate()</function
> e <function
>printout()</function
> em um arquivo comum, e fazer com que essas funções chamem de volta as partes que são diferentes entre os plugins. Por exemplo: </para>
	<programlisting
>// este é um arquivo chamado "common_functions.js"

function calculate () {
        // faz algumas coisas que são o mesmo para todos os plugins
        // ...

        // adiciona algo que é diferente entre os plugins
        getSpecifics ();

        // ...
}
        </programlisting>
	<programlisting
>// este é o do seu dos seus arquivos <literal role="extension"
>.js</literal
> do plugin normal

// inclui as funções comuns
include ("common_functions.js");

// nota: nenhuma função calculate() é definida aqui.
// está em common_functions.js, ao invés.

function getSpecifics () {
        // imprime algum código R
}
        </programlisting>
	<para
>Uma questão que você deve ter em mente ao usar essa técnica é o escopo de variáveis. Consulte o manual do JavaScript sobre escopos de variáveis. </para>
	<para
>Essa técnica é muito utilizada nos plugins de plotagem de distribuição e de distribuição CLT, então talvez você queira procurar exemplos lá. </para>
</sect1>

<sect1 id="include_xml">
<title
>Incluir arquivos <literal role="extension"
>.xml</literal
></title>
	<para
>Basicamente, o mesmo recurso de inclusão de arquivos também está disponível para uso nos arquivos <literal role="extension"
>.xml</literal
>, &pluginmap; e <literal role="extension"
>.rkh</literal
>. Em qualquer lugar nesses arquivos, você pode inserir uma tag <command
>&lt;include&gt;</command
>, como mostrado abaixo. O efeito é que todo o conteúdo desse arquivo &XML; (para ser preciso: tudo dentro da tag <command
>&lt;document&gt;</command
> desse arquivo) é incluído literalmente neste ponto do arquivo. Observe que você só pode incluir outro arquivo &XML;. </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;include file="outro_arquivo_xml.xml"/&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>O atributo <parameter
>file</parameter
> é o nome do arquivo relativo ao diretório em que o arquivo atual está localizado. </para>
</sect1>

<sect1 id="snippets">
<title
>Usar &lt;snippets&gt;</title>
	<para
>Embora a inclusão de arquivos conforme mostrado na <link linkend="include_xml"
>seção anterior</link
> seja bastante poderosa, ela se torna mais útil quando usada em combinação com o comando <command
>&lt;snippets&gt;</command
>. Snippets são, na verdade, seções menores que você pode inserir em outro ponto do arquivo. Um exemplo ilustra isso melhor: </para>
	<programlisting
>&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;frame&gt;
                                &lt;text&gt;
                Isto será inserido em dois lugares na GUI
                                &lt;/text&gt;
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;
        &lt;dialog label="test"&gt;
                &lt;column&gt;
                        &lt;insert snippet="note"/&gt;
                        [...]
                        &lt;insert snippet="note"/&gt;
                &lt;/column&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Portanto, você define o trecho ou snippet em um local no topo do arquivo &XML; e então você o <command
>&lt;insert&gt;</command
> (insere) em qualquer(is) local(is) que desejar. </para>
	<para
>Embora este exemplo não seja muito útil por si só, considere combiná-lo com um arquivo <literal role="extension"
>.xml</literal
> usando <command
>&lt;include&gt;</command
>. Observe que você também pode inserir trechos de código para o arquivo <literal role="extension"
>.rkh</literal
> no mesmo arquivo. Basta adicionar o arquivo lá também usando <command
>&lt;include&gt;</command
> e inserir o trecho de código relevante usando <command
>&lt;insert&gt;</command
>: </para>
	<programlisting
>&lt;!-- Este é o arquivo chamado "common_snippets.xml" --&gt;
&lt;document&gt;
        &lt;snippet id="common_options"&gt;
                &lt;spinbox id="something" [...]/&gt;
                [...]
        &lt;/snippet&gt;
        &lt;snippet id="common_note"&gt;
                &lt;text&gt;Uma observação importante para este tipo de plugin&lt;/text&gt;
        &lt;/snippet&gt;

        &lt;snippet id="common_help"&gt;
                &lt;setting id="something"&gt;Isto faz alguma coisa&lt;/setting&gt;
                [...]
        &lt;/snippet&gt;
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- Este é o arquivo .xml do plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;!-- Importa os snippets comuns--&gt;
                &lt;include file="common_snippets.xml"/&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test2"&gt;
                &lt;insert snippet="common_note"/&gt;
                &lt;spinbox id="something_plugin_specific" [...] /&gt;
                &lt;insert snippet="common_options"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Semelhante à <link linkend="include_js"
>inclusão em JS</link
>, a abordagem inversa costuma ser ainda mais útil: </para>
	<programlisting
>&lt;!-- Este é um arquivo chamado "common_layout.xml" --&gt;
&lt;document&gt;
        &lt;column&gt;
                &lt;insert snippet="note"&gt;
                [...]
                &lt;insert snippet="plugin_parameters"&gt;
        &lt;/column&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- Este é o arquivo .xml do plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;text&gt;A nota usada para este plugin específico&lt;/text&gt;
                &lt;/snippet&gt;

                &lt;snippet id="plugin_parameters"&gt;
                        &lt;frame label="Parâmetros específicos deste plugin"&gt;
                                [...]
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test3"&gt;
                &lt;include file="common_layout.xml"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Finalmente, também é possível <command
>&lt;insert&gt;</command
> (inserir) trechos de código (snippets) em outros trechos, desde que: a) haja apenas um nível de aninhamento, e b) a seção de <command
>&lt;snippets&gt;</command
> esteja localizada no topo do arquivo (antes da inserção de um snippet aninhado); isso ocorre porque as instruções <command
>&lt;insert&gt;</command
> são resolvidas de cima para baixo. </para>
</sect1>

<sect1 id="include_snippets_vs_embedding">
<title
>&lt;include&gt; e &lt;snippets&gt; vs. &lt;embed&gt;</title>
	<para
>À primeira vista, <command
>&lt;include&gt;</command
> e <command
>&lt;snippets&gt;</command
> oferecem funcionalidades bastante semelhantes a <link linkend="embedding"
>embedding</link
>: Permitem reutilizar partes do código entre plugins. Então, qual é a diferença entre essas abordagens e quando usar cada uma? </para>
	<para
>A principal diferença entre esses conceitos é que os plugins incorporáveis ​​são um pacote mais compacto. Eles combinam uma &GUI; completa, código para gerar código &R; a partir dela e uma página de ajuda. Em contraste, os métodos include e insert permitem um controle muito mais preciso, mas com menor modularidade. </para>
	<para
>Ou seja, um plugin que incorpora outro plugin normalmente não precisa saber muito sobre os detalhes internos do plugin incorporado. Um ótimo exemplo é o plugin plot_options. Plugins que desejam incorporá-lo não precisam necessariamente conhecer todas as opções fornecidas, ou como elas são fornecidas. Isso é bom, pois, caso contrário, uma alteração no plugin plot_options poderia tornar necessário ajustar todos os plugins que o incorporam (e muito). Em contraste, os plugins include e insert expõem todos os detalhes internos, e os plugins que os utilizam precisarão -- por exemplo -- saber os IDs exatos e talvez até mesmo o tipo dos elementos usados. </para>
	<para
>Portanto, a regra prática é a seguinte: incluir e inserir são ótimos se as opções relevantes forem necessárias apenas para um grupo claramente limitado de plugins. Plugins incorporados são melhores se o grupo de plugins para os quais eles podem ser úteis não estiver claramente definido e se a funcionalidade puder ser facilmente modularizada. Outra regra prática: se você puder colocar as partes comuns em um único <quote
>bloco</quote
>, faça isso e use a incorporação. Se você precisar de muitos pequenos trechos para definir as partes comuns, use <command
>&lt;snippets&gt;</command
>. Uma última maneira de ver isso: se todos os plugins fornecerem funcionalidades muito semelhantes, incluir e inserir provavelmente é uma boa ideia. Se eles compartilharem apenas um ou dois <quote
>módulos</quote
> em comum, a incorporação provavelmente é melhor. </para>
</sect1>
</chapter>

<chapter id="specialized_plugins">
<title
>Conceitos para uso em plugins especializados</title>
<para
>Este capítulo contém informações sobre alguns tópicos que são úteis apenas para certas classes de plugins. </para>

<sect1 id="specialized_plugins_plots">
	<title
>Plugins que geram um gráfico</title>
	<para
>Criar um gráfico a partir de um plugin é fácil. No entanto, existem algumas armadilhas sutis a evitar, bem como algumas funcionalidades genéricas excelentes que você deve conhecer. Esta seção mostra os conceitos básicos e conclui com um exemplo canônico que você deve seguir sempre que criar plugins de gráficos. </para>
	<sect2 id="rk_graph_on">
		<title
>Desenhar um gráfico na janela de saída</title>
		<para
>Para desenhar um gráfico na janela de saída, use <function
>rk.graph.on()</function
> imediatamente antes de criar o gráfico e <function
>rk.graph.off()</function
> imediatamente depois. Isso é semelhante a, &eg;, chamar <function
>postscript()</function
> e <function
>dev.off()</function
> em uma sessão &R; regular. </para>
		<para
>É importante ressaltar, no entanto, que você deve <emphasis
>sempre </emphasis
> chamar <function
>rk.graph.off()</function
> após chamar <function
>rk.graph.on()</function
>. Caso contrário, o arquivo de saída ficará corrompido. Para garantir que <function
>rk.graph.off()</function
> seja realmente chamado, você deve envolver todos os comandos &R; entre as duas chamadas em uma instrução <function
>try()</function
>. Nunca ouviu falar disso? Não se preocupe, é fácil. Tudo o que você precisa fazer é seguir o padrão mostrado no <link linkend="plot_plugin_example"
>exemplo</link
>, abaixo. </para>
	</sect2>
	<sect2 id="preview_plots">
		<title
>Adicionando funcionalidade de pré-visualização</title>
		<note
><para
>Esta seção discute a adição de funcionalidades de pré-visualização a plugins que produzem gráficos. Existem seções separadas sobre <link linkend="preview_output"
>pré-visualizações de saída (HTML)</link
>, <link linkend="preview_data"
>pré-visualizações de dados (importados)</link
> e <link linkend="preview_custom"
>pré-visualizações personalizadas</link
>. No entanto, recomenda-se que você leia esta seção primeiro, pois a abordagem é semelhante em todos os casos.</para
></note>
		<para
>Um recurso muito útil para todos os plugins que geram um gráfico é fornecer uma pré-visualização com atualização automática. Para isso, você precisará de duas coisas: Adicionar uma caixa de seleção <command
>&lt;preview&gt;</command
> à sua definição <link linkend="mainxml"
>&GUI;</link
> e ajustar o código <link linkend="jstemplate"
>gerado</link
> para a pré-visualização. </para>
		<para
>Adicionar uma caixa de seleção <command
>&lt;preview&gt;</command
> é simples. Basta colocar o seguinte em algum lugar da sua &GUI;. Isso cuidará de toda a mágica nos bastidores da criação de um dispositivo de visualização, atualizando a visualização sempre que as configurações forem alteradas, &etc; Exemplo: </para>
		<note
><para
>A partir da versão 0.6.5 do &rkward;, elementos <command
>&lt;preview&gt;</command
> são tratados de forma especial em diálogos de plugins (não em assistentes): eles serão colocados na coluna de botões, independentemente de onde estejam definidos na interface do usuário. Ainda é uma boa prática defini-los em um local adequado no layout, para garantir a compatibilidade com versões anteriores. </para
></note>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;dialog [...]&gt;
                        [...]
                        &lt;preview id="preview"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>E isso conclui a definição da &GUI;. </para>
		<para
>Ajustar o modelo JS requer apenas um pouco mais de trabalho. Aqui, você precisará garantir que somente o próprio gráfico seja gerado e exibido em um dispositivo na tela, em vez de ser direcionado para a saída. Ou seja, sem impressão de cabeçalhos, <function
>rk.graphics.on()</function
> ou chamadas semelhantes. Para auxiliar você nisso, o &rkward; chamará as funções <function
>preprocess()</function
>, <function
>calculate()</function
> e <function
>printout()</function
> com um parâmetro adicional definido como <parameter
>true</parameter
> ao gerar o código para uma pré-visualização. (O parâmetro é omitido ao gerar o código final. Em JavaScript, isso será avaliado como <parameter
>false</parameter
> quando usado dentro de uma instrução <function
>if</function
>.) Veja o <link linkend="plot_plugin_example"
>exemplo</link
> abaixo para o padrão típico que você usará. </para>
		<para
>Alternativamente, caso precise de mais controle do que isso, você pode adicionar uma nova função chamada <function
>preview()</function
> ao seu modelo JS e gerar o código necessário para uma pré-visualização ali (provavelmente, pelo menos em parte, chamando novamente <function
>calculate()</function
>, etc). </para>
	</sect2>
	<sect2 id="plot_options">
		<title
>Opções genéricas do gráfico</title>
		<para
>Você deve ter notado que a maioria dos plugins de plotagem no &rkward; oferece uma ampla gama de opções genéricas como, &eg;, personalizar títulos de eixos ou margens de figuras. Adicionar essas opções ao seu plugin é fácil. Elas são fornecidas por um plugin <link linkend="embedding"
>incorporável</link
> chamado <command
>rkward::plot_options</command
>. Incorpore-o na interface do seu plugin desta forma: </para>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;logic [...]&gt;
                        &lt;connect client="plotoptions.xvar" governor="x.available"/&gt;
                        &lt;set id="plotoptions.allow_type" to="true"/&gt;
                        &lt;set id="plotoptions.allow_ylim" to="true"/&gt;
                        &lt;set id="plotoptions.allow_xlim" to="false"/&gt;
                        &lt;set id="plotoptions.allow_log" to="false"/&gt;
                        &lt;set id="plotoptions.allow_grid" to="true"/&gt;
                &lt;/logic&gt;
                &lt;dialog [...]&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Plot Options"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>Isso adicionará um botão à sua interface de usuário para abrir uma janela com opções de plotagem. A seção de lógica é apenas um exemplo. Ela permite algum controle sobre o plugin de opções de plotagem. Leia mais na página de ajuda do plugin plot_options (link disponível na página de ajuda de qualquer plugin que forneça as opções genéricas). </para>
		<para
>Em seguida, você precisa garantir que o código correspondente às suas opções de plotagem seja adicionado ao código gerado para o seu gráfico. Para fazer isso, obtenha as propriedades <command
>code.preprocess</command
>, <command
>code.printout</command
> e <command
>code.calculate</command
> do plugin de opções de plotagem incorporado e insira-as em seu código, conforme mostrado no <link linkend="plot_plugin_example"
>exemplo</link
>, abaixo. </para>
	</sect2>
	<sect2 id="plot_plugin_example">
		<title
>Um exemplo canônico</title>
		<para
>Aqui está um exemplo de arquivo .JS que você deve usar como modelo sempre que criar um plugin de plotagem: </para>
		<programlisting
>function preprocess () {
    // o "algumpacote" é necessário para criar o gráfico
    echo ("require (algumpacote)\n");
  }
  
  function printout (is_preview) {
    // Se "is_preview" é definido para false/undefined, ele gera o código completo, incluindo headers.
    // Se "is_preview" é definido para true, somente o essencial será gerado.

    if (!is_preview) {
      echo ('rk.header (' + i18n ("An example plot") + ')\n\n');
      echo ('rk.graph.on ()\n');
    }
    // somente a seção a seguir será gerada para is_preview==true

    // lembre-se: tudo entre between rk.graph.on() e rk.graph.off() deve ser circundado dentro de uma declaração try():
    echo ('try ({\n');
    // insira qualquer código de opção-configuração que deve ser executado antes dos comandos de plotagem.
    // O código em si é fornecido para incorporar o plugin de opções de gráfico. printIndentedUnlessEmpty() takes care of pretty formatting.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.preprocess"), '', '\n');

    // cria de fato o gráfico. plotoptions.code.printout fornece a parte das opções genéricas do gráfico
    // que deve ser adicionado à chamada de plotagem em si.
    echo ('plot (5, 5' + getString ("plotoptions.code.printout") + ')\n');

    // insere qualquer código de configuração-opção que deve ser executado após a plotagem em si.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.calculate"), '\n');
    echo ('})'\n);  // the closure of the try() statement

    if (!is_preview) {
      echo ('rk.graph.off ()\n');
    }
  }
                </programlisting>
	</sect2>
</sect1>
<sect1>
	<title
>Pré-visualizações de dados, resultados e outras informações</title>
	<sect2 id="preview_output">
		<title
>Pré-visualizações de saída (HTML)</title>
		<note
><para
>Esta seção discute a adição de funcionalidade de pré-visualização a plugins que criam impressões de saída/HTML. Recomenda-se que você leia a seção separada sobre <link linkend="preview_plots"
>pré-visualizações de gráficos</link
>, antes desta seção.</para
></note>
		<para
>Criar uma pré-visualização da saída HTML é um procedimento quase idêntico ao de criar uma pré-visualização de um gráfico. Nesse caso, basta garantir que o comando <command
>preview()</command
> gere os comandos relevantes <command
>rk.print()/rk.results()</command
>. No entanto, geralmente é uma boa prática omitir as declarações de cabeçalho na pré-visualização. Aqui está um exemplo simplificado: </para>
		<programlisting
>&lt;!-- In the plugin's XML file --&gt;>
        &lt;dialog label="Importar dados CSV" &gt;
                &lt;browser id="file" type="file" label="Nome do arquivo"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" mode="output"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Observe a especificação de <parameter
>mode="output"</parameter
> no elemento <command
>&lt;preview&gt;</command
>. </para>
		<programlisting
>// No arquivo JS do plugin
        function preview () {
                // gera o código usado para a pré-visualização
                printout (true);
        }

        function printout (is_preview) {
                // somente gera um header se is_preview==false
                if (!is_preview) {
                        new Header ("Esta é uma descrição").print ();
                }
                echo ('rk.print (result)');
        }
                </programlisting>
	</sect2>
	<sect2 id="preview_data">
		<title
>Pré-visualização dos dados (importados)</title>
		<note
><para
>Esta seção discute a adição de funcionalidade de pré-visualização a plugins que criam (ou importam) dados. Recomenda-se que você leia a seção separada sobre <link linkend="preview_plots"
>pré-visualizações de gráficos</link
> antes desta seção.</para
></note>
		<para
>Criar uma pré-visualização de dados importados (qualquer tipo de dado que o comando <command
>rk.edit()</command
> possa manipular) é muito semelhante a criar uma <link linkend="preview_plots"
>pré-visualização de gráfico</link
>. O exemplo simplificado a seguir deve ajudar a ilustrar como criar uma pré-visualização de dados: </para>
		<programlisting
>&lt;!-- No arquivo XML do plugin --&gt;>
        &lt;dialog label="Importar dados CSV" &gt;
                &lt;browser id="file" type="file" label="Nome do arquivo"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" active="true" mode="data"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Observe que o elemento <command
>&lt;preview&gt;</command
> especifica <parameter
>mode="data"</parameter
> desta vez. <parameter
>active="true"</parameter
> simplesmente torna a pré-visualização ativa por padrão. </para>
		<programlisting
>// No arquivo JS do plugin 
        function preview () {
                // gera o código usado para a pré-visualização
                calculate (true);
        }

        function calculate (is_preview) {
                echo ('imported &lt;- read.csv (file="' + getString ("file") /* [+ options] */);
                if (is_preview) {
                        echo ('preview_data &lt;- imported\n');
                } else {
                        echo ('.GlobalEnv$' + getString ("name") + ' &gt;- imported\n');
                }
        }

        function printout () {
                // [...]
        }
                </programlisting>
		<para
>Novamente, a função <command
>preview()</command
> gera quase o mesmo código &R; que a função <command
>calculate()</command
>, então criamos uma função auxiliar <command
>doCalculate()</command
> para isolar as partes comuns. O mais importante a observar é que você precisará atribuir os dados importados a um objeto chamado <parameter
>preview_data</parameter
> (dentro do ambiente local atual). <emphasis
>Todo o resto acontecerá automaticamente</emphasis
> (grosso modo, o &rkward; chamará <command
>rk.edit(preview_data)</command
>, dentro de uma chamada para <command
>.rk.with.window.hints()</command
>). </para>
		<note
><para
>Embora as pré-visualizações sejam um ótimo recurso, elas consomem recursos. No caso de pré-visualizações de dados, pode haver situações em que elas causem problemas de desempenho significativos. Isso pode ocorrer ao importar conjuntos de dados enormes (que são grandes demais para serem abertos para edição na janela do editor do &rkward;), mas também conjuntos de dados "normais" podem ser importados incorretamente, criando um número enorme de linhas ou colunas. <emphasis
>É altamente recomendável limitar o parâmetro <parameter
>preview_data</parameter
></emphasis
> a uma dimensão que forneça uma pré-visualização útil, sem o risco de criar problemas de desempenho perceptíveis (&eg;, 50 linhas por 50 colunas devem ser mais do que suficientes na maioria dos casos). </para
></note>
	</sect2>
	<sect2 id="preview_custom">
		<title
>Pré-visualizações personalizadas</title>
		<para
>O elemento <command
>&lt;preview&gt;</command
> pode ser usado para criar pré-visualizações para qualquer tipo de janela de "documento" que possa ser anexada à área de trabalho do &rkward;. Além de <link linkend="preview_plots"
>plots</link
> e <link linkend="preview_data"
>data windows</link
>, isso inclui arquivos HTML, scripts &R; e janelas de resumo de objetos. Para estes últimos, você precisará usar <command
>&lt;preview mode="custom"&gt; </command
>. </para>
		<para
>Se você leu as seções que descrevem a pré-visualização de gráficos e a pré-visualização de dados, você já deve ter uma ideia geral do procedimento, mas as pré-visualizações "personalizadas" exigem um pouco mais de trabalho manual nos bastidores. A função &R; mais importante a ser analisada é <command
>rk.assign.preview.data()</command
>, neste exemplo. A seguinte listagem resumida mostra como o seu código &R; (pré-visualização) gerado poderia ser para um plugin que cria um arquivo de texto como saída: </para>
		<programlisting
>## A ser gerado na seção de código do preview() de um plugin
        pdata &lt;- rk.get.preview.data("ALGUMAID")
        if (is.null (pdata)) {
                outfile &lt;- rk.get.tempfile.name(prefix="preview", extension=".txt")
                pdata &lt;- list(filename=outfile, on.delete=function (id) {
                        unlink(rk.get.preview.data(id)$filename)
                })
                rk.assign.preview.data("ALGUMAID", pdata)
        }
        try ({
                cat ("Isto é um teste", pdata$filename)
                rk.edit.files(file=pdata$filename)
        })
                </programlisting>
		<para
>Aqui você deve obter o valor <parameter
>ALGUMAID</parameter
> da propriedade <parameter
>id</parameter
> do elemento <command
>&lt;preview&gt;</command
>, ou seja, usando <command
>getString ("preview.id")</command
> no arquivo .js do plugin. </para>
	</sect2>
</sect1>

<sect1 id="contextualized_plugins">
	<title
>Plugins dependentes do contexto</title>
	<para
>Até agora, presumimos que todos os plugins são sempre relevantes e estão localizados no menu principal. No entanto, alguns plugins só fazem sentido (ou adicionalmente) em um determinado contexto. Por exemplo, um plugin para exportar o conteúdo de um dispositivo gráfico X11 é obviamente mais útil quando localizado no menu de um dispositivo X11, e não na barra de menus principal. Além disso, esse plugin deve saber o número do dispositivo em que deve operar, sem precisar perguntar ao usuário sobre isso. </para>
	<para
>Chamamos esses plugins de dependentes de contexto. Consequentemente, no arquivo <link linkend="pluginmap"
>&pluginmap;</link
>, eles não são (ou não apenas) colocados na <command
>&lt;hierarchy&gt;</command
> de comandos principal, mas sim em um elemento <command
>&lt;context&gt;</command
>. Até o momento, apenas dois contextos diferentes são suportados (mais serão adicionados posteriormente): x11 e importação de arquivos. Abordaremos esses contextos em sequência. Mesmo que você esteja interessado apenas no contexto de importação, leia também a seção sobre o contexto x11, pois este é um pouco mais detalhado. </para>

	<sect2 id="context_x11">
		<title
>Contexto do dispositivo X11</title>
		<para
>Para usar um plugin no contexto de um dispositivo x11 - isto é, colocá-lo na barra de menus da janela que aparece quando você chama <function
>x11()</function
> no console, primeiro declare-o como de costume no <link linkend="pluginmap"
>arquivo &pluginmap;</link
>: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="meu_plugin__x11" file="meu_plugin_x11.xml" label="Um plugin de contexto X11"/&gt;
                [...]
        &lt;/components&gt;
                </programlisting>
		<para
>No entanto, você não precisa defini-lo na hierarquia (você pode, se também fizer sentido como um plugin de nível superior): </para>
		<programlisting
>&lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
                </programlisting>
		<para
>Em vez disso, adicione uma definição do contexto "x11" e adicione-a aos menus aqui: </para>
		<programlisting
>&lt;context id="x11"&gt;
                [...]
                &lt;menu id="edit"&gt;
                        [...]
                        &lt;entry id="meu_plugin_X11"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
&lt;/document&gt;
                </programlisting>
		<para
>Na seção <link linkend="logic"
>logic</link
> do XML do plugin, você pode declarar duas propriedades <command
>&lt;external&gt;</command
>: <parameter
>devnum</parameter
> e <parameter
>context</parameter
>. <parameter
>context</parameter
> (se declarado) será definido como <replaceable
>"x11"</replaceable
> quando o plugin for invocado neste contexto. <parameter
>devnum</parameter
> será definido como o número do dispositivo gráfico no qual operar. E isso é tudo. </para>
	</sect2>

	<sect2 id="context_import">
		<title
>Contexto de importação de dados</title>
		<para
>Antes de ler esta seção, certifique-se de ler a seção sobre o <link linkend="context_x11"
>Contexto do dispositivo X11</link
>, pois ela explica os conceitos básicos. </para>
		<para
>O contexto <replaceable
>"import"</replaceable
> é usado para declarar plugins de filtro de importação de arquivos. Você simplesmente os coloca em um contexto com <parameter
>id="</parameter
><replaceable
>"import"</replaceable
> no arquivo &pluginmap;. No entanto, há um detalhe adicional ao declarar esses plugins: para oferecer uma caixa de diálogo de seleção de arquivos unificada para todos os tipos de arquivo suportados, você precisa declarar uma informação adicional em seu componente: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="meu_plugin_importar_xyz" file="meu_plugin_importar_xyz.xml" label="Importar arquivos XYZ"&gt;
                        &lt;attribute id="format" value="*.xyz *.zyx" label="XYZ data files"/&gt;
                &lt;/component&gt;
                [...]
        &lt;/components&gt;
        &lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
        &lt;context id="import"&gt;
                [...]
                &lt;menu id="import"&gt;
                        [...]
                        &lt;entry id="my_xyz_import_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
        [...]
&lt;/document&gt;
                </programlisting>
		<para
>A linha de atributo simplesmente diz que as extensões de nome de arquivo associadas para os arquivos XYZ são <literal role="extension"
>*.xyz</literal
> ou <literal role="extension"
>*.zyx</literal
>, e que o filtro deve ser rotulado como <quote
>Arquivos de dados XYZ</quote
> na caixa de diálogo de seleção de arquivos. </para>
		<para
>Você pode declarar duas propriedades <command
>&lt;external&gt;</command
> em seu plugin. <parameter
>filename</parameter
> será definido com o nome do arquivo selecionado e <parameter
>context</parameter
> será definido com <replaceable
>"import"</replaceable
>. </para>
	</sect2>
</sect1>

<sect1 id="querying_r_for_info">
<title
>Consultando o &R; para obter informações</title>
	<para
>Em alguns casos, você pode querer obter mais informações do &R; para serem apresentadas na interface do usuário do seu plugin. Por exemplo, você pode querer oferecer uma seleção dos níveis de um fator que o usuário selecionou para análise. Desde a versão 0.6.2 do &rkward;, isso é possível. Antes de começarmos, é importante que você esteja ciente de algumas ressalvas:</para>
	<para
>O código R executado dentro da lógica da interface do usuário do plugin é avaliado no loop de eventos do R, o que significa que ele pode ser executado <emphasis
>enquanto</emphasis
> outros cálculos estão em andamento. Isso garante que a interface do usuário do seu plugin seja utilizável, mesmo enquanto o &R; estiver ocupado realizando outras tarefas. No entanto, isso torna muito importante que seu código não tenha efeitos colaterais. Em particular:</para>
	<itemizedlist>
		<listitem
><para
><emphasis
>Não</emphasis
> faça nenhuma atribuição em .GlobalEnv ou qualquer outro ambiente não local.</para
></listitem>
		<listitem
><para
><emphasis
>Não</emphasis
> imprima nada no arquivo de saída.</para
></listitem>
		<listitem
><para
><emphasis
>Não</emphasis
> plote nada na tela.</para
></listitem>
		<listitem
><para
>Em geral, <emphasis
>não</emphasis
> faça nada que tenha efeitos colaterais. Seu código <emphasis
>pode ler informações</emphasis
>, mas não "<emphasis
>fazer</emphasis
>" nada.</para
></listitem>
	</itemizedlist>
	<para
>Com isso em mente, aqui está o padrão geral. Você usará isso dentro de uma seção de lógica de interface do usuário com o script <link linkend="logic_scripted"
>scripted UI logic</link
>:</para>
	<programlisting
>&lt;script&gt;&lt;![CDATA[
                                let update = gui.addChangeCommand ("variable", function () {
                                        gui.setValue ("selector.enabled", 0);
                                        variable = gui.getValue ("variable");
                                        if (variable == "") return;

                                        new RCommand('levels (' + variable + ')', "myid").then(result =
> {
                                                gui.setValue ("selector.enabled", 1);
                                                gui.setListValue ("selector.available", result);
                                        }).catch(msg =
> {
                                                if (msg === "outdated") return;  // comando foi cancelado, pois um novo está prestes a chegar ->benigno
                                                // possivelmente outros erros de tratamento, msg carrega os avisos e mensagens de erro produzidos,
                                                // se o comando falhou porexemplo:
                                                gui.setListValue ("selector.available", Array ("ERROR:", msg));
                                        });
                                });
                ]]&gt;&lt;/script&gt;
        </programlisting>
	<para
>Aqui, <parameter
>variable</parameter
> é uma propriedade que contém o nome de um objeto (&eg;, dentro de um <command
>&lt;varslot&gt;</command
>). Sempre que isso mudar, você precisará atualizar a exibição dos níveis dentro do <command
>&lt;valueselector&gt;</command
>, chamado <parameter
>selector</parameter
>. A função chave aqui é a instrução construtora <command
>new RCommand()</command
>, que recebe como primeiro parâmetro a string de comando a ser executada. Observe que o comando é executado de forma assíncrona, o que torna as coisas um pouco mais complexas. Por um lado, você precisa garantir que seu <command
>&lt;valueselector&gt;</command
> permaneça desabilitado enquanto não contiver informações atualizadas. Em segundo lugar, como o usuário pode fazer alterações rapidamente, mais de um comando pode ter sido gerado antes de recebermos qualquer resultado. Portanto, você precisará garantir que execute apenas o comando mais recente. </para>
	<para
>Para lidar com a assincronia, o que é retornado aqui é um objeto <command
>Promise</command
>. Mais informações sobre esse poderoso recurso do JavaScript podem ser encontradas <ulink url="https://javascript.info/async"
>na internet</ulink
>. O importante a saber aqui é que adicionar uma instrução <command
>.then()</command
> permite especificar o que acontecerá quando o comando for concluído, e uma instrução <command
>.catch()</command
> pode ser usada para lidar com quaisquer erros. Novamente, lembre-se de que o bloco <command
>.then()</command
> não é executado imediatamente. Para entender as implicações disso, pode ser útil, durante o desenvolvimento, inserir um <command
>Sys.sleep(1);</command
> em seu comando R, para ver o que acontece, quando um comando não é concluído imediatamente.</para>
	<para
>Finalmente, para lidar com a geração de múltiplos comandos, você pode especificar um segundo argumento para <command
>new RCommand()</command
>, ("myid", neste exemplo). Quaisquer comandos com o mesmo identificador (escolhido livremente) serão entendidos como pertencentes à mesma fila. O RKWard garantirá então que apenas o comando mais recente acione o bloco <command
>.then()</command
> enquanto quaisquer comandos obsoletos chegarão no bloco <command
>.catch()</command
>. Aqui, os comandos obsoletos podem ser identificados, pois a string "outdated" é passada como seu valor, enquanto para quaisquer outros erros possíveis, os avisos e mensagens de erro são repassados. </para>
	<para
>Note que este exemplo é um tanto simplificado. Na realidade, você deve tomar precauções adicionais, por exemplo, para evitar colocar uma quantidade excessiva de níveis no seletor. A boa notícia é que provavelmente você não precisa fazer tudo isso sozinho. O exemplo acima foi retirado do plugin <command
>rkward::level_select</command
>, por exemplo, que você pode simplesmente <link linkend="embedding"
>incorporar</link
> em seu próprio plugin. Isso permite até mesmo que você especifique uma expressão diferente para executar no lugar de <command
>levels()</command
>.</para>
	<note>
		<para
>Em versões anteriores do RKWard, os comandos R eram executados usando uma função um pouco mais complexa: <command
>doRCommand()</command
>. Você ainda pode encontrar isso em alguns plugins, mas não é recomendável usá-la em novos códigos.</para>
	</note>

</sect1>

<sect1 id="current_object">
<title
>Referenciando o objeto atual ou o arquivo atual</title>
	<para
>Para muitos plugins, é desejável trabalhar com o objeto <quote
>atual</quote
>. Por exemplo, um plugin de <quote
>classificação</quote
> poderia pré-selecionar os dados. O nome do objeto atual está disponível para os plugins como uma propriedade predefinida chamada <parameter
>current_object</parameter
>. Você pode se conectar a essa propriedade da maneira usual. Se nenhum objeto for atual, a propriedade equivale a uma string vazia. Da mesma forma, o &URL; do arquivo de script atual é acessível como uma propriedade predefinida chamada <parameter
>current_filename</parameter
>. Essa propriedade está vazia se nenhum arquivo de script estiver sendo editado ou se o arquivo de script ainda não tiver sido salvo. </para>
	<para
>Atualmente, o parâmetro <parameter
>current_object</parameter
> só pode ser da classe <function
>data.frame</function
>, mas não confie nisso, pois isso será estendido para outros tipos de dados no futuro. Se você estiver interessado apenas em objetos <function
>data.frame</function
>, conecte-se à propriedade <parameter
>current_dataframe</parameter
>. Como alternativa, você pode impor requisitos de tipo usando restrições apropriadas em seus comandos <command
>&lt;varslot&gt;</command
>s, ou usando <link linkend="logic_scripted"
>scripts de lógica &GUI;</link
>. </para>
</sect1>

<sect1 id="optionset">
	<title
>Opções repetidas (um conjunto de)</title>
	<para
>Às vezes, você deseja repetir um conjunto de opções para um número arbitrário de itens. Por exemplo, suponha que você queira implementar um plugin para classificar um data.frame. Você pode querer permitir a classificação por um número arbitrário de colunas (em caso de empate entre as primeiras colunas). Isso pode ser facilmente implementado permitindo que o usuário selecione várias variáveis ​​em um <command
>&lt;varslot&gt;</command
> com <parameter
>multi="true"</parameter
>. Mas se você quiser estender isso, &eg;, permitindo que o usuário especifique para cada variável se ela deve ser convertida para caractere/numérica ou se a classificação deve ser crescente ou decrescente, você precisa de mais flexibilidade. Outros exemplos seriam plotar várias linhas em um único gráfico (permitindo selecionar objeto, estilo de linha, cor da linha &etc; para cada linha) ou especificar um mapeamento para recodificar de um conjunto de valores antigos para novos valores. </para>
	<para
>Digite o <command
>&lt;conjunto de opções&gt;</command
>. Vamos analisar um exemplo simples primeiro: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        &lt;row&gt;
                                &lt;input id="firstname" label="Nome(s) fornecido(s)" size="small"&gt;
                                &lt;input id="lastname" label="Nome de família" size="small"&gt;
                                &lt;radio id="gender" label="Gênero"&gt;
                                        &lt;optioncolumn label="Masculino" value="m"/&gt;
                                        &lt;optioncolumn label="Feminino" value="f"/&gt;
                                &lt;/radio&gt;
                        &lt;/row&gt;
                &lt;/content&gt;

                &lt;optioncolumn id="firstnames" label="Nome(s) fornecido(s)" connect="firstname.text"&gt;
                &lt;optioncolumn id="lastnames" label="Nome de família" connect="lastname.text"&gt;
                &lt;optioncolumn id="gender" connect="gender.string"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Aqui, criamos uma interface de usuário para especificar um número de pessoas (&eg;, autores). A interface requer pelo menos uma entrada (<parameter
>min_rows="1"</parameter
>). Dentro do elemento <command
>&lt;optionset&gt;</command
>, começamos especificando o <command
>&lt;content&gt;</command
>, &ie;, os elementos que pertencem ao conjunto de opções. Você já deve estar familiarizado com a maioria dos elementos dentro do <command
>&lt;content&gt;</command
>. </para
><para
>Em seguida, especificamos as variáveis ​​de interesse que queremos ler do conjunto de opções em nosso arquivo JS. Como lidaremos com um número arbitrário de itens, não podemos simplesmente ler <function
>getString("firstname")</function
> em JS. Em vez disso, para cada valor de interesse, especificamos um <command
>&lt;optioncolumn&gt;</command
>. Para a primeira optioncolumn no exemplo, `<command
>&lt;connect="firstname.text"&gt;</command
> significa que o conteúdo do elemento "firstname" é lido para cada item. Os itens <command
>&lt;optioncolumn&gt;</command
> para os quais um <parameter
>label</parameter
> é fornecido serão exibidos na tela, em uma coluna correspondente a esse rótulo. Em JS, agora podemos buscar os primeiros nomes de todos os autores usando <function
>getList("set.firstname")</function
>, <function
>getList("set.lastnames")</function
> para os sobrenomes e <function
>getList("set.gender")</function
> para um array de strings "m"/"f". </para>
	<para
>Observe que não há restrições quanto ao que você pode colocar dentro de um <command
>&lt;optionset&gt;</command
>. Você pode até usar componentes <link linkend="embedding"
>embedded</link
>. Assim como com qualquer outro elemento, tudo o que você precisa fazer é coletar as variáveis ​​de saída de interesse em uma <command
>&lt;optioncolumn&gt;</command
>-specification. No caso de plugins incorporados, isso geralmente é uma seção da propriedade "code". Por exemplo: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Claro que você também pode usar <link linkend="logic"
>lógica de interface do usuário</link
> dentro de um optionset. Existem duas opções para fazer isso: Você pode fazer isso estabelecendo uma conexão (ou script) na seção principal <command
>&lt;logic&gt;</command
> do seu plugin, como de costume. No entanto, você acessará os elementos da interface do usuário na região de conteúdo como (por exemplo) "set.contents.firstname.XYZ". Observe o prefixo "set" (o <parameter
>id</parameter
> que você atribuiu ao conjunto e "contents"). Alternativamente, você pode adicionar uma seção <command
>&lt;logic&gt;</command
> separada como um elemento filho do seu <command
>&lt;optionset&gt;</command
>. Nesse caso, os <parameter
>id</parameter
>s serão endereçados em relação à região de conteúdo, &eg;, "firstname.XYZ". Somente o elemento <command
>&lt;script&gt;</command
> não é permitido na seção de <command
>&lt;logic&gt;</command
> do plugin.Se você quiser usar scripts, terá que utilizar a seção principal <command
>&lt;logic&gt;</command
> do plugin. </para>
	<note>
		<para
>Ao criar scripts de lógica em um conjunto de opções, tudo o que você pode fazer é acessar a região de conteúdo <emphasis
>atual</emphasis
>. Portanto, normalmente, só faz sentido conectar elementos dentro da região de conteúdo entre si. Conectar uma propriedade fora do <command
>&lt;optionset&gt;</command
> a uma propriedade dentro da região de conteúdo pode ser útil para inicialização. No entanto, modificar a região de conteúdo após a inicialização <emphasis
>não</emphasis
> se aplicará aos itens que o usuário já definiu. Apenas ao item atualmente selecionado no conjunto. </para>
	</note>
	<sect2 id="optionset_driven">
		<title
>"Driven" optionsets</title>
		<para
>Até agora, consideramos um <command
>&lt;optionset&gt;</command
> que fornece botões para adicionar/remover itens. No entanto, em alguns casos, é muito mais natural selecionar itens fora do <command
>&lt;optionset&gt;</command
> e fornecer opções para personalizar alguns aspectos de cada item apenas em um <command
>&lt;optionset&gt;</command
>. Por exemplo, suponha que você queira permitir que o usuário plote vários objetos em um único gráfico. Para cada objeto, o usuário deve poder especificar a cor da linha. Você poderia resolver isso colocando um <command
>&lt;varselector&gt;</command
> e um <command
>&lt;varslot&gt;</command
> dentro da área <command
>&lt;content&gt;</command
>, permitindo que o usuário selecione um item por vez. No entanto, isso significará muito menos cliques para o usuário se você usar um <command
>&lt;varslot multi="true""&gt;</command
> <emphasis
>fora</emphasis
> do <command
>&lt;optionset&gt;</command
>. Em seguida, você conectará essa seleção de objetos a um conjunto de opções chamado "controlado". Veja como: </para>
		<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;connect client="set.vars" governor="vars.available"/&gt;
                &lt;connect client="set.varnames" governor="vars.available.shortname"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;varselector id="varsel"/&gt;
        &lt;varslot id="vars" label="Objects to plot"/&gt;
        &lt;optionset id="set" keycolumn="var"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Line color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="vars" external="true"&gt;
                &lt;optioncolumn id="varnames" external="true" label="Variable"&gt;
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
		<para
>Começaremos analisando o exemplo abaixo. Você notará que duas especificações de <command
>&lt;optioncolumn&gt;</command
> têm <parameter
>external="true"</parameter
>. Isso indica à &rkward; que elas são controladas de fora do <command
>&lt;optionset&gt;</command
>. Aqui, o único propósito da coluna de opções "varnames" é fornecer rótulos de fácil leitura na exibição do conjunto de opções (ela está conectada ao modificador "shortname" da propriedade que contém os objetos selecionados). O propósito da coluna de opções "vars" é servir como a coluna "chave", conforme especificado por <command
>&lt;optionset keycolumn="vars"...&gt;</command
>. Isso significa que para cada entrada nesta lista, o conjunto oferecerá um conjunto de opções, e as opções estão logicamente vinculadas a essas entradas. Esta coluna está conectada à propriedade que contém os objetos selecionados no <command
>&lt;varslot&gt;</command
>. Ou seja, para cada objeto selecionado ali, o <command
>&lt;optionset&gt;</command
> permitirá especificar a cor da linha. </para>
		<note>
			<para
>A coluna externa também pode ser <parameter
>connect</parameter
> (conectada) a propriedades dentro da região <command
>&lt;content&gt;</command
>. No entanto, é importante observar que as colunas de opções declaradas como <parameter
>external="true"</parameter
> nunca devem ser modificadas de dentro do <command
>&lt;optionset&gt;</command
>, e as colunas de opções declaradas como <parameter
>external="false"</parameter
> (o padrão) nunca devem ser modificadas de fora do <command
>&lt;optionset&gt;</command
>. </para>
		</note>
	</sect2>
	<sect2 id="optionset_alternatives">
		<title
>Alternativas: Quando não usar conjuntos de opções</title>
		<para
>Optionsets são uma ferramenta poderosa, mas às vezes podem causar mais danos do que benefícios, pois adicionam uma complexidade considerável, tanto da perspectiva de um desenvolvedor de plugins quanto da perspectiva de um usuário. Portanto, pense duas vezes antes de usá-los. Aqui estão algumas dicas: </para>
		<itemizedlist>
			<listitem
><para
>Para alguns casos simples, o elemento <command
>&lt;matrix&gt;</command
> pode fornecer uma alternativa leve e útil.</para
></listitem>
			<listitem
><para
>Não sobrecarregue seu plugin com muitas funcionalidades. Demos o exemplo de usar um conjunto de opções (optionset) para que um plugin desenhe várias linhas em um único gráfico. Mas, em geral, não é uma boa ideia criar um plugin que gere gráficos individuais para cada item em um conjunto de opções. Em vez disso, faça com que o plugin gere um único gráfico, e o usuário possa chamá-lo várias vezes. </para
></listitem>
			<listitem
><para
>Se você não espera mais do que dois ou três itens em um conjunto, considere repetir as opções manualmente.</para
></listitem>
		</itemizedlist>
	</sect2>
</sect1>

</chapter>

<chapter id="chapter_dependencies">
<title
>Lidar com dependências e problemas de compatibilidade</title>
<sect1 id="sect_dependencies_rkward_version"
><title
>Compatibilidade com a versão do &rkward;</title>
	<para
>Fazemos o possível para garantir que os plugins desenvolvidos para uma versão antiga do &rkward; continuem funcionando em versões posteriores do &rkward;. No entanto, o inverso nem sempre é verdadeiro, pois novos recursos são adicionados. Como nem todos os usuários estão executando a versão mais recente do &rkward;, isso significa que seu plugin pode não funcionar para todos.</para>
	<para
>Quando você estiver ciente de tais problemas de compatibilidade, certifique-se de documentar esse fato em seu arquivo &pluginmap;, usando o elemento <command
>&lt;dependencies&gt;</command
>. O elemento <command
>&lt;dependencies&gt;</command
> pode ser especificado como um filho direto do elemento &lt;document&gt; do &pluginmap;, ou como um elemento filho de definições individuais de <command
>&lt;component&gt;</command
>. No primeiro caso, as dependências se aplicam a <emphasis
>todos</emphasis
> plugins no mapa. No segundo caso, apenas ao(s) <command
>&lt;component&gt;</command
>(s) individual(is). Você também pode misturar dependências "globais" e "específicas". Nesse caso, as dependências "globais" são adicionadas às do componente individual.</para>
	<para
>Vejamos um pequeno exemplo:</para>
	<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c" /&gt;
        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Neste exemplo, sabe-se que todos os plugins requerem pelo menos a versão 0.5.0c do &rkward;. Um plugin, com <replaceable
>id="myplugin"</replaceable
> é fornecido em duas variantes alternativas. A primeira versão, simplificada, será usada para versões do &rkward; anteriores à 0.6.1. A segunda utiliza recursos que são novos no &rkward; 0.6.1, e será usada somente a partir do &rkward; 0.6.1 em diante.</para>
	<para
>Fornecer variantes alternativas como esta é uma maneira muito amigável de usar novos recursos, mantendo o suporte para versões anteriores do &rkward;. As versões alternativas devem compartilhar o mesmo <parameter
>id</parameter
> (caso contrário, serão exibidos avisos) e só podem ser definidas <emphasis
>dentro do mesmo</emphasis
> arquivo &pluginmap;.</para>
	<para
>Plugins que não são compatíveis com a versão em execução do &rkward;, e que não vêm com uma versão alternativa serão ignorados com um aviso.</para>
	<note
><para
>Na verdade, a versão 0.6.1 do &rkward; é a primeira a interpretar dependências e a reportar erros de dependência. Portanto, ao contrário do que o exemplo possa sugerir, especificar versões anteriores nas dependências não terá efeito direto (mas ainda pode ser uma boa ideia para fins de documentação).</para
></note>
	<para
><emphasis
>Às vezes</emphasis
> será possível até mesmo lidar com problemas de incompatibilidade de versão <emphasis
>dentro</emphasis
> de um único arquivo &pluginmap; usando o elemento <command
>&lt;dependency_check&gt;</command
>, descrito na seção seguinte.</para>
</sect1>
<sect1 id="sect_dependencies_r_version"
><title
>Compatibilidade de versão do &R;</title>
	<para
>Semelhante a <parameter
>rkward_min_version</parameter
> e <parameter
>rkward_max_version</parameter
>, o elemento <command
>&lt;dependencies&gt;</command
> permite a especificação dos atributos <parameter
>R_min_version</parameter
> e <parameter
>R_max_version</parameter
>. No entanto, existem as seguintes diferenças:</para>
	<itemizedlist>
		<listitem
><para
>Plugins que não atendem ao requisito de versão &R; não são ignorados atualmente ao ler um arquivo &pluginmap;. O usuário ainda pode chamar o plugin e não verá nenhum aviso imediato (em versões futuras, provavelmente uma mensagem de aviso será exibida).</para
></listitem>
		<listitem
><para
>Consequentemente, também <emphasis
>não</emphasis
> é possível definir versões alternativas de um plugin dependendo da versão em execução do &R;.</para
></listitem>
		<listitem
><para
>No entanto, muitas vezes é fácil obter compatibilidade com versões anteriores, como mostrado abaixo. Se você estiver ciente de problemas de compatibilidade com o &R;, considere usar este método, em vez de definir uma dependência em uma versão específica do &R;.</para
></listitem>
	</itemizedlist>
	<para
>Em muitos casos, é facilmente possível fornecer funcionalidade reduzida, se um determinado recurso não estiver disponível na versão em execução do &R;. Considere o seguinte exemplo curto de um arquivo de plugin <literal role="extension"
>.xml</literal
>:</para>
	<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;dependency_check id="ris210" R_min_version="2.10.0"/&gt;
                &lt;connect client="compression.xz.enabled" governor="ris210"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;radio id="compression" label="Método abrangente"&gt;
                &lt;option label="Nenhum" value=""&gt;
                &lt;option label="gzip" value="gzip"&gt;
                &lt;option id="xz" label="xz" value="xz"&gt;
        &lt;/radio&gt;
        [...]
&lt;/dialog&gt;
        </programlisting>
	<para
>Neste exemplo, a opção de compressão "xz" será simplesmente desativada quando a versão do runtime do &R; for anterior à 2.10.0 (que não suportava compressão xz). O elemento <command
>&lt;dependency_check&gt;</command
> suporta os mesmos atributos que o elemento <command
>&lt;dependencies&gt;</command
> nos arquivos &pluginmap;. Ele cria uma propriedade booleana, que é verdadeira se as dependências especificadas forem atendidas e falsa caso contrário.</para>
</sect1>
<sect1 id="sect_dependencies_r_packages"
><title
>Dependências de pacotes &R;</title>
<para
>É possível definir dependências em pacotes &R; específicos, mas a partir da versão 0.6.1 do &rkward;, essas dependências não são verificadas nem instaladas/carregadas automaticamente. Elas são exibidas nos arquivos de ajuda do plugin. Aqui está um exemplo de definição:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<note
><para
>Certifique-se sempre de adicionar as chamadas apropriadas de <function
>require()</function
>, se o seu plugin precisar que determinados pacotes sejam carregados.</para
></note>
<note
><para
>Se você <link linkend="external_plugins"
>distribuir seu &pluginmap; como um pacote &R;</link
>, e todos os plugins dependerem de um pacote específico, então você deve definir essa dependência no nível do pacote &R;. Definir dependências para pacotes &R; no nível do &pluginmap; do &rkward; é mais útil se apenas alguns de seus plugins precisarem da dependência, a dependência não estiver disponível no CRAN, ou seu &pluginmap; não for distribuído como um pacote &R;.</para
></note>
</sect1>
<sect1 id="sect_dependencies_other_pluginmaps"
><title
>Dependências de outros &pluginmap; do &rkward;</title>
	<para
>Se seus plugins dependem de plugins definidos em outro &pluginmap; (ou seja, <emphasis
>não</emphasis
>faz parte do seu pacote), você pode definir essa dependência assim:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<para
>Atualmente, o plugin não carrega, instala ou sequer avisa sobre a falta de &pluginmap;, mas pelo menos as informações sobre as dependências (e onde obtê-las) serão exibidas na página de ajuda do plugin. Você não precisa (e não deve) declarar dependências de &pluginmap; que são distribuídos com a distribuição oficial do &rkward;, ou de &pluginmap; que estão dentro do seu próprio pacote. Além disso, se um &pluginmap; necessário for <link linkend="external_plugins"
>distribuído como um pacote &R;</link
>, declare uma dependência do pacote (como mostrado na seção anterior), em vez de declarar dependências do plugin.</para>
	<para
>Para garantir que os &pluginmap; necessários sejam realmente carregados, use a tag <command
>&lt;require&gt;</command
> (consulte a <link linkend="pluginmapelements"
>reference</link
> para obter detalhes).</para>
</sect1>
<sect1 id="sect_dependencies_example"
><title
>Um exemplo</title>
	<para
>Para esclarecer como as definições de dependência podem ser misturadas, aqui está um exemplo combinado:</para>
<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c"&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
                &lt;package 
                        name="DreamsOfPi"
                        min_version="0.2"
                /&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;dependencies&gt;

        &lt;require map="heisenberg::heisenberg_plugins"/&gt;

        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
</programlisting>
</sect1>
</chapter>

<chapter id="i18n">
	<title
>Traduções de plugin</title>
	<para
>Até agora, usamos alguns conceitos sobre traduções ou "i18n" (abreviação de "internacionalização", que tem 18 caracteres entre i e n no inglês) de passagem. Neste capítulo, apresentamos uma explicação mais detalhada da funcionalidade de i18n para plugins do &rkward;. Na maioria dos casos, você <emphasis
>não</emphasis
> precisará de tudo isso em seus plugins. No entanto, pode ser uma boa ideia ler este capítulo na íntegra, pois a compreensão desses conceitos deve ajudá-lo a criar plugins totalmente traduzíveis e que permitam traduções de alta qualidade. </para>
	<sect1 id="i18n_general"
><title
>Considerações gerais</title>
		<para
>Um ponto importante a entender sobre traduções de software, em contraste com traduções de outros materiais de texto, é que os tradutores frequentemente terão bastante dificuldade em obter uma visão completa <emphasis
>do que</emphasis
> estão traduzindo. As traduções de software são necessariamente baseadas em fragmentos de texto bastante curtos: cada rótulo que você atribui a uma <command
>&lt;option&gt;</command
> em um <command
>&lt;radio&gt;</command
>, cada string que você marca para tradução em uma chamada de função <command
>i18n()</command
>, formará uma "unidade de tradução" separada. Em essência, cada fragmento será apresentado ao tradutor isoladamente. Bem, não completamente isolado, pois tentamos fornecer ao tradutor o máximo de contexto significativo que puder ser extraído automaticamente. Mas, em alguns momentos, os tradutores precisarão de contexto adicional para entender uma string, especialmente quando as strings são curtas. </para>
	</sect1>
	<sect1 id="i18n_xml"
><title
>i18n em arquivos xml do &rkward;</title>
		<para
>Para arquivos &XML; do &rkward;, a internacionalização (i18n) geralmente funciona sem problemas. Se você estiver escrevendo seu próprio <command
>.pluginmap</command
> (&eg;, para um <link linkend="external_plugins"
>plugin externo</link
>), você precisará especificar um <replaceable
>po_id</replaceable
> ao lado do <replaceable
>id</replaceable
> do pluginmap. Isso define o "catálogo de mensagens" a ser usado. Em geral, isso deve ser definido de forma idêntica ao <replaceable
>id</replaceable
> do seu <command
>.pluginmap</command
>, mas se você fornecer vários <command
>.pluginmap</command
>s relacionados em um único pacote, provavelmente desejará especificar um <replaceable
>po_id</replaceable
> comum em seus mapas. O <replaceable
>po_id</replaceable
> de um arquivo <command
>.pluginmap</command
> é herdado por todos os plugins declarados nele, a menos que declare um <replaceable
>po_id</replaceable
> diferente. </para>
		<para
>Para plugins e páginas de ajuda, você não precisa especificar para o &rkward; quais strings devem ser traduzidas, pois isso geralmente fica evidente pelo seu uso. No entanto, como explicado acima, você deve ficar atento a strings que podem ser ambíguas ou que precisam de alguma explicação para serem traduzidas corretamente. Para strings que podem ter significados diferentes, forneça um <replaceable
>i18n_context</replaceable
> como este: </para>
		<programlisting
>&lt;checkbox id="scale" label="Escala" i18n_context="Mostra a escala"/&gt;
&lt;checkbox id="scale" label="Escala" i18n_context="Escala o gráfico"/&gt;
                </programlisting>
		<para
>Fornecer <replaceable
>i18n_context</replaceable
> fará com que as duas strings sejam traduzidas separadamente. Caso contrário, elas compartilhariam uma única tradução. Além disso, o contexto é mostrado ao tradutor. O atributo <replaceable
>i18n_context</replaceable
> é compatível com todos os elementos que podem ter strings traduzíveis, em algum lugar, incluindo elementos que contêm texto dentro deles (por exemplo, elementos <command
>&eg;text&gt;</command
>). </para>
		<para
>Em outros casos, a sequência a ser traduzida tem um único significado não ambíguo, mas ainda pode precisar de alguma explicação. Nesse caso, você pode adicionar um comentário que será mostrado aos tradutores. Exemplos podem incluir: </para>
		<programlisting
>&lt;!-- i18n: Não, isto não é um erro de digitação para screen plot! --&gt;
&lt;component id="scree_plot" label="Scree plot"/&gt;

&lt;!-- i18n: Se possível, por favor, faça com que esta string seja curta. Ter mais de cerca de 15 caracteres
fica muito feio neste ponto, e o significado deve ser bastante auto-evidente para o
usuário (seleção de uma lista de valores exibida ao lado deste elemento) --&gt;
&lt;valueslot id="selected" label="Pegue um"/&gt;
                </programlisting>
		<para
>Observe que tais comentários devem preceder o elemento ao qual se aplicam e devem começar com "i18n:" ou "TRANSLATORS:". </para>
		<para
>Finalmente, em casos raros, você pode querer excluir certas strings da tradução. Isso pode fazer sentido, por exemplo, se você oferecer uma escolha entre vários nomes de função &R; em um controle <command
>&lt;radio&gt;</command
>. Nesse caso, você não quer que esses nomes sejam traduzidos (mas, dependendo do contexto, você deve considerar fornecer um rótulo descritivo). </para>
		<programlisting
>&lt;radio id="transformation" label="Função R a aplicar"&gt;
  &lt;option id="as.list" noi18n_label="as.list()"/&gt;
  &lt;option id="as.vector" noi18n_label="as.vector()"/&gt;
  [...]
&lt;/radio&gt;
                </programlisting>
		<para
>Observe que você omitirá o atributo <replaceable
>label</replaceable
>, e especificará <replaceable
>noi18n_label</replaceable
> em vez disso. Além disso, observe que, ao contrário de <replaceable
>i18n_context</replaceable
> e comentários, o uso de <replaceable
>noi18n_label</replaceable
> tornará seu plugin incompatível com versões do &rkward; anteriores à 0.6.3. </para>
	</sect1>
	<sect1 id="i18n_js"
><title
>i18n nos arquivos e seções js do &rkward;</title>
		<para
>Em contraste com os arquivos <literal role="extension"
>.xml</literal
>, tornar os arquivos <literal role="extension"
>.js</literal
> de um plugin traduzíveis requer mais trabalho personalizado. A principal diferença aqui é que não há uma maneira automática adequada de determinar se uma string deve ser exibida como uma string legível por humanos ou como um trecho de código. Portanto, você precisa marcá-la você mesmo. Já mostramos exemplos disso ao longo do texto. Aqui está uma descrição mais completa das funções de internacionalização (i18n) disponíveis no código JavaScript e algumas dicas para casos mais complexos: </para>
<variablelist>
<varlistentry>
	<term
><command
>i18n (msgid, [...])</command
></term>
	<listitem
><para
>A função mais importante. Marca a string para tradução. A string (traduzida ou não) é retornada entre aspas duplas (''). Um número arbitrário de marcadores de posição pode ser usado na string, como mostrado abaixo. Usar esses marcadores de posição em vez de concatenar pequenas substrings é muito mais fácil para os tradutores:</para>
		<programlisting
>i18n ("Comparar objetos %1 e %2", getString ('x'), getString ('y'));
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18nc (msgctxt, msgid, [...])</command
></term>
	<listitem
><para
>O mesmo que <command
>i18n()</command
>, mas fornecendo adicionalmente uma mensagem de contexto:</para>
		<programlisting
>i18nc ("nome próprio, não estado de espírito", "Teste de humor");
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18np (msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
>Semelhante a <command
>i18n()</command
>, mas para mensagens que podem ser diferentes no singular ou plural (e algumas linguagens diferenciam ainda mais formas numéricas). Observe que, assim como com <command
>i18n()</command
>, você pode usar um número arbitrário de substituições, mas a primeira ('%1') é obrigatória e deve ser um número inteiro.</para>
		<programlisting
>i18np ("Comparando um único par", "Comparando %1 pares distintos", n_pairs);
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18ncp (msgctxt, msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
><command
>i18np()</command
> com mensagem de contexto adicionada.</para
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>comment (comentário, [endentação])</command
></term>
	<listitem
><para
>Exibe um comentário de código, marcado para tradução. Ao contrário das outras funções i18n(), esta não é colocada entre aspas, mas um '#' é adicionado a cada linha do comentário.</para>
		<programlisting
>comment ("Transpor a matriz");
                        echo ('x &lt;- t (x)\n');
                </programlisting
></listitem>
</varlistentry>
</variablelist>
	<para
>Para adicionar comentários aos tradutores (consulte <link linkend="i18n_xml"
>acima</link
> para uma discussão sobre as diferenças entre comentário e contexto), adicione um comentário começando com "i18n:" ou "translators:" diretamente acima da chamada de comentário <command
>i18n()</command
>. Exemplo: </para>
	<programlisting
>// i18n: A grafia está correta: Scree plot.
                echo ('rk.header (' + i18n ("Scree plot") + ')\n');
        </programlisting>

		<sect2 id="i18n_js_quoting"
><title
>i18n e aspas</title>
			<para
>Na maioria dos casos, você não precisará se preocupar com o comportamento do i18n() em relação às aspas. Como, normalmente, as strings traduzíveis são literais de string, colocá-las entre aspas é a coisa certa a fazer e economiza digitação. Além disso, em funções como <command
>makeHeaderCode()/Header()</command
> que geralmente colocam seus argumentos entre aspas, as strings i18n() são protegidas contra aspas duplicadas. Essencialmente, isso funciona enviando a string traduzida primeiro por meio de <command
>quote()</command
> (para colocá-la entre aspas) e, em seguida, por meio de <command
>noquote()</command
> (para protegê-la de aspas adicionais). Caso você precise de uma string traduzível que não esteja entre aspas, use <command
>i18n(noquote ("Minha mensagem"))</command
>. Caso você precise que uma string traduzível seja citada uma segunda vez, envie-a através de: <command
>quote()</command
>, <emphasis
>duas vezes</emphasis
>. </para>
			<para
>Dito isso, geralmente não é uma boa ideia tornar partes como nomes de funções ou nomes de variáveis ​​traduzíveis. Para começar, o &R;, a linguagem de programação, é inerentemente em inglês e não há internacionalização da linguagem em si. Comentários de código são um caso à parte, mas você deve usar a função <command
>comment()</command
> para eles. Em segundo lugar, tornar partes sintaticamente relevantes do código gerado traduzíveis significa que as traduções podem, na verdade, quebrar seu plugin. Por exemplo, se um tradutor desavisado traduzir uma string destinada a ser um nome de variável em duas palavras distintas com um espaço entre elas. </para>
		</sect2>
	</sect1>
	<sect1 id="i18n_workflow"
><title
>Manutenção da tradução</title>
		<para
>Agora que você tornou seu plugin traduzível, como você realmente o traduz? Em geral, você só precisa se preocupar com isso ao desenvolver um <link linkend="external_plugins"
>plugin externo</link
>. Para plugins no repositório principal do &rkward;, toda a mágica já foi feita para você. Aqui está o fluxo de trabalho básico para plugins externos. Observe que você precisa ter as ferramentas "gettext" instaladas: </para>
		<itemizedlist>
			<listitem
><para
>Marque todas as strings, fornecendo contexto e comentários conforme necessário</para
></listitem>
			<listitem
><para
>Execute <command
>python3 scripts/update_plugin_messages.py --extract-only /caminho/para/meu.pluginmap</command
>. O script scripts/update_plugin_messages.py não faz parte das versões de código-fonte, mas pode ser encontrado em um repositório de código-fonte.</para
></listitem>
			<listitem
><para
>Distribua o arquivo <command
>rkward__<replaceable
>POID</replaceable
>.pot</command
> resultante aos seus tradutores. Para plugins externos, é recomendado colocá-lo em uma subpasta "po" em inst/rkward.</para
></listitem>
			<listitem
><para
>O tradutor abre o arquivo em uma ferramenta de tradução como o <command
>lokalize</command
>. Na verdade, mesmo que você não vá preparar nenhuma tradução, você mesmo deveria experimentar este passo. Examine as strings extraídas em busca de problemas/ambiguidades.</para
></listitem>
			<listitem
><para
>O tradutor salva a tradução como <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> (onde <replaceable
>xx</replaceable
> é o código do idioma) e a envia de volta para você.</para
></listitem>
			<listitem
><para
>Copie <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> para suas fontes, ao lado de <command
>rkward__<replaceable
>POID</replaceable
>.pot</command
>. Execute <command
>python3 scripts/update_plugin_messages.py /path/to/my.pluginmap</command
> (Observação: sem <replaceable
>--extract-only</replaceable
>, desta vez). Isso irá mesclar a tradução com quaisquer alterações de string intermediárias, compilar a tradução e instalá-la em <command
><replaceable
>DIRETÓRIO_DO_MAPA_DE_PLUGIN</replaceable
>/po/<replaceable
>xx</replaceable
>/LC_MESSAGES/rkward__<replaceable
>POID</replaceable
>.mo</command
> (onde <replaceable
>xx</replaceable
> é o código do idioma, novamente).</para
></listitem>
			<listitem
><para
>Você também deve incluir a tradução não compilada (ou seja, <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
>) em sua distribuição, no subdiretório "po".</para
></listitem>
			<listitem
><para
>Para qualquer atualização do seu plugin, execute <command
>python3 scripts/update_plugin_messages.py /caminho/para/meu.pluginmap</command
> para atualizar o arquivo .pot mas também os arquivos .po existentes e os catálogos de mensagens compilados.</para
></listitem>
		</itemizedlist>
	</sect1>
	<sect1 id="i18n_translators"
><title
>Escrevendo traduções para plugin</title>
		<para
>Presumimos que você conheça sua profissão de tradutor ou esteja disposto a se aprofundar nela em outro lugar. Algumas palavras específicas sobre traduções de plugins: </para>
		<itemizedlist>
			<listitem
><para
>Os plugins do &rkward; não eram traduzíveis até a versão 0.6.3 e, em sua maioria, não foram escritos com a internacionalização (i18n) em mente antes disso. Portanto, você encontrará strings ambíguas e outros problemas de i18n com mais frequência do que em outros projetos mais maduros. Por favor, não ignore esses problemas, mas nos informe (ou aos mantenedores dos plugins) para que possamos corrigi-los.</para
></listitem>
			<listitem
><para
>Muitos plugins &rkward; se referem a termos altamente especializados, desde manipulação de dados e estatística, mas também de outras áreas da ciência. Em muitos casos, uma boa tradução exigirá pelo menos conhecimento básico dessas áreas. Em alguns casos, não há uma boa tradução para um termo técnico, e a melhor opção pode ser deixar o termo sem tradução ou incluir o termo em inglês entre parênteses. Não se concentre muito na marca de 100% de traduções, concentre-se em fornecer uma boa tradução, mesmo que isso signifique pular algumas strings (ou até mesmo pular alguns catálogos de mensagens por inteiro). Outros usuários podem preencher quaisquer lacunas em termos técnicos.</para
></listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="chapter_about_information">
<title
>Informações de autor, licença e versão</title>
<para
>Você criou um conjunto de plugins e está se preparando para <link linkend="external_plugins"
>compartilhar seu trabalho</link
>. Para garantir que os usuários saibam do que se trata o seu trabalho, sob quais termos eles podem usá-lo e distribuí-lo, e com quem devem entrar em contato para problemas ou ideias, você deve adicionar algumas informações <emphasis
>sobre</emphasis
> seus plugins. Isso pode ser feito usando o elemento <command
>&lt;about&gt;</command
>. Ele pode ser usado tanto no &pluginmap; quanto em arquivos <literal role="extension"
>.xml</literal
> de plugins individuais (em ambos os casos, como um filho direto da tag document). Quando especificado no &pluginmap;, ele se aplicará a todos os plugins. Se <command
>&lt;about&gt;</command
> for especificado em ambos os locais, as informações de <command
>&lt;about&gt;</command
> no arquivo <literal role="extension"
>.xml</literal
> do plugin substituirão as do arquivo do &pluginmap;. Você também pode adicionar um elemento <command
>&lt;about&gt;</command
> às páginas .rkh que não estão conectadas a um plugin, se necessário.</para>
<para
>Aqui está um exemplo de arquivo &pluginmap; com apenas algumas explicações. Em caso de dúvida, mais informações podem ser encontradas na documentação.</para>
<programlisting
>&lt;document 
        namespace="rkward"
        id="SquaretheCircle_rkward"
&gt;
        &lt;about 
                name="Quadrado para Círculo"
                shortinfo="Quadrado para círculo usando a compensação de Heisenberg."
                version="0.1-3"
                releasedate="2011-09-19"
                url="http://eternalwondermaths.example.org/23/stc.html"
                license="GPL"
                category="Geometry"
        &gt;
                &lt;author 
                        given="E.A."
                        family="Dölle"
                        email="doelle@eternalwondermaths.example.org"
                        role="aut"
                 /&gt;
                &lt;author 
                        given="A."
                        family="Assistant"
                        email="alterego@eternalwondermaths.example.org"
                        role="cre, ctb"
                 /&gt;
        &lt;/about&gt;
        &lt;dependencies&gt;
                ...
        &lt;/dependencies&gt;
        &lt;components&gt;
                ...
        &lt;/components&gt;
        &lt;hierarchy&gt;
                ...
        &lt;/hierarchy&gt;
&lt;/document&gt;
</programlisting>
<para
>A maior parte disso deve se explicar por si só, então não vamos discutir cada elemento de tag individualmente. Mas vamos analisar alguns detalhes que provavelmente precisam de comentários para facilitar a compreensão. </para>
<para
>O elemento <parameter
>category</parameter
> em <command
>&lt;about&gt;</command
> pode ser definido de forma bastante livre, mas deve ser significativo, pois ele é usado para organizar plugins em grupos. Todos os outros atributos nesta tag de abertura são obrigatórios e devem ser preenchidos com conteúdo relevante. </para>
<para
>Pelo menos um <command
>&lt;author&gt;</command
> com um endereço de e-mail válido e a função <quote
>aut</quote
> (<quote
>author</quote
>) também devem ser fornecidos. Caso seu plugin cause problemas ou alguém queira expressar sua gratidão, você poderá entrar em contato com alguém envolvido. Para mais informações sobre outras funções válidas, como <quote
>ctb</quote
> para contribuidores de código ou <quote
>cre</quote
> para manutenção de pacotes, consulte a <ulink url="http://stat.ethz.ch/R-manual/R-patched/library/utils/html/person.html"
>documentação do R sobre <function
>person()</function
></ulink
>. </para>
<note
><para
>Lembre-se de que você pode usar <command
>&lt;include&gt;</command
> e/ou <command
>&lt;insert&gt;</command
> para repetir informações em vários arquivos <literal role="extension"
>.xml</literal
> (por exemplo, informações sobre um autor que esteve envolvido com vários plugins). <link linkend="sect_similar_plugins"
>Mais informações</link
>.</para
></note>
<tip
><para
>Você não precisa escrever este código &XML; manualmente. Se você usar a função <function
>rk.plugin.skeleton()</function
> do <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
> e fornecer todas as informações necessárias através da opção <parameter
>about</parameter
>, ela criará automaticamente um arquivo &pluginmap; com uma seção &lt;about&gt; funcional para você.</para
></tip>
</chapter>

<chapter id="external_plugins">
<title
>Compartilhar seu trabalho com outras pessoas</title>
<sect1 id="sect_external_plugins"
><title
>Plugins externos</title>
	<para
>A partir da versão 0.5.5, o &rkward; oferece uma maneira prática de instalar plugins adicionais de terceiros que não pertencem ao pacote principal em si. Chamamos esses plugins de <quote
>plugins externos</quote
>. Eles vêm na forma de um pacote &R; e podem ser gerenciados diretamente por meio dos recursos usuais de gerenciamento de pacotes do &R; e/ou do &rkward;. </para>
	<para
>Esta seção da documentação descreve como os plugins externos devem ser empacotados, para que o &rkward; possa usá-los. A criação do plugin em si é, obviamente, idêntica às seções anteriores. Ou seja, você provavelmente deve primeiro escrever um plugin funcional e, em seguida, voltar aqui para aprender como distribuí-lo. </para>
	<para
>Como os plugins externos são um recurso relativamente novo, os detalhes sobre isso provavelmente mudarão em versões futuras. Você pode contribuir com suas ideias para melhorar o processo. </para>
	<tip>
		<para
>Esta documentação explica os detalhes dos plugins externos para que você possa aprender como eles funcionam. Além disso, dê uma olhada também no <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
>, que foi projetado para automatizar grande parte do processo de escrita. </para>
	</tip>
</sect1>
<sect1 id="why_external_plugins">
<title
>Por que usar plugins externos?</title>
	<para
>O número de pacotes para estender a funcionalidade do &R; é imenso e continua crescendo. Por um lado, queremos incentivar você a escrever plugins até mesmo para as tarefas mais especializadas que você precisa resolver. Por outro lado, o usuário médio não deve se perder em enormes árvores de menus cheias de termos estatísticos desconhecidos. Portanto, pareceu razoável manter o gerenciamento de plugins no &rkward; bastante modular também. A equipe do &rkward; mantém seu próprio repositório público de pacotes em <ulink url="https://files.kde.org/rkward/R/"
>https://files.kde.org/rkward/R/</ulink
>, destinado a hospedar seus plugins externos. </para>
	<para
>Como regra geral, plugins que parecem servir a um propósito amplamente utilizado (por exemplo, testes t) devem se tornar parte do pacote principal, enquanto aqueles que atendem a um grupo bastante limitado de pessoas com interesses específicos devem ser fornecidos como um pacote opcional. Para você, como autor de plugin, a melhor prática é simplesmente começar com um plugin externo. </para>
</sect1>
  
<sect1 id="structure_of_a_plugin_package">
<title
>Estrutura de um pacote de plugins</title>
	<para
>Para que os plugins externos sejam instalados e funcionem corretamente, eles devem seguir algumas diretrizes estruturais em relação à sua hierarquia de arquivos. </para>
    
	<sect2 id="file_hierarchy"
><title
>Hierarquia de arquivos</title>
		<para
>Vamos dar uma olhada na hierarquia de arquivos prototípica de um plugin elaborado. Você não precisa incluir todos esses diretórios e/ou arquivos para que um plugin funcione (continue lendo para saber o que é absolutamente necessário), considere isso um exemplo de <quote
>boa prática</quote
>: </para>
		<programlisting
>plugin_name/
                inst/
                        rkward/
                                plugins/
                                        plugin_name.xml
                                        plugin_name.js
                                        plugin_name.rkh
                                        ...
                                po/
                                        ll/
                                                LC_MESSAGES/
                                                        rkward__plugin_name_rkward.mo
                                        rkward__plugin_name_rkward.ll.po
                                        rkward__plugin_name_rkward.pot
                                tests/
                                        testsuite_name/
                                                RKTestStandards.sometest_name.rkcommands.R
                                                RKTestStandards.sometest_name.rkout
                                                ...
                                        testsuite.R
                                plugin_name.pluginmap
                                ...
        ChangeLog
        README
        AUTHORS
        LICENSE
        DESCRIPTION
                </programlisting>
		<note>
			<para
>Neste exemplo, todas as ocorrências de <token
>plugin_name</token
>, <token
>testsuite_name</token
> e <token
>sometest_name</token
> devem ser substituídas por seus nomes corretos, respectivamente. Além disso, <token
>ll</token
> é um marcador para uma abreviação de idioma (por exemplo, <quote
>de</quote
>, <quote
>en</quote
> ou <quote
>es</quote
>). </para>
		</note>
		<tip>
			<para
>Você não precisa criar essa hierarquia de arquivos manualmente. Se você usar a função <function
>rk.plugin.skeleton()</function
> do <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
>, ela criará automaticamente todos os arquivos e diretórios necessários para você, exceto o diretório <filename
>po</filename
>, que é criado e gerenciado pelo <link linkend="i18n_workflow"
>script de tradução</link
>. </para>
		</tip>
		<sect3 id="basic_plugin_components">
		<title
>Componentes de um plugin básico</title>
			<para
>É obrigatório incluir pelo menos três arquivos: um <link linkend="pluginmap"
>&pluginmap;</link
>, um arquivo <link linkend="mainxml"
>.xml</link
> com a descrição do plugin e um arquivo <link linkend="jstemplate"
>.js</link
> com a descrição do plugin. Ou seja, até mesmo o diretório "plugins" é opcional. Ele pode ajudar a organizar seus arquivos, principalmente se você incluir mais de um plugin/diálogo no arquivo, o que não é problema algum. Você pode ter quantos diretórios achar necessários para os arquivos de plugin, contanto que eles tenham nomes semelhantes aos do <link linkend="pluginmap"
>&pluginmap;</link
>, respectivamente. Também é possível incluir vários arquivos &pluginmap;, se isso atender às suas necessidades, mas você deve incluí-los todos em <quote
>plugin_name.pluginmap</quote
>. </para>
			<para
>Cada pacote &R; deve ter um arquivo <filename
>DESCRIPTION</filename
> válido, que também é crucial para o &rkward; o reconhecer como um provedor de plugin. A maior parte das informações que ele contém também é necessária nas <link linkend="chapter_about_information"
>Meta-informações</link
> do plugin e possivelmente nas <link linkend="chapter_dependencies"
>dependências</link
>, mas em um formato diferente (a documentação do &R; explica o <ulink url="http://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file"
>arquivo <filename
>DESCRIPTION</filename
> em detalhes</ulink
>). </para>
			<para
>Além do conteúdo geral de um arquivo <filename
>DESCRIPTION</filename
>, certifique-se de incluir também a linha <quote
>Aprimora: rkward</quote
>. Isso fará com que o &rkward; verifique automaticamente o pacote em busca de plugins, caso ele esteja instalado. Um exemplo de arquivo <filename
>DESCRIPTION</filename
> se parece com isto: </para>
			<programlisting
>Package: SquaretheCircle
        Type: Package
        Title: Square the circle
        Version: 0.1-3
        Date: 2011-09-19
        Author: E.A. Dölle &lt;doelle@eternalwondermaths.example.org&gt;
        Maintainer: A. Assistant &lt;alterego@eternalwondermaths.example.org&gt;
        Enhances: rkward
        Description: Squares the circle using Heisenberg compensation.
        License: GPL
        LazyLoad: yes
        URL: http://eternalwondermaths.example.org/23/stc.html
        Authors@R: c(person(given="E.A.", family="Dölle", role="aut",
                        email="doelle@eternalwondermaths.example.org"),
                        person(given="A.", family="Assistant", role=c("cre",
                        "ctb"), email="alterego@eternalwondermaths.example.org"))
                        </programlisting>
			<tip>
				<para
>Você não precisa escrever este arquivo manualmente. Se você usar a função <function
>rk.plugin.skeleton()</function
> do <link linkend="rkwarddev"
>pacote <application
>rkwarddev</application
></link
> e fornecer todas as informações necessárias através da opção <quote
>about</quote
>, ela criará automaticamente um arquivo <filename
>DESCRIPTION</filename
> funcional para você. </para>
			</tip>
		</sect3>
		<sect3 id="additional_information">
		<title
>Informações adicionais (opcional)</title>
			<para
><filename
>ChangeLog</filename
>, <filename
>README</filename
>, <filename
>AUTHORS</filename
>, <filename
>LICENSE</filename
> devem ser autoexplicativos e são totalmente opcionais. Na verdade, eles não serão interpretados pelo &rkward;, portanto, servem para conter informações adicionais que podem ser relevantes, por exemplo, para distribuidores. A maior parte do conteúdo relevante (créditos do autor, termos da licença &eg;) já estará incluída nos arquivos do plugin (consulte a seção <link linkend="chapter_about_information"
>sobre meta-informações</link
>). Observe que todos esses arquivos também podem ser colocados em algum lugar no diretório "inst", se você quiser que eles estejam presentes não apenas no arquivo de origem, mas também no pacote instalado. </para>
		</sect3>
		<sect3 id="automated_plugin_testing">
		<title
>Teste automatizado de plugins (opcional)</title>
			<para
>Outro diretório opcional é "tests", que se destina a fornecer arquivos necessários para <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>testes automatizados de plugins</ulink
>. Esses testes são úteis para verificar rapidamente se seus plugins ainda funcionam com novas versões do &R; ou do &rkward;. Se você quiser incluir testes, é altamente recomendável restringir-se ao esquema de nomenclatura e hierarquia mostrados aqui. Ou seja, os testes devem residir em um diretório chamado <filename
>tests</filename
>, que inclui um arquivo <filename
>testsuite.R</filename
> e uma pasta com padrões de teste nomeados de acordo com o conjunto de testes apropriado. Você pode, no entanto, fornecer mais de um conjunto de testes; nesse caso, se não quiser anexá-los todos em um único arquivo <filename
>testsuite.R</filename
>, você pode dividi-los em, por exemplo; um arquivo para cada conjunto de testes e criar um arquivo <filename
>testsuite.R</filename
> com chamadas <function
>source()</function
> para cada arquivo de conjunto de testes. Em ambos os casos, crie subdiretórios separados com padrões de teste para cada conjunto de testes definido. </para>
			<para
>A vantagem de manter essa estrutura é que os testes de plugins podem ser executados simplesmente chamando <function
>rktests.makplugintests()</function
> do pacote <ulink url="rkward://rhelp/rkwardtests"
>rkwardtests</ulink
> sem argumentos adicionais. Consulte a documentação online em <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>Testes Automatizados de Plugins</ulink
> para obter mais detalhes. </para>
		</sect3>
	</sect2>
</sect1>
  
	<sect1 id="building_the_plugin_package">
		<title
>Construindo o pacote do plugin</title>
		<para
>Como explicado anteriormente, os plugins do &rkward; externos são, na verdade, pacotes &R;, e, portanto, o processo de empacotamento é idêntico. Ao contrário dos pacotes &R; "reais", um pacote de plugin puro não carrega nenhum código &R; adicional (embora você possa, é claro, adicionar plugins &rkward; a pacotes &R; usuais também, usando os mesmos métodos explicados aqui). Isso deve tornar ainda mais fácil a criação de um pacote funcional, desde que você tenha um arquivo <filename
>DESCRIPTION</filename
> válido e siga a hierarquia de arquivos explicada nas <link linkend="structure_of_a_plugin_package"
>seções anteriores</link
>.</para>
		<para
>A maneira mais fácil de realmente construir e testar seu plugin é usar o comando <application
>R</application
> na linha de comando, por exemplo:</para>
		<para
><userinput
><command
>R</command
> <option
>CMD build</option
> <parameter
><filename
>SquaretheCircle</filename
></parameter
> </userinput
></para>
		<para
><userinput
><command
>R</command
> <option
>CMD INSTALL</option
> <parameter
><filename
>SquaretheCircle_0.1-3.tar.gz</filename
></parameter
> </userinput
></para>
		<tip
><para
>Você não precisa compilar o pacote dessa forma na linha de comando. Se você usar a função <function
>rk.build.package()</function
> do pacote <link linkend="rkwarddev"
><application
>rkwarddev</application
></link
>, ela compilará e/ou verificará o pacote do seu plugin para você.</para
></tip>
	</sect1>
</chapter>

<chapter id="rkwarddev">
	<title
>Desenvolvimento de plugins com o pacote <application
>rkwarddev</application
></title>
	<sect1 id="rkdev_overview"
><title
>Visão geral</title>
		<para
>A criação de plugins externos envolve a escrita de arquivos em três linguagens (&XML;, &javascript; e R) e a criação de uma hierarquia padronizada de diretórios. Para facilitar bastante o trabalho dos desenvolvedores de plugins, estamos fornecendo o pacote <application
>rkwarddev</application
>. Ele oferece diversas funções simples em &R; para criar o código &XML; para todos os elementos de diálogo, como abas, caixas de seleção, listas suspensas ou navegadores de arquivos, além de funções para criar código &javascript; e arquivos de ajuda do &rkward; para começar. A função <function
>rk.plugin.skeleton()</function
> cria a árvore de diretórios esperada e todos os arquivos necessários em seus respectivos locais.</para>
		<para
>Este pacote não é instalado por padrão, mas precisa ser instalado manualmente a partir do <ulink url="https://files.kde.org/rkward/R/"
>repositório próprio do &rkward;</ulink
>. Você pode fazer isso usando a &GUI; (<menuchoice
><guimenu
>Configurações</guimenu
><guimenuitem
>Configurar pacotes</guimenuitem
></menuchoice
>), ou a partir de qualquer sessão do &R; em execução:</para>
		<programlisting
>install.packages("rkwarddev", repos="https://files.kde.org/rkward/R")
                library(rkwarddev)
                </programlisting>
		<para
>O <application
>rkwarddev</application
> depende de outro pequeno pacote chamado <quote
>XiMpLe</quote
>, que é um analisador e gerador &XML; muito simples e também presente no mesmo repositório.</para>
		<para
>A <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev.pdf"
>documentação completa em formato PDF</ulink
> também pode ser encontrada lá. Uma introdução mais detalhada ao trabalho com o pacote pode ser encontrada na<ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev_vignette.pdf"
>vinheta do rkwarddev</ulink
>.</para>
	</sect1>

	<sect1 id="rkdev_example"
><title
>Exemplo prático</title>
		<para
>Para que você tenha uma ideia de como <quote
>criar um script para um plugin</quote
> funciona, em comparação com a abordagem direta que você viu nos capítulos anteriores, criaremos o plugin completo do teste t mais uma vez -- desta vez apenas com as funções &R; do pacote <application
>rkwarddev</application
>.</para>

		<tip
><para
>O pacote adicionará uma nova caixa de diálogo &GUI; ao &rkward; em <menuchoice
><guimenu
>Arquivo</guimenu
><guimenuitem
>Exportar</guimenuitem
><guimenuitem
>Criar script de plugin do &rkward;</guimenuitem
></menuchoice
>. Como o nome sugere, você pode criar esqueletos de plugins para edição posterior com ele. Esta caixa de diálogo foi gerada por um script <application
>rkwarddev</application
> que você pode encontrar no diretório <quote
>demo</quote
> do pacote instalado e nas fontes do pacote, como um exemplo adicional. Você também pode executá-lo chamando <function
>demo("skeleton_dialog")</function
></para
></tip>

		<sect2 id="rkdev_gui"
><title
>Descrição da &GUI;</title>
		<para
>Você notará imediatamente que o fluxo de trabalho é consideravelmente diferente: Ao contrário de escrever o código XML diretamente, você não começa com a definição do <command
>&lt;document&gt;</command
>, mas diretamente com os elementos do plugin que você gostaria de ter na caixa de diálogo. Você pode atribuir cada elemento da interface -- sejam caixas de seleção, menus suspensos, slots de variáveis ​​ou qualquer outra coisa -- a objetos &R; individuais e, em seguida, combinar esses objetos para formar a &GUI; propriamente dita. O pacote possui funções para <link linkend="interfaceelements"
>cada tag XML</link
> que pode ser usada para definir a &GUI; do plugin, e a maioria delas tem até o mesmo nome, apenas com o prefixo <function
>rk.XML.*</function
>. Por exemplo, definir um elemento <command
>&lt;varselector&gt;</command
> e dois elementos <command
>&lt;varslot&gt;</command
> para as variáveis ​<replaceable
>"x"</replaceable
> e <replaceable
>"y"</replaceable
> do teste t de exemplo pode ser feito da seguinte forma:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("comparar", source=variables, types="number", required=TRUE, id.name="x")
var.y &lt;- rk.XML.varslot("contra", source=variables, types="number", required=TRUE, id.name="y")
                </programlisting>
		<para
>O detalhe mais interessante é provavelmente <parameter
>source=</parameter
><replaceable
>variables</replaceable
>: Uma característica importante do pacote é que todas as funções podem gerar IDs automáticos, então você não precisa se preocupar em pensar em valores de <parameter
>id</parameter
> ou em lembrá-los para se referir a um elemento específico do plugin. Você pode simplesmente fornecer os objetos &R; como referência, pois todas as funções que precisam de um ID de algum outro elemento também podem lê-lo desses objetos. <function
>rk.XML.varselector()</function
> é um pouco especial, pois geralmente não tem um conteúdo específico para gerar um ID (pode ter, mas apenas se você especificar um rótulo), então precisamos definir um nome de ID. Mas <function
>rk.XML.varslot()</function
> não precisaria dos argumentos <parameter
>id.name</parameter
> aqui, então isso seria suficiente:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("comparar", source=variables, types="number", required=TRUE)
var.y &lt;- rk.XML.varslot("contra", source=variables, types="number", required=TRUE)
                </programlisting>
		<para
>Para recriar o código de exemplo exatamente como estava, você teria que definir todos os valores de ID manualmente. Mas como o pacote facilitará nossa vida, a partir de agora não nos preocuparemos mais com isso.</para>
		<tip>
			<para
><application
>rkwarddev</application
> é capaz de muita automação para ajudar você a criar seus plugins. No entanto, pode ser preferível não usá-lo em sua totalidade. Se seu objetivo é produzir um código que não apenas funcione mas também possa ser facilmente lido e comparado ao seu script gerador por um ser humano, você deve considerar sempre definir IDs úteis com <parameter
>id.name</parameter
>. Nomear seus objetos &R; de forma idêntica a esses IDs também ajudará a obter um código de script fácil de entender. </para>
		</tip>
		<para
>Se você quiser ver como o código XML do elemento definido se parece se você o exportasse para um arquivo, basta chamar o objeto pelo nome. Então, se você agora chamar <quote
>var.x</quote
> na sua sessão do &R;, você deverá ver algo como isto:</para>
		<programlisting
>&lt;varslot id="vrsl_compare" label="comparar" source="vars" types="number" required="true" /&gt;
                </programlisting>
		<para
>Algumas tags só são úteis no contexto de outras. Portanto, por exemplo, você não encontrará uma função para a tag <command
>&lt;option&gt;</command
>. Em vez disso, tanto os botões de opção quanto as listas suspensas são definidos incluindo suas opções como uma lista nomeada, onde os nomes representam os rótulos a serem exibidos na caixa de diálogo, e seu valor é um vetor nomeado que pode ter duas entradas: <parameter
>val</parameter
> para o valor de uma opção e o booleano <parameter
>chk</parameter
> para especificar se esta opção está marcada por padrão.</para>
		<programlisting
>test.hypothesis &lt;- rk.XML.radio("usar hipótese de teste",
        options=list(
                "Dois lados"=c(val="two.sided"),
                "Primeiro é maior"=c(val="greater"),
                "Segundo é maior"=c(val="less")
        )
)
                </programlisting>
		<para
>O resultado é o seguinte:</para>
		<programlisting
>&lt;radio id="rad_usngtsth" label="usar hipótese de teste"&gt;
        &lt;option label="Dois lados" value="two.sided" /&gt;
        &lt;option label="Primeiro é maior" value="greater" /&gt;
        &lt;option label="Segundo é maior" value="less" /&gt;
&lt;/radio&gt;
                </programlisting>
		<para
>Tudo o que falta nos elementos da aba <quote
>Configurações básicas</quote
> é a caixa de seleção para amostras pareadas e a estruturação de todos esses elementos em linhas e colunas:</para>
		<programlisting
>check.paired &lt;- rk.XML.cbox("Amostras pareadas", value="1", un.value="0")
basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))
                </programlisting>
		<para
>A <function
>rk.XML.cbox()</function
> é uma rara exceção onde o nome da função não contém o nome completo da tag, para economizar digitação para este elemento frequentemente usado. Isto é o que <function
>basic.settings</function
> agora contém:</para>
		<programlisting
>&lt;row id="row_vTFSPP10TF"&gt;
        &lt;varselector id="vars" /&gt;
        &lt;column id="clm_vrsTFSPP10"&gt;
                &lt;varslot id="vrsl_compare" label="comparar" source="vars" types="number" required="true" /&gt;
                &lt;varslot id="vrsl_against" label="contra" i18n_context="comparar contra" source="vars" types="number" required="true" /&gt;
                &lt;radio id="rad_usngtsth" label="usar hipótese de teste"&gt;
                        &lt;option label="Dois lados" value="two.sided" /&gt;
                        &lt;option label="Primeiro é maior" value="greater" /&gt;
                        &lt;option label="Segundo é maior" value="less" /&gt;
                &lt;/radio&gt;
                &lt;checkbox id="chc_Pardsmpl" label="Amostras pareadas" value="1" value_unchecked="0" /&gt;
        &lt;/column&gt;
&lt;/row&gt;
                </programlisting>
		<para
>De maneira semelhante, as próximas linhas criarão objetos &R; para os elementos da aba <quote
>Opções</quote
>, introduzindo funções para caixas de seleção, molduras e espaços:</para>
		<programlisting
>check.eqvar &lt;- rk.XML.cbox("assumir variâncias iguais", value="1", un.value="0")
conf.level &lt;- rk.XML.spinbox("nível de confiança", min=0, max=1, initial=0.95)
check.conf &lt;- rk.XML.cbox("imprimir intervalo de confiança", val="1", chk=TRUE)
conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")
                </programlisting>
		<para
>Agora, tudo o que precisamos fazer é juntar os objetos em um tabbook e colocá-lo em uma seção de diálogo:</para>
		<programlisting
>full.dialog &lt;- rk.XML.dialog(
        label="Teste t com duas variáveis",
        rk.XML.tabbook(tabs=list("Configurações básicas"=basic.settings, "Opções"=list(check.eqvar, conf.frame)))
)
                </programlisting>
		<para
>Também podemos criar a seção do assistente com suas duas páginas usando os mesmos objetos, portanto, seus IDs serão extraídos para as tags <command
>&lt;copy&gt;</command
>:</para>
		<programlisting
>full.wizard &lt;- rk.XML.wizard(
                label="Teste t com duas variáveis",
                rk.XML.page(
                        rk.XML.text("Como primeiro passo, selecione duas variáveis que você deseja comparar.
                                E especifique qual você teoriza que é maior. Selecione dois lados,
                                se sua teoria não te informa qual variável é maior."),
                        rk.XML.copy(basic.settings)),
                rk.XML.page(
                        rk.XML.text("Abaixo estão algumas opções avançadas. É geralmente seguro não considerar que as
                                variáveis tenha variância igual. Uma correção apropriada será aplicada então.
                                Escolher \"assumir variâncias iguais\" pode aumentar a força do teste, no entanto."),
                        rk.XML.copy(check.eqvar),
                        rk.XML.text("Algumas vezes é útil obter uma estimativa do intervalo de confiança da
                                diferença em significado. Abaixo você pode especificar se um deve ser exibido, e
                                qual nível de confiança deve ser aplicado (95% corresponde a 5% de nível de
                                significância)."),
                        rk.XML.copy(conf.frame)))
                </programlisting>
		<para
>Isso é tudo para a &GUI;. O documento global será combinado no final por <function
>rk.plugin.skeleton()</function
>.</para>
		</sect2>

		<sect2 id="rkdev_jscode"
><title
>Código &javascript;</title>
			<para
>Até agora, usar o pacote <application
>rkwarddev</application
> pode não parecer ter ajudado muito. Isso vai mudar agora.</para>
			<para
>Primeiramente, assim como não precisamos nos preocupar com os IDs dos elementos ao definir o layout da &GUI;, também não precisamos nos preocupar com os nomes das variáveis &javascript; na próxima etapa. Se você quiser mais controle, pode escrever código &javascript; puro e colá-lo no arquivo gerado. Mas provavelmente é muito mais eficiente fazer isso da maneira do <application
>rkwarddev</application
>.</para>
			<para
>O mais notável é que você não precisa definir nenhuma variável manualmente, pois <function
>rk.plugin.skeleton()</function
> pode analisar seu código &XML; e definir automaticamente todas as variáveis ​​que você provavelmente precisará -- por exemplo, você não se preocuparia em incluir uma caixa de seleção se não usar seu valor ou estado posteriormente. Assim, podemos começar a escrever o código JS que gera o código &R; imediatamente.</para>
			<tip
><para
>A função <function
>rk.JS.scan()</function
> também pode analisar arquivos &XML; em busca de variáveis.</para
></tip>
			<para
>O pacote possui algumas funções para construções de código JS que são comumente usadas em plugins &rkward;, como a função <function
>echo()</function
> ou as condições <function
>if() {...} else {...}</function
>. Existem algumas diferenças entre JS e &R;, &eg;, para <function
>paste()</function
> em &rkward; você usa a vírgula para concatenar strings de caracteres, enquanto para <function
>echo()</function
> em JS você usa <quote
>+</quote
>, e as linhas devem terminar com um ponto e vírgula. Ao usar as funções &R;, você pode praticamente esquecer essas diferenças e continuar escrevendo código &R;.</para>
			<para
>Essas funções podem receber diferentes classes de objetos de entrada: texto simples, objetos &R; com código &XML; como o acima ou, por sua vez, resultados de outras funções JS do pacote. No final, você sempre chamará <function
>rk.paste.JS()</function
>, que se comporta de forma semelhante a <function
>paste()</function
>, mas, dependendo dos objetos de entrada, irá substituí-los por seus IDs &XML;, nomes de variáveis &javascript; ou até mesmo blocos de código &javascript; completos.</para>
			<para
>Para o exemplo do teste t, precisamos de dois objetos JS: um para calcular os resultados e outro para imprimi-los na função <function
>printout()</function
>.</para>
		<programlisting
>JS.calc &lt;- rk.paste.JS(
        echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
        js(
                if(check.paired){
                        echo(", paired=TRUE")
                },
                if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                },
                if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                },
                linebreaks=TRUE
        ),
        echo(")\n"),
        level=2
)

JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)
                </programlisting>
		<para
>Como você pode ver, <application
>rkwarddev</application
> também fornece uma implementação de &R; da função <function
>echo()</function
>. Ela retorna exatamente uma string de um caractere com uma versão JS válida de si mesma. Você também pode notar que todos os objetos &R; aqui são aqueles que criamos anteriormente. Eles serão automaticamente substituídos por seus nomes de variáveis, então isso deve ser bastante intuitivo. Sempre que você precisar apenas dessa substituição, a função <function
>id()</function
> pode ser usada, que também retornará exatamente uma string de um caractere de todos os objetos que lhe foram fornecidos (você poderia dizer que ela se comporta como <function
>paste()</function
> com uma substituição de objeto muito específica).</para>
    <para
>A função <function
>js()</function
> é um wrapper que permite usar as condições <command
>if(){...} else {...}</command
> do &R; como você já está acostumado. Elas serão traduzidas diretamente para código JS. Também preserva alguns operadores como <command
>&lt;</command
>, <command
>&gt;=</command
> ou <command
>||</command
>, para que você possa comparar logicamente seus objetos &R; sem a necessidade de aspas na maioria das vezes. Vejamos o objeto <quote
>JS.calc</quote
> resultante, que agora contém uma string de caracteres com o seguinte conteúdo:</para>
		<programlisting
>echo("res &lt;- t.test (x=" + vrslCompare + ", y=" + vrslAgainst + ", hypothesis=\"" + radUsngtsth + "\"");
        if(chcPardsmpl) {
                echo(", paired=TRUE");
        } else {}
        if(!chcPardsmpl &amp;&amp; chcAssmqlvr) {
                echo(", var.equal=TRUE");
        } else {}
        if(spnCnfdnclv != "0.95") {
                echo(", conf.level=" + spnCnfdnclv);
        } else {}
        echo(")\n");
                </programlisting>
    <note>
      <para
>Alternativamente, para condições <function
>if()</function
> aninhadas em <function
>js()</function
>, você pode usar a função <function
>ite()</function
>, que se comporta de forma semelhante à função <function
>ifelse()</function
> do pacote &R;. No entanto, instruções condicionais construídas usando <function
>ite()</function
> geralmente são mais difíceis de ler e devem ser substituídas por <function
>js()</function
> sempre que possível. </para>
    </note>
		</sect2>

		<sect2 id="rkdev_pluginmap"
><title
>Mapa de plugin</title>
		<para
>Esta seção é muito curta: Não precisamos escrever um &pluginmap; pois ele pode ser gerado automaticamente por <function
>rk.plugin.skeleton()</function
>. A hierarquia do menu pode ser especificada através da opção <parameter
>pluginmap</parameter
>:</para>
			<programlisting
>[...]
        pluginmap=list(
                name="Teste t com duas variáveis",
                hierarchy=list("análise", "significado", "Teste t"))
        [...]
                        </programlisting>
		</sect2>

		<sect2 id="rkdev_rkh"
><title
>Página de ajuda</title>
			<para
>Esta seção também é muito curta: <function
>rk.plugin.skeleton()</function
> não consegue escrever uma página de ajuda completa com as informações que possui. Mas ela consegue analisar o documento &XML; em busca de elementos que provavelmente merecem uma entrada na página de ajuda e criar automaticamente um modelo de página de ajuda para o nosso plugin. Tudo o que precisamos fazer depois é escrever algumas linhas para cada seção listada.</para>
			<tip
><para
>A função <function
>rk.rkh.scan()</function
> também pode analisar arquivos &XML; para criar um esqueleto de arquivo de ajuda.</para
></tip>
		</sect2>

		<sect2 id="rkdev_plugin_generator"
><title
>Gerar arquivos do plugin</title>
			<para
>Agora vem a etapa final, na qual entregaremos todos os objetos gerados para <function
>rk.plugin.skeleton()</function
>:</para>
			<programlisting
>plugin.dir &lt;- rk.plugin.skeleton("Teste t",
        xml=list(
                dialog=full.dialog,
                wizard=full.wizard),
        js=list(
                results.header="Teste t com duas variáveis",
                calculate=JS.calc,
                printout=JS.print),
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("análise", "significados", "Teste t")),
        load=TRUE,
        edit=TRUE,
        show=TRUE)
                        </programlisting>
			<para
>Os arquivos serão criados em um diretório temporário por padrão. As três últimas opções não são necessárias, mas são muito úteis: <parameter
>load=</parameter
><replaceable
>TRUE</replaceable
> adicionará automaticamente o novo plugin à configuração do &rkward; (já que ele está em um diretório temporário e, portanto, deixará de existir quando o &rkward; for fechado, ele será removido automaticamente pelo &rkward; na próxima inicialização), <parameter
>edit=</parameter
><replaceable
>TRUE</replaceable
> abrirá todos os arquivos criados para edição nas abas do editor do &rkward; e <parameter
>show=</parameter
><replaceable
>TRUE</replaceable
> tentará iniciar o plugin diretamente, para que você possa ver como ele é sem precisar clicar. Você pode considerar adicionar <parameter
>overwrite=</parameter
><replaceable
>TRUE</replaceable
> se você for executar seu script repetidamente (por exemplo, após alterações no código), pois, por padrão, nenhum arquivo será sobrescrito.</para>
			<para
>O objeto de resultado <quote
>plugin.dir</quote
> contém o caminho para o diretório no qual o plugin foi criado. Isso pode ser útil em combinação com a função <function
>rk.build.package()</function
>, para construir um pacote &R;real para compartilhar seu plugin com outras pessoas -- &eg;, enviando-o para a equipe de desenvolvimento da &rkward; para ser adicionado ao nosso repositório de plugins.</para>
		</sect2>
		<sect2 id="rkdev_ttest_script"
><title
>O script completo</title>
		<para
>Para recapitular tudo o que foi dito acima, aqui está o script completo para criar o exemplo de teste t funcional. Além do código já explicado, ele também carrega o pacote, se necessário, e usa o ambiente <function
>local()</function
>, portanto, todos os objetos criados não ficarão no seu espaço de trabalho atual (exceto o arquivo <quote
>plugin.dir</quote
>):</para>
		<programlisting
>require(rkwarddev)

local({
        variables &lt;- rk.XML.varselector(id.name="vars")
        var.x &lt;- rk.XML.varslot("comparar", source=variables, types="number", required=TRUE)
        var.y &lt;- rk.XML.varslot("contra", source=variables, types="number", required=TRUE)
        test.hypothesis &lt;- rk.XML.radio("usar hipótese de teste",
                options=list(
                        "Two-sided"=c(val="two.sided"),
                        "First is greater"=c(val="greater"),
                        "Second is greater"=c(val="less")
                )
        )
        check.paired &lt;- rk.XML.cbox("Amostra pareadas", value="1", un.value="0")
        basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))

        check.eqvar &lt;- rk.XML.cbox("assumir variâncias iguais", value="1", un.value="0")
        conf.level &lt;- rk.XML.spinbox("nível de confiança", min=0, max=1, initial=0.95)
        check.conf &lt;- rk.XML.cbox("imprimir intervalo de confiança", val="1", chk=TRUE)
        conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Intervalo de confiança")

        full.dialog &lt;- rk.XML.dialog(
                label="Teste t com duas variáveis",
                rk.XML.tabbook(tabs=list("Configurações básicas"=basic.settings, "Opções"=list(check.eqvar, conf.frame)))
        )

        full.wizard &lt;- rk.XML.wizard(
                label="Teste t com duas variáveis",
                rk.XML.page(
                        rk.XML.text("Como primeiro passo, selecione duas variáveis que você deseja comparar.
                                E especifique qual você teoriza que é maior. Selecione dois lados,
                                se sua teoria não te informa qual variável é maior."),
                                rk.XML.copy(basic.settings)),
                        rk.XML.page(
                        rk.XML.text("Abaixo estão algumas opções avançadas. É geralmente seguro não considerar que as
                                variáveis tenha variância igual. Uma correção apropriada será aplicada então.
                                Escolher \"assumir variâncias iguais\" pode aumentar a força do teste, no entanto."),
                                rk.XML.copy(check.eqvar),
                        rk.XML.text("Algumas vezes é útil obter uma estimativa do intervalo de confiança da
                                diferença em significado. Abaixo você pode especificar se um deve ser exibido, e
                                qual nível de confiança deve ser aplicado (95% corresponde a 5% de nível de
                                significância)."),
                                rk.XML.copy(conf.frame)))

        JS.calc &lt;- rk.paste.JS(
                echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
                js(
                        if(check.paired){
                        echo(", paired=TRUE")
                        },
                        if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                        },
                        if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                        },
                        linebreaks=TRUE
                ),
                echo(")\n"), level=2)

        JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)

        plugin.dir &lt;&lt;- rk.plugin.skeleton("t-Test",
                xml=list(
                        dialog=full.dialog,
                        wizard=full.wizard),
                js=list(
                        results.header="Teste t com duas variáveis",
                        calculate=JS.calc,
                        printout=JS.print),
                pluginmap=list(
                        name="Two Variable t-Test",
                        hierarchy=list("análise", "significados", "Teste t")),
                load=TRUE,
                edit=TRUE,
                show=TRUE,
                overwrite=TRUE)
})
                </programlisting>
		</sect2>

  </sect1>
  <sect1 id="rkwarddev_rkh"
><title
>Adicionar páginas de ajuda</title>
    <para
>Se você deseja escrever uma página de ajuda para o seu plugin, a maneira mais direta de fazer isso é adicionar as instruções específicas diretamente às definições dos elementos &XML; aos quais elas pertencem: </para>
    <programlisting
>variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Selecione o objeto de dados que gostaria de analisar.",
  component="Data"
)
    </programlisting>
    <para
>O texto fornecido ao parâmetro <parameter
>help</parameter
> pode então ser obtido por <function
>rk.rkh.scan()</function
> e escrito na página de ajuda deste componente de plugin. Para que isso funcione tecnicamente, no entanto, <function
>rk.rkh.scan()</function
> deve saber quais objetos &R; pertencem a um componente de plugin. É por isso que você também deve fornecer o parâmetro <parameter
>component</parameter
> e garantir que ele seja idêntico para todos os objetos pertencentes ao mesmo componente. </para>
    <para
>Como você geralmente combinará muitos objetos em um único diálogo e também poderá querer reutilizar objetos como o <command
>&lt;varslot&gt;</command
> em vários componentes de seus plugins, é possível definir globalmente um componente com a função <function
>rk.set.comp()</function
>. Se definida, presume-se que todos os objetos subsequentes usados ​​em seu script pertencem a esse componente específico, até que <function
>rk.set.comp()</function
> seja chamada novamente com um nome de componente diferente. Você pode então omitir o parâmetro <parameter
>component</parameter
>: </para>
    <programlisting
>rk.set.comp("Data")
variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Selecione o objeto de dados que gostaria de analisar."
)
    </programlisting>
    <para
>Para adicionar seções globais como <command
>&lt;summary&gt;</command
> ou <command
>&lt;usage&gt;</command
> à página de ajuda, você usa funções como <function
>rk.rkh.summary()</function
> ou <function
>rk.rkh.usage()</function
> conforme necessário. Os resultados dessas funções são então usados ​​para definir os elementos da lista, como <parameter
>summary</parameter
> ou <parameter
>usage</parameter
>, no <parameter
>rkh</parameter
> parâmetro de <function
>rk.plugin.component()</function
>/<function
>rk.plugin.skeleton()</function
>. </para>
	</sect1>
  <sect1 id="rkwarddev_i18n"
><title
>Traduzir plugins</title>
    <para
>O pacote <application
>rkwarddev</application
> é capaz de produzir plugins externos com suporte completo a internacionalização (i18n). Por exemplo, todas as funções relevantes que geram objetos XML oferecem um parâmetro opcional para especificar <replaceable
>i18n_context</replaceable
> ou <replaceable
>noi18n_label</replaceable
>: </para>
    <programlisting
>varComment &lt;- rk.XML.varselector(id.name="vars", i18n=list(comment="Seletor de variável principal"))
varContext &lt;- rk.XML.varselector(id.name="vars", i18n=list(context="Seletor de variável principal"))
cboxNoi18n &lt;- rk.XML.cbox(label="Power", id.name="power", i18n=FALSE)
    </programlisting>
    <para
>Os exemplos acima produzem resultados como este:</para>
    <programlisting
># varComment
&lt;!-- i18n: Seletor de variável principal --&gt;
  &lt;varselector id="vars" /&gt;

# varContext
&lt;varselector id="vars" i18n_context="Seletor de variável principal" /&gt;

# cboxNoi18n
&lt;checkbox id="power" noi18n_label="Força" value="true" /&gt;
    </programlisting>
    <para
>Há também suporte para código JS traduzível. Na verdade, o pacote tenta adicionar chamadas <function
>i18n()</function
> por padrão em locais onde isso é geralmente útil. A função <function
>rk.JS.header()</function
> é um bom exemplo: </para>
    <programlisting
>jsHeader &lt;- rk.JS.header("Testar resultados")
    </programlisting>
    <para
>Isso gera o seguinte código JS:</para>
    <programlisting
>new Header(i18n("Testar resultados")).print();
    </programlisting>
    <para
>Mas você também pode marcar manualmente strings em seu código JS como traduzíveis, usando a função <function
>i18n()</function
> da mesma forma que faria se escrevesse o arquivo JS diretamente.</para>
  </sect1>
</chapter>

<appendix id="reference">
<title
>Referência</title>

<sect1 id="propertytypes"
><title
>Tipos de propriedades/Modificadores</title>
<para
>Em alguns trechos desta introdução, mencionamos as <quote
>propriedades</quote
> de elementos da &GUI; ou outros. Na verdade, existem vários tipos diferentes de propriedades. Normalmente, você não precisa se preocupar com isso, pois pode usar o bom senso para conectar qualquer propriedade a qualquer outra. No entanto, internamente, existem diferentes tipos de propriedades. Isso é importante para a recuperação de valores especiais no modelo JS. Nas instruções getString("id")/getBoolean("id")/getList("id"), você também pode especificar alguns dos chamados <quote
>modificadores</quote
>, como este: <function
>getString("id.modificador")</function
>. Esse modificador afetará a forma como o valor é impresso. Continue lendo para ver a lista de propriedades e os modificadores que cada uma delas disponibiliza: </para>
<variablelist>
<varlistentry>
<term
>Propriedades de string</term>
<listitem
><para
>O tipo de propriedade mais simples, usado simplesmente para armazenar um trecho de texto. Modificadores: <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>A string conforme definida/configurada.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>quoted</term>
	<listitem
><para
>A string em formato de aspas (adequada para ser passada para &R; como caractere).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades boleanas</term>
<listitem
><para
>Propriedades que podem ser ativadas ou desativadas, verdadeiras ou falsas. Por exemplo, as propriedades criadas por tags &lt;convert&gt;, bem como a propriedade que acompanha uma &lt;checkbox&gt; (veja abaixo). Os seguintes valores serão retornados de acordo com o modificador fornecido: <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>Por padrão, a propriedade retornará 1 se for verdadeira e 0 caso contrário. A maneira recomendada de obter valores booleanos é usando <function
>getBoolean()</function
>. Observe que, para <function
>getString()</function
>, a string "0" será retornada quando a propriedade for falsa. Essa string seria avaliada como verdadeira, e não como falsa, em JavaScript.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"labeled"</term>
	<listitem
><para
>Retorna a string "true" quando verdadeiro, "false" quando falso, ou quaisquer strings personalizadas que tenham sido especificadas (normalmente em uma &lt;checkbox&gt;).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"true"</term>
	<listitem
><para
>Retorna a string como se a propriedade fosse verdadeira, mesmo que seja falsa.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"false"</term>
	<listitem
><para
>Retorna a string como se a propriedade fosse falsa, mesmo que seja verdadeira.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"not"</term>
	<listitem
><para
>Isso na verdade retorna outra propriedade booleana, que é o inverso da atual (&ie;, falso se verdadeiro, verdadeiro se falso)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"numeric"</term>
	<listitem
><para
>Obsoleto, fornecido para compatibilidade com versões anteriores. Equivalente a nenhum modificador "". Retorna "1" se a propriedade for verdadeira ou "0" se for falsa.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades de inteiro</term>
<listitem
><para
>Uma propriedade projetada para armazenar um valor inteiro (mas, é claro, ainda retorna uma string de caracteres numéricos para o modelo JS). Não aceita nenhum modificador. Usada em &lt;spinbox&gt;es (veja abaixo)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades de número real</term>
<listitem
><para
>Uma propriedade projetada para armazenar um valor numérico real (mas, é claro, ainda retorna uma string de caracteres numéricos para o modelo JS). Usada em &lt;spinbox&gt;es (veja abaixo) <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>Para <function
>getValue() / getString()</function
>, isso retorna o mesmo que "formatted". Em versões futuras, será possível obter uma representação numérica.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"formatted"</term>
	<listitem
><para
>Retorna o número formatado (como uma string).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades RObject</term>
<listitem
><para
>Uma propriedade projetada para selecionar um ou mais objetos &R;. Usada principalmente em varselectors e varslots. Os seguintes valores serão retornados de acordo com o modificador fornecido: <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>Por padrão, a propriedade retornará o nome completo do objeto selecionado. Se mais de um objeto for selecionado, os nomes dos objetos serão separados por quebras de linha ("\n").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"shortname"</term>
	<listitem
><para
>Semelhante ao anterior, mas retorna apenas o(s) nome(s) abreviado(s) do(s) objeto(s). Por exemplo: um objeto dentro de uma lista receberia apenas o nome que possui dentro da lista, sem o nome da lista.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"label"</term>
	<listitem
><para
>Semelhante ao anterior, mas retorna o(s) rótulo(s) do(s) objeto(s) &rkward; (se nenhum rótulo estiver disponível, isso é o mesmo que nome curto)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades de lista de strings</term>
<listitem
><para
>Esta propriedade contém uma lista de strings. <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>Para <function
>getValue()/getString()</function
>, isso retorna todas as strings separadas por "\n". Quaisquer caracteres "\n" em cada item são escapados como literalmente "\n". No entanto, o uso recomendado é buscar o valor com <function
>getList()</function
>, que retornará uma matriz de strings.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"joined"</term>
	<listitem
><para
>Retorna a lista como uma única string, com os itens unidos por "\n". Em contraste com a ausência de modificador (""), as strings individuais _não_ são escapadas.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propriedades de código</term>
<listitem
><para
>Uma propriedade mantida por plugins que geraram código. Isso é importante para incorporar plugins, a fim de incorporar o código gerado pelo plugin incorporado no código gerado pelo plugin incorporador (de nível superior). Os os seguintes valores serão retornados de acordo com o modificador fornecido: <variablelist>
	<varlistentry>
	<term
>Sem modificador ("")</term>
	<listitem
><para
>Retorna o código completo, ou seja, as seções "preprocess", "calculate", "printout" e (mas não "preview") concatenadas em uma única string.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preprocess"</term>
	<listitem
><para
>Retorna apenas a seção de pré-processamento do código</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"calculate"</term>
	<listitem
><para
>Retorna apenas a seção de cálculo do código</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"printout"</term>
	<listitem
><para
>Retorna apenas a seção de impressão do código</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preview"</term>
	<listitem
><para
>Retorna a seção de pré-visualização do código</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="globalxmlelements">
	<title
>Elementos de uso geral para serem utilizados em qualquer arquivo &XML; (<literal role="extensão"
>.xml</literal
>, <literal role="extensão"
>.rkh</literal
>, &pluginmap;)</title>
	<variablelist>
	<varlistentry>
	<term
>&lt;snippets&gt;</term>
	<listitem
><para
>Permitido como filho direto do nó &lt;document&gt; e somente lá. Deve ser colocado próximo ao início do arquivo. Consulte a seção <link linkend="snippets"
>sobre como usar snippets</link
>. Apenas um elemento &lt;snippets&gt; pode estar presente. Opcional, sem atributos.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;snippet&gt;</term>
	<listitem
><para
>Define um único trecho. Permitido apenas como filho direto do elemento &lt;snippets&gt;. Atributos: <variablelist
> <varlistentry>
		<term
>&lt;id&gt;</term>
		<listitem
><para
>Uma string identificadora para o trecho de código. Obrigatória.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;insert&gt;</term>
	<listitem
><para
>Insere o conteúdo de um &lt;snippet&gt;. Permitido em qualquer lugar. Atributos: <variablelist
> <varlistentry>
		<term
>&lt;snippet&gt;</term>
		<listitem
><para
>A string de identificação do trecho de código a ser inserido. Obrigatório.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;include&gt;</term>
	<listitem
><para
>Inclui o conteúdo de outro arquivo &XML; (tudo dentro do elemento &lt;document&gt; desse arquivo). Permitido em qualquer lugar. Atributos: <variablelist
> <varlistentry>
		<term
>&lt;file&gt;</term>
		<listitem
><para
>O nome do arquivo, relativo ao diretório onde o arquivo atual se encontra. Obrigatório.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	</variablelist>
</sect1>

<sect1 id="xmlelements"
><title
>Elementos a serem usados ​​na descrição &XML; do plugin</title>
<para
>As propriedades mantidas pelos elementos são listadas em uma <link linkend="elementproperties"
>seção separada</link
>.</para>

<sect2 id="generalelements"
><title
>Elementos gerais</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Precisa estar presente em cada arquivo description.xml como nó raiz. Sem função especial. Sem atributos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Informações sobre este plugin (autor, licença, &etc;.). Este elemento é permitido tanto no arquivo <literal role="extension"
>.xml</literal
> de um plugin individual quanto nos arquivos &pluginmap;. Consulte a <link linkend="pluginmapelements"
>referência do arquivo &pluginmap;</link
> para obter detalhes de referência e o <link linkend="chapter_about_information"
> o capítulo sobre informações do 'about'</link
> para uma introdução.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;code&gt;</term>
<listitem
><para
>Define onde procurar o modelo JS para o plugin. Use apenas uma vez por arquivo, como filho direto da tag document. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nome do arquivo do modelo JS, relativo ao diretório onde o arquivo xml do plugin está localizado.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;help&gt;</term>
<listitem
><para
>Define onde procurar o arquivo de ajuda do plugin. Use apenas uma vez por arquivo, como um filho direto da tag document. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nome do arquivo de ajuda, relativo ao diretório onde o arquivo xml do plugin está localizado.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;copy&gt;</term>
<listitem
><para
>Pode ser usado como filho (direto ou indireto) dos elementos de layout principais, &ie;, &lt;dialog&gt; e &lt;wizard&gt;. Isso é usado para copiar um bloco inteiro de elementos &XML; 1:1. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID a ser procurado. A tag &lt;copy&gt; procurará um elemento &XML; anterior que tenha recebido o mesmo ID e o copiará, incluindo todos os elementos descendentes.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>copy_element_tag_name</parameter
></term>
	<listitem
><para
>Em alguns casos, você desejará uma cópia quase literal, mas alterará o nome da tag do elemento a ser copiado. O exemplo mais importante disso é quando você deseja copiar uma &lt;tab&gt; inteira de uma interface de diálogo para a &lt;page&gt; de uma interface de assistente. Nesse caso, você definiria copy_element_tag_name="page" para fazer essa conversão automaticamente.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="interfaceelements"
><title
>Definições da interface</title>
<variablelist>
<varlistentry>
<term
>&lt;dialog&gt;</term>
<listitem
><para
>Define uma interface do tipo diálogo. Coloque a definição &GUI; dentro desta tag. Use apenas uma vez por arquivo, como filho direto da tag document. Pelo menos uma das tags "dialog" ou "wizard" é necessária para um plugin. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o diálogo</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>O diálogo deve ser usado como a interface "recomendada" (&ie;, a interface que será exibida por padrão, a menos que o usuário tenha configurado o &rkward; para usar uma interface específica por padrão)? Este atributo não tem efeito atualmente, pois é implicitamente "verdadeiro", a menos que o assistente seja recomendado.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;wizard&gt;</term>
<listitem
><para
>Define uma interface do tipo assistente. Coloque a definição da &GUI; dentro desta tag. Use apenas uma vez por arquivo, como filho direto da tag document. Pelo menos uma das tags "dialog" ou "wizard" é necessária para um plugin. Aceita apenas tags &lt;page&gt; ou &lt;embed&gt; como filhos diretos. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o assistente</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>O assistente deve ser usado como a interface "recomendada" (&ie;, a interface que será exibida por padrão, a menos que o usuário tenha configurado o &rkward; para usar uma interface específica por padrão)? Opcional, o padrão é "false".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="layoutelements"
><title
>Elementos do layout</title>
<para
>Todos os elementos desta seção aceitam um atributo id="identifierstring". Este atributo é opcional para todos os elementos. Ele pode ser usado, por exemplo, para ocultar/desativar todo o elemento de layout e todos os elementos contidos nele (consulte o capítulo <link linkend="logic"
>lógica da &GUI;</link
>). A string de identificação não pode conter "." (ponto) ou ";" (ponto e vírgula) e deve geralmente ser limitada a caracteres alfanuméricos e ao sublinhado ("_"). Apenas os atributos adicionais estão listados.</para>
<variablelist>
<varlistentry>
<term
>&lt;page&gt;</term>
<listitem
><para
>Define uma nova página dentro de um assistente. Só é permitido como filho direto de um elemento &lt;wizard&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;row&gt;</term>
<listitem
><para
>Todos os filhos diretos de uma tag "row" serão colocados da esquerda para a direita.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;column&gt;</term>
<listitem
><para
>Todos os filhos diretos de uma tag "column" serão colocados de cima para baixo.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;stretch&gt;</term>
<listitem
><para
>Por padrão, os elementos da &GUI; ocupam todo o espaço disponível. Por exemplo, se você tiver duas colunas lado a lado, a da esquerda está repleta de elementos, mas a da direita contém apenas um botão de opção (<command
>&lt;radio&gt;</command
>), o controle <command
>&lt;radio&gt;</command
> se expandirá verticalmente, mesmo que não precise do espaço disponível, e ficará com uma aparência ruim. Nesse caso, você realmente deseja adicionar um espaço em branco abaixo do <command
>&lt;radio&gt;</command
>. Para isso, use o elemento &lt;stretch&gt;. Ele simplesmente ocupará um pouco de espaço. Não abuse desse elemento, geralmente é uma boa prática que os elementos da &GUI; ocupem todo o espaço disponível, apenas ocasionalmente o layout ficará espaçado. O elemento &lt;stretch&gt; não aceita nenhum argumento, nem mesmo um "id". Além disso, você não pode colocar nenhum filho dentro do elemento &lt;stretch&gt; (em outras palavras, você o usará apenas como "&lt;stretch/&gt;").</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Desenha uma moldura/caixa ao redor de seus filhos diretos. Pode ser usado para agrupar visualmente opções relacionadas. O layout dentro de uma moldura é de cima para baixo, a menos que você coloque uma &lt;row&gt; dentro dela. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a moldura (opcional)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>Os frames podem ser marcados. Nesse caso, todos os elementos contidos neles serão desativados quando o frame estiver desmarcado e ativados quando estiver marcado. (opcional, o padrão é "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Somente para frames marcáveis: Se o frame deve ser marcado por padrão? O padrão é "true". Não é interpretado para frames não marcáveis.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tabbook&gt;</term>
<listitem
><para
>Organiza elementos em um livro de abas. Aceita apenas tags &lt;tab&gt; como filhos diretos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tab&gt;</term>
<listitem
><para
>Você define a página em um livro de abas. Coloque a definição da &GUI; para a aba dentro desta tag. Pode ser usada apenas como filha direta de uma tag &lt;tabbook&gt;. Em um &lt;tabbook&gt;, deve haver pelo menos duas abas definidas. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a página da aba (obrigatória)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Exibe o texto contido nesta tag na &GUI;. Algumas marcações simples em estilo &HTML; são suportadas (principalmente <markup
>&lt;b&gt;</markup
>, <markup
>&lt;i&gt;</markup
>, <markup
>&lt;p&gt;</markup
> e <markup
>&lt;br/&gt;</markup
>). No entanto, mantenha a formatação ao mínimo. Inserir uma linha completamente vazia adiciona uma quebra de linha. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Tipo de texto. Um dos seguintes: "normal", "aviso" ou "erro". Isso influencia a aparência do texto (opcional, o padrão é normal)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="activeelements"
><title
>Elementos ativos</title>
<para
>Todos os elementos desta seção aceitam um atributo id="identifierstring". Este atributo é obrigatório para todos os elementos. Somente os atributos adicionais estão listados. A string de identificação não pode conter "." (pontos).</para>
<variablelist>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Fornece uma lista de objetos disponíveis a partir da qual o usuário pode selecionar um ou mais. Requer um ou mais &lt;varslots&gt; como contrapartida para ser útil. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o seletor de variáveis ​​(opcional, o padrão é "Selecionar variável(eis)")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>Usado em conjunto com um "seletor de variáveis" para permitir que o usuário selecione uma ou mais variáveis. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o varslot (recomendado, o padrão é "Variável:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source</parameter
></term>
	<listitem
><para
>O seletor de variáveis ​​para obter a seleção (obrigatório, a menos que você se conecte manualmente ou usando source_property)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source_property</parameter
></term>
	<listitem
><para
>Uma propriedade arbitrária da qual copiar valores quando o botão de seleção é clicado. Se especificada, esta propriedade substitui o atributo "source".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Se - para submeter o código - é necessário que este varslot contenha um valor válido. Consulte <link linkend="elementproperties"
>required-property</link
> (opcional, o padrão é falso)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>multi</parameter
></term>
	<listitem
><para
>Indica se o varslot contém apenas um objeto (padrão, "false") ou vários objetos</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_duplicates</parameter
></term>
	<listitem
><para
>Se o varslot pode aceitar apenas objetos únicos (padrão, "false") ou se o mesmo objeto pode ser adicionado várias vezes.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars</parameter
></term>
	<listitem
><para
>Só faz sentido se multi="true": Número mínimo de variáveis ​​a serem selecionadas para que a seleção seja considerada válida (opcional, o padrão é "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars_if_any</parameter
></term>
	<listitem
><para
>Só faz sentido se multi="true": Alguns espaços para variáveis ​​podem ser considerados válidos, se, por exemplo, o espaço para variáveis ​​estiver vazio ou contiver pelo menos dois valores. Isso especifica quantas variáveis ​​devem ser selecionadas, se houver alguma (2 no exemplo). (opcional, o padrão é "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_vars</parameter
></term>
	<listitem
><para
>Só faz sentido se multi="true": Número máximo de variáveis ​​a selecionar (opcional, o padrão é "0", o que significa que não há máximo)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>classes</parameter
></term>
	<listitem
><para
>Se você especificar um ou mais nomes de classe &R; (separados por espaços (" ")), aqui, o varslot aceitará apenas objetos pertencentes a essas classes (opcional, <emphasis
>use com muita cautela</emphasis
>, o usuário não deve ser impedido de fazer escolhas válidas, e &R; possui <emphasis
>muitas</emphasis
> classes diferentes)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>types</parameter
></term>
	<listitem
><para
>Se você especificar um ou mais tipos de variáveis ​​(separados por espaços (" ")), aqui, o varslot aceitará apenas objetos desses tipos. Os tipos válidos são "unknown", "number", "string", "factor", "invalid". (Opcional, <emphasis
>use com muita cautela</emphasis
>, o usuário não deve ser impedido de fazer escolhas válidas, e o &rkward; nem sempre sabe o tipo de uma variável)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>num_dimensions</parameter
></term>
	<listitem
><para
>O número de dimensões que um objeto precisa ter. "0" (o padrão) Significa que qualquer número de dimensões é aceitável. (opcional, o padrão é "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_length</parameter
></term>
	<listitem
><para
>O comprimento mínimo que um objeto precisa ter para ser aceitável. (opcional, o padrão é "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_length</parameter
></term>
	<listitem
><para
>O comprimento máximo que um objeto precisa ter para ser aceitável. (opcional, o padrão é o maior número inteiro representável no sistema)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Fornece uma lista de strings disponíveis (não objetos &R;) para serem selecionadas em um ou mais &lt;valueslots&gt; acompanhantes. As opções de string podem ser definidas usando tags &lt;option&gt; como filhos diretos (veja abaixo) ou definidas usando propriedades dinâmicas. <link linkend="elementproperties"
>properties</link
>. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o seletor de valores (opcional, o padrão é nenhuma legenda)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Usado em conjunto com um &lt;valueselector&gt; para permitir que o usuário selecione um ou mais itens de string. Este elemento é praticamente idêntico a &lt;varslot&gt;, e compartilha os mesmos atributos, exceto aqueles que se referem às propriedades dos itens aceitáveis ​​(ou seja, classes, tipos, num_dimensions, min_length, max_length).</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Define um grupo de botões exclusivos de rádio (apenas um pode ser selecionado por vez). Requer pelo menos duas tags &lt;option&gt; como filhos diretos. Nenhuma outra tag é permitida como filho. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o controle remoto (recomendado, o padrão é "Selecione uma opção:")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Define um grupo de opções, das quais apenas uma pode ser selecionada por vez, usando uma lista suspensa. Isso é funcionalmente equivalente a um &lt;radio&gt;, mas tem uma aparência diferente. Requer pelo menos duas tags &lt;option&gt; como filhos diretos. Nenhuma outra tag é permitida como filha. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a lista suspensa (recomendado, o padrão é "Selecione uma opção:")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Fornece uma lista de strings disponíveis a partir das quais o usuário pode selecionar um número arbitrário. As opções de string podem ser definidas usando tags &lt;option&gt; como filhos diretos (veja abaixo) ou definidas usando <link linkend="elementproperties"
>properties</link
> dinâmicas. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o &lt;select&gt; (opcional, o padrão é nenhuma legenda)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>single</parameter
></term>
	<listitem
><para
>Se definido como verdadeiro, apenas um único valor poderá ser selecionado, em vez de vários valores simultaneamente. (booleano, padrão é falso)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Só pode ser usado como filho direto de um elemento &lt;radio&gt;, &lt;dropdown&gt;, &lt;valueselector&gt; ou &lt;select&gt;. Representa uma opção selecionável em um controle de rádio ou lista suspensa. Como os elementos &lt;option&gt; são sempre parte de um dos elementos de seleção, eles normalmente não têm um "id" próprio, mas veja abaixo. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a opção (obrigatória)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>O valor da string que o elemento pai retornará se esta opção estiver marcada/selecionada (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Indica se a opção deve ser marcada/selecionada por padrão "true" ou "false". Em um &lt;radio&gt; ou &lt;dropdown&gt;, apenas uma opção pode ser definida como <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, e se nenhuma opção for definida como marcada, a primeira opção no elemento pai será marcada/selecionada automaticamente. Em um &lt;select&gt;, qualquer número de opções pode ser definido como marcado. (opcional, padrão "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>Especificar o "id" do parâmetro para os elementos &lt;option&gt; é opcional (e, na verdade, é recomendado não definir um "id", a menos que você realmente precise de um). No entanto, especificar um "id" permitirá que você habilite/desabilite &lt;option&gt; dinamicamente, conectando-se à propriedade booleana <replaceable
>id_of_radio.id_of_optionX.enabled</replaceable
>. Atualmente, isso funciona apenas para opções dentro de elementos &lt;radio&gt; ou &lt;dropdown&gt;. As opções &lt;valueselector&gt; e &lt;select&gt; não suportam IDs no momento.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Define uma caixa de seleção, &ie;, uma única opção que pode ser ativada ou desativada. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a caixa de seleção (obrigatória)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>O valor que a caixa de seleção retornará se estiver marcada (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value_unchecked</parameter
></term>
	<listitem
><para
>O valor que será retornado se a caixa de seleção não estiver marcada (opcional, o padrão é "", &ie;, uma string vazia)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Indica se a opção deve ser marcada por padrão como "verdadeiro" ou "falso" (opcional, padrão "falso")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>O elemento frame é geralmente usado como um elemento de layout puro e está listado na seção sobre <link linkend="layoutelements"
>elementos de layout</link
>. No entanto, ele também pode ser marcado, funcionando assim como uma caixa de seleção simples. Ao mesmo tempo, </para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Define um campo de entrada de texto livre. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o campo de entrada (obrigatória)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Texto inicial do campo de texto (opcional, o padrão é "", ou seja, uma string vazia)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>size</parameter
></term>
	<listitem
><para
>Uma das opções "small" (pequeno), "medium" (médio) ou "large" (grande). "Grande" define um campo de entrada com várias linhas, "pequeno" e "médio" são campos de linha única (opcional, o padrão é "medium")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Se - para submeter o código - é necessário que esta entrada não esteja vazia. Consulte <link linkend="elementproperties"
>required-property</link
> (opcional, o padrão é falso)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;matrix&gt;</term>
<listitem
><para
>Uma tabela para inserir dados matriciais (ou vetores) na &GUI;.</para
> <note
><para
>Este elemento de entrada <emphasis
>não</emphasis
> está otimizado para inserir/editar grandes quantidades de dados. Embora não haja um limite estrito para o tamanho de uma &lt;matrix&gt;, em geral, ela não deve exceder cerca de dez linhas/colunas. Se você espera dados maiores, permita que os usuários os selecionem como um objeto &R; (o que pode ser uma boa ideia como opção alternativa, em quase <emphasis
>todos</emphasis
> casos em que você usa um elemento de matriz).</para
></note
> <para
>Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a tabela (obrigatória)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Um dos seguintes valores: "integer" (inteiro), "real" ou "string". O tipo de dados que será aceito na tabela (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Valor mínimo aceitável (para matrizes do tipo "inteiro" ou "real") (opcional, o padrão é o menor valor representável)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Valor máximo aceitável (para matrizes do tipo "inteiro" ou "real") (opcional, o padrão é o maior valor representável)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_missings</parameter
></term>
	<listitem
><para
>Indica se valores ausentes (vazios) são permitidos na matriz. Isso está implícito para matrizes ou modo "string" (opcional, o padrão é falso).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_columns</parameter
></term>
	<listitem
><para
>Quando definido como verdadeiro, o usuário pode adicionar colunas digitando nas células mais à direita (inativas) (opcional, o padrão é verdadeiro).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_rows</parameter
></term>
	<listitem
><para
>Quando definido como verdadeiro, o usuário pode adicionar linhas digitando nas células mais inferiores (inativas) (opcional, o padrão é verdadeiro).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>rows</parameter
></term>
	<listitem
><para
>Número de linhas na matriz. Não tem efeito para allow_user_resize_rows="true". " <note
><para
>Isso também pode ser controlado definindo a propriedade "rows".</para
></note
> (opcional, o padrão é 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>columns</parameter
></term>
	<listitem
><para
>Número de colunas na matriz. Não tem efeito para allow_user_resize_columns="true". <note
><para
>Isso também pode ser controlado definindo a propriedade "columns".</para
></note
> (opcional, o padrão é 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Número mínimo de linhas na matriz. A matriz não será reduzida abaixo desse tamanho. (opcional, o padrão é 0; veja também: <parameter
>allow_missings</parameter
>.).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_columns</parameter
></term>
	<listitem
><para
>Número mínimo de colunas na matriz. A matriz não será reduzida abaixo desse tamanho. (opcional, o padrão é 0; veja também: <parameter
>allow_missings</parameter
>.).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_height</parameter
></term>
	<listitem
><para
>Força o elemento da &GUI; a permanecer em sua altura inicial. Não use em combinação com matrizes, onde o número de linhas pode mudar de alguma forma. Útil, especialmente ao criar um elemento de entrada vetorial (columns="1"). Com esta opção definida como verdadeira, nenhuma barra de rolagem horizontal será exibida, mesmo que a matriz exceda a largura disponível (pois isso afetaria a altura). (opcional, o padrão é falso).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_width</parameter
></term>
	<listitem
><para
>Ligeiramente mal nomeado: Assume que a contagem de colunas não mudará. A última (ou normalmente a única) coluna será esticada para ocupar a largura disponível. Não use em combinação com matrizes, onde o número de colunas pode mudar de alguma forma. Útil, especialmente ao criar um elemento de entrada vetorial (linhas="1"). (opcional, o padrão é falso).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>horiz_headers</parameter
></term>
	<listitem
><para
>Textos a serem usados ​​para o cabeçalho horizontal, separados por ";". O cabeçalho ficará oculto se definido como "". (opcional, o padrão é o número da coluna).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>vert_headers</parameter
></term>
	<listitem
><para
>Strings a serem usadas para o cabeçalho vertical, separadas por ";". O cabeçalho ficará oculto se definido como "". (opcional, o padrão é o número da linha).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;optionset&gt;</term>
<listitem
><para
>Uma interface de usuário para repetir um conjunto de opções para um número arbitrário de itens (<link linkend="optionset"
>introdução a conjuntos de opções</link
>). Atributos:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Se especificado, o conjunto será marcado como inválido, a menos que tenha pelo menos este número de linhas (opcional, inteiro).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows_if_any</parameter
></term>
	<listitem
><para
>Semelhante a min_rows, mas só será testado se houver pelo menos uma linha. (opcional, inteiro).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_rows</parameter
></term>
	<listitem
><para
>Se especificado, o conjunto será marcado como inválido, a menos que tenha no máximo este número de linhas (opcional, inteiro).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>keycolumn</parameter
></term>
	<listitem
><para
>ID da coluna que atuará como coluna-chave. Um conjunto de opções com uma coluna-chave (válida) atenderá como um conjunto de opções "controlado". Um conjunto de opções sem coluna-chave permitirá a inserção/remoção manual de itens. A coluna-chave deve ser marcada como externa. (opcional, o padrão é nenhuma coluna-chave).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elementos-filho:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;optioncolumn&gt;</term>
	<listitem
><para
>Declara uma coluna de opções do conjunto. Para cada valor que você deseja obter do conjunto de opções, você deve declarar um &lt;optioncolumn&gt; separado. Atributos: <variablelist>
			<varlistentry
><term
><parameter
>id</parameter
></term>
			<listitem
><para
>O ID da coluna de opções (obrigatório, string).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>external</parameter
></term>
			<listitem
><para
>Defina como verdadeiro se a coluna de opções for controlada externamente ao conjunto de opções. (opcional, booleano, o padrão é falso).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>label</parameter
></term>
			<listitem
><para
>Se fornecida, a coluna de opções será exibida em uma coluna com esse rótulo. (opcional, texto, o padrão é não exibir).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>connect</parameter
></term>
			<listitem
><para
>A propriedade à qual esta coluna de opções será conectada, fornecida como id dentro da área de &lt;content&gt;. Para &lt;optioncolumn&gt; externas, o valor correspondente será definido como o valor definido externamente. Para &lt;optioncolumn&gt; regulares (não externas), a linha correspondente da propriedade da &lt;optioncolumn&gt; será definida quando a propriedade for alterada dentro da área de conteúdo. (opcional, string, o padrão é não conectado).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>default</parameter
></term>
			<listitem
><para
>Apenas para colunas externas: O valor a ser assumido para esta coluna, caso nenhum valor seja conhecido para uma entrada. Raramente útil. (Opcional, o padrão é uma string vazia)</para
></listitem
></varlistentry>
		</variablelist>
	</para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;content&gt;</term>
	<listitem
><para
>Declare o conteúdo/interface do usuário do conjunto. Sem atributos. Todos os elementos ativos, passivos e de layout usuais são permitidos como elementos childname. Além disso, em versões anteriores do &rkward; (até a 0.6.3), o elemento filho especial <command
>&lt;optiondisplay&gt;</command
> era permitido. Isso está obsoleto na versão 0.6.4 do &rkward; e deve ser simplesmente removido dos plugins existentes. </para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;logic&gt;</term>
	<listitem
><para
>Especificação opcional da lógica da interface do usuário para aplicar <emphasis
>dentro</emphasis
> da região de conteúdo do conjunto de opções. Consulte <link linkend="logicelements"
>a referência sobre &lt;logic&gt;</link
> </para
></listitem
></varlistentry>
	</variablelist>
</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Um elemento projetado para selecionar um único nome de arquivo (ou nome de diretório). Observe que este campo aceita qualquer string, embora seja destinado ao uso exclusivo de arquivos. <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o navegador (opcional, o padrão é "Digite o nome do arquivo")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Texto inicial do navegador (opcional, o padrão é "", ou &ie;, uma string vazia)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Uma das opções "file", "dir" ou "savefile". Para selecionar um arquivo existente, um diretório existente ou um arquivo inexistente, respectivamente (opcional, o padrão é "file")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_urls</parameter
></term>
	<listitem
><para
>Se &URL;s (não locais) podem ser selecionadas (opcional, o padrão é "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>filter</parameter
></term>
	<listitem
><para
>Filtro de tipo de arquivo, &eg; ("*.txt *.csv" para arquivos .txt e .csv). Uma entrada separada para "Todos os arquivos" é adicionada automaticamente (opcional, o padrão é "", ou seja, Todos os arquivos)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Se - para submeter o código - é necessário que o campo não esteja vazio. Observe que isso não significa necessariamente que o nome do arquivo selecionado seja válido. Consulte <link linkend="elementproperties"
>required-property</link
> (opcional, o padrão é verdadeiro)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Um elemento projetado para selecionar o nome de um objeto &R; para salvar (&ie;, geralmente não existente, ao contrário de um varslot): <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para o campo de entrada (opcional, o padrão é "Salvar em:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Texto inicial da entrada (opcional, o padrão é "my.data")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Para submeter o código, é necessário que o campo contenha um nome de objeto permitido? Consulte a propriedade <link linkend="elementproperties"
>required-property</link
> (opcional, o padrão é verdadeiro)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>Em muitos casos de uso, salvar em um objeto &R; é opcional. Nesses casos, uma caixa de seleção pode ser integrada ao elemento saveobject usando este atributo. Quando definido como verdadeiro, o objeto salvo será ativado/desativado pela caixa de seleção. Consulte a <link linkend="elementproperties"
>active-property</link
> do elemento saveobject (opcional, o padrão é falso)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Somente para elementos saveobject verificáveis: Se o controle está marcado/habilitado por padrão (opcional, o padrão é falso)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Uma caixa de seleção numérica na qual o usuário pode escolher um valor numérico, usando entrada direta pelo teclado ou pequenas setas para cima/para baixo. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda para a caixa de seleção (recomendado, o padrão é "Digite o valor:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>O menor valor que o usuário pode inserir na caixa de seleção (opcional, o padrão é o menor valor tecnicamente representável na caixa de seleção)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>O maior valor que o usuário pode inserir na caixa de seleção (opcional, o padrão é o maior valor tecnicamente representável na caixa de seleção)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>O valor inicial exibido na caixa de seleção (opcional, o padrão é "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Uma das opções "real" ou "integer" (inteiro). Indica se a caixa de seleção aceitará números reais ou apenas números inteiros (opcional, o padrão é "real")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default_precision</parameter
></term>
	<listitem
><para
>Só faz sentido se a caixa de seleção for do tipo "real". Especifica o número padrão de casas decimais exibidas na caixa de seleção (apenas essa quantidade de zeros à direita será exibida). Quando o usuário pressionar as setas para cima/para baixo, esse número de casas decimais será alterado. O usuário ainda poderá inserir valores com uma precisão maior, no entanto (veja abaixo) (opcional, o padrão é "2")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_precision</parameter
></term>
	<listitem
><para
>O número máximo de dígitos que podem ser representados de forma significativa (opcional, o padrão é "8")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>Este elemento avançado permite ao usuário selecionar uma fórmula/conjunto de interações a partir de variáveis ​​selecionadas. Por exemplo, para um GLM, este elemento pode ser usado para permitir que o usuário especifique os termos de interação no modelo. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>fixed_factors</parameter
></term>
	<listitem
><para
>O ID do varslot que contém os fatores fixos selecionados (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dependent</parameter
></term>
	<listitem
><para
>O ID do varslot que contém a variável dependente selecionada (obrigatório)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Incorpora um plugin diferente no atual (consulte o <link linkend="embedding"
>capítulo sobre incorporação</link
>). Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>component</parameter
></term>
	<listitem
><para
>O nome registrado do componente a ser incorporado (consulte o <link linkend="pluginmap"
>capítulo sobre registro de componentes</link
>) (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>as_button</parameter
></term>
	<listitem
><para
>Se definido como "true", apenas um botão será colocado na &GUI; incorporada. A &GUI; incorporada só será exibida (em uma janela separada) quando o botão for pressionado (opcional, o padrão é "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Só faz sentido se as_button="true": A legenda do botão (recomendado, o padrão é "Opções")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Caixa de seleção para ativar/desativar a funcionalidade de pré-visualização. Observe que, a partir da versão 0.6.5 do &rkward; os elementos <command
>&lt;preview&gt;</command
> (pré-visualização) são tratados de forma especial em diálogos de plugins (não em assistentes): Eles serão colocados na coluna de botões, independentemente de onde estejam definidos na interface do usuário. Ainda é uma boa prática defini-los em um local adequado no layout, para manter a compatibilidade com versões anteriores. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Legenda da caixa (opcional, o padrão é "Pré-visualização")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Tipo de pré-visualização. Os tipos suportados são "plot" (consulte o <link linkend="preview_plots"
>capítulo sobre pré-visualizações de gráficos</link
>), "output" (consulte o <link linkend="preview_output"
>capítulo sobre pré-visualizações de saída (HTML)</link
>), "data" (consulte o <link linkend="preview_data"
>pré-visualizações de dados</link
>) e "custom" (consulte o <link linkend="preview_custom"
>pré-visualizações personalizadas</link
>). (opcional, o padrão é "plot")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>placement</parameter
></term>
	<listitem
><para
>Posicionamento da pré-visualização: "attached" (à área de trabalho principal), "detached" (janela independente), "docked" (anexada à caixa de diálogo do plugin) e "default" (atualmente, é igual a "docked", mas poderá ser configurável pelo usuário em algum momento). Em geral, recomenda-se manter esta configuração como padrão para melhor consistência da interface do usuário (opcional, o padrão é "default").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>active</parameter
></term>
	<listitem
><para
>Indica se a pré-visualização está ativa por padrão. Em geral, apenas as pré-visualizações ancoradas (docked) devem ser ativadas por padrão e, mesmo para estas, há um motivo para que o padrão seja pré-visualizações inativas (opcional, o padrão é "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="logicelements"
><title
>Seção de lógica</title>
<variablelist>
<varlistentry>
<term
>&lt;logic&gt;</term>
<listitem
><para
>O elemento que contém a seção de lógica. Todos os elementos abaixo são permitidos somente dentro do elemento &lt;logic&gt;. O elemento &lt;logic&gt; é permitido somente como filho direto do elemento &lt;document&gt; (no máximo uma vez por documento) ou de elementos &lt;optionset&gt; (no máximo uma vez por optionset). A seção de lógica do documento se aplica tanto a GUIs &lt;dialog&gt; quanto a &lt;wizard&gt; da mesma forma.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;external&gt;</term>
<listitem
><para
>Cria uma nova propriedade (string) que deve ser conectada a uma propriedade externa caso o plugin seja incorporado. Consulte a seção <link linkend="embedding_incomplete"
>sobre plugins "incompletos"</link
>. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID da nova propriedade (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default</parameter
></term>
	<listitem
><para
>O valor de string padrão da nova propriedade, &ie;, o valor usado se a propriedade não estiver conectada a uma propriedade externa (opcional, o padrão é uma string vazia)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;i18n&gt;</term>
<listitem
><para
>Cria uma nova propriedade (string) que deve fornecer uma legenda internacionalizado (i18n). Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID da nova propriedade (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>A legenda. Isto será traduzido. (obrigatório)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;set&gt;</term>
<listitem
><para
>Define uma propriedade com um valor fixo (é claro que, se você conectar a propriedade a alguma outra propriedade, o valor não permanecerá fixo). Por exemplo, se você incorporar um plugin, mas quiser ocultar alguns de seus elementos, você pode definir a propriedade de visibilidade desses elementos como falsa. Útil especialmente para plugins incorporados. Nota: Se houver vários elementos &lt;set&gt; para um único <parameter
>id</parameter
>, o último a ser definido terá precedência. Isso às vezes será útil ao usar partes &lt;include&gt;. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID da propriedade a ser definida (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>to</parameter
></term>
	<listitem
><para
>O valor da string para definir a propriedade (obrigatório). Observação: Para propriedades booleanas, como visibilidade e habilitação, você normalmente definirá o atributo como "true" ou "false".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Cria uma nova propriedade booleana que depende do estado de uma ou mais propriedades diferentes. Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID da nova propriedade (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>sources</parameter
></term>
	<listitem
><para
>Os IDs das propriedades das quais esta propriedade dependerá. Uma ou mais propriedades podem ser especificadas, separadas por ";" (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>O modo de conversão/operação. Um dos seguintes: "equals" (igual a), "notequals" (diferente de), "range" (intervalo), "and" (E lógico) ou "or" (OU lógico). Se o modo for "igual a", a propriedade será verdadeira somente se: o valor de todas as suas fontes for igual ao padrão do atributo (veja abaixo). Se o modo for "diferente de", a propriedade será verdadeira somente se o valor de todas assuas fontes for diferente do padrão do atributo (veja abaixo). Se o modo for "intervalo", as fontes devem ser numéricas (inteiras ou reais). A propriedade será verdadeira somente se todas as fontes estiverem no intervalo especificado pelos atributos mínimo e máximo (veja abaixo). Se o modo for "E", as fontes devem ser propriedades booleanas. A propriedade será verdadeira somente se todas as fontes forem verdadeiras simultaneamente. Se o modo for "OU", as fontes devem ser propriedades booleanas. A propriedade será verdadeira somente se pelo menos uma das fontes for verdadeira. (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Só faz sentido nos modos equals ou notequals: o valor da string a ser comparado contra (obrigatório se estiver em um desses modos)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Somente significativo no modo range: o valor mínimo para comparação (opcional, o padrão é o menor número de ponto flutuante representável na máquina)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Somente significativo no modo range: o valor máximo para comparação (opcional, o padrão é o maior número de ponto flutuante representável na máquina)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>require_true</parameter
></term>
	<listitem
><para
>Se definida como "true", a propriedade se tornará obrigatória e só será considerada válida se seu estado for verdadeiro/ativado. Portanto, se a propriedade for falsa, ela bloqueará o botão <guibutton
>Enviar</guibutton
> (opcional, o padrão é "false"). <caution
><para
>Se você usar isso, certifique-se de que o usuário possa detectar facilmente o que está errado, por exemplo, mostrando um &lt;text&gt; explicativo.</para
></caution
></para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Cria uma nova propriedade que será repassada para diferentes propriedades de destino (ou strings fixas) com base no valor de uma propriedade de condição. Isso permite criar uma lógica semelhante às construções <function
>if()</function
> ou <function
>switch()</function
>. Atributos:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>O ID da nova propriedade (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>condition</parameter
></term>
	<listitem
><para
>O ID da propriedade de condição (obrigatório)</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elementos-filho:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;true&gt;</term>
	<listitem
><para
>Se a propriedade de condição for booleana, você pode especificar os dois elementos filhos: &lt;true&gt; e &lt;false&gt; (e somente estes). (Obrigatório, se &lt;false&gt; também for fornecido)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;false&gt;</term>
	<listitem
><para
>Se a propriedade de condição for booleana, você pode especificar os dois elementos filhos: &lt;true&gt; e &lt;false&gt; (e somente estes). (Obrigatório, se &lt;true&gt; também for fornecido)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;case&gt;</term>
	<listitem
><para
>Se a propriedade de condição não for booleana, você pode fornecer um número arbitrário de elementos &lt;case&gt;, um para cada valor da propriedade de condição que você deseja corresponder (pelo menos um elemento desse tipo é necessário se a propriedade de condição não for booleana).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;default&gt;</term>
	<listitem
><para
>Se a propriedade de condição não for booleana, o elemento opcional &lt;default&gt; permite especificar o comportamento caso nenhum elemento &lt;case&gt; corresponda ao valor da propriedade de condição (opcional, permitido apenas uma vez, em combinação com um ou mais elementos &lt;case&gt;).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Os elementos filhos &lt;true&gt;, &lt;false&gt;, &lt;case&gt; e &lt;default&gt; assumem os seguintes atributos:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Apenas para elementos &lt;case&gt;: O valor para comparar a propriedade de condição contra (obrigatório, string).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_value</parameter
></term>
	<listitem
><para
>Uma string fixa que deve ser fornecida como o valor da propriedade &lt;switch&gt; se a condição atual for atendida (obrigatório, se dynamic_value não for fornecido).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dynamic_value</parameter
></term>
	<listitem
><para
>O <parameter
>id</parameter
> da propriedade de destino que deve ser fornecido como o valor da propriedade &lt;switch&gt; se a condição atual corresponder (obrigatório, se fixed_value não for fornecido).</para
></listitem>
	</varlistentry>
	</variablelist>
	</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;connect&gt;</term>
<listitem
><para
>Conecta duas propriedades. A propriedade do cliente será alterada sempre que a propriedade do governador for alterada (mas não o contrário). Atributos: <variablelist>
	<varlistentry>
	<term
><parameter
>client</parameter
></term>
	<listitem
><para
>O ID da propriedade do cliente, ou seja, a propriedade que será ajustada (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>governor</parameter
></term>
	<listitem
><para
>O ID da propriedade do governador, &ie;, a propriedade que ajustará a propriedade do cliente. Isso pode incluir um modificador (obrigatório)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>reconcile</parameter
></term>
	<listitem
><para
>Se "verdadeiro", a propriedade do cliente ajustará a propriedade do governador na conexão de forma que a propriedade do governador aceite apenas valores que também sejam aceitáveis ​​pelo cliente (&eg;, suponha que o governador seja uma propriedade numérica com valor mínimo "0" e o cliente seja uma propriedade numérica com valor mínimo "100". O mínimo de ambas as propriedades será ajustado para 100, se reconcile="true"). Geralmente funciona apenas para propriedades do mesmo tipo básico (opcional, padrão "falso").</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dependency_check&gt;</term>
<listitem
><para
>Cria uma propriedade booleana que é verdadeira se as dependências especificadas forem atendidas, e falsa caso contrário. A sintaxe &XML; do elemento é a mesma do elemento <command
>&lt;dependencies&gt;</command
>, descrito na <link linkend="pluginmapelements"
>referência de &pluginmap;</link
>. A partir da versão 0.6.1, apenas as especificações de versão do &rkward; e &R; são consideradas, e não as dependências de pacotes ou pluginmaps.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;script&gt;</term>
<listitem
><para
>Define o código do script para controlar a lógica da interface do usuário. Consulte <link linkend="logic_scripted"
>a seção sobre lógica GUI com script</link
> para obter detalhes. O código do script a ser executado pode ser fornecido usando o atributo <parameter
>"file"</parameter
>, ou como um texto (comentado) do elemento. O elemento <command
>&lt;script&gt;</command
> não é permitido na seção <command
>&lt;logic&gt;</command
> de um conjunto de opções. Atributos: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nome do arquivo de script. (obrigatório)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

</variablelist>
</sect2>

</sect1
>	<!-- Elements in main XML -->

<sect1 id="elementproperties"
><title
>Propriedades dos elementos do plugin</title>
<para
>Todos os <link linkend="layoutelements"
>elementos de layout</link
> e todos os <link linkend="activeelements"
>elementos ativos</link
> possuem as seguintes propriedades, acessíveis através de "id_of_element.name_of_property": </para>
<variablelist>
<varlistentry>
<term
>visible</term>
<listitem
><para
>Indica se o elemento &GUI; está visível ou não (booleano)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>enabled</term>
<listitem
><para
>Indica se o elemento &GUI; está habilitado ou não (booleano)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>required</term>
<listitem
><para
>Indica se o elemento &GUI; é obrigatório (para conter uma configuração válida) ou não. Observe que qualquer elemento que esteja desativado ou oculto também é implicitamente não obrigatório (booleano).</para
></listitem>
</varlistentry>
</variablelist>
<para
>Além disso, alguns elementos possuem propriedades adicionais às quais você pode se conectar. A maioria dos elementos ativos também possui uma propriedade "padrão" cujo valor será retornado nas chamadas para <function
>getBoolean/getString/getList ("...")</function
>, caso nenhuma propriedade específica tenha sido nomeada, conforme descrito abaixo. </para>

<variablelist>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>A propriedade padrão é texto. <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>O texto exibido (texto)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Nenhuma propriedade padrão <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Os objetos atualmente selecionados. Provavelmente você não deseja usar isso. Usado internamente (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>root</term>
	<listitem
><para
>O objeto raiz/pai dos objetos oferecidos para seleção (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>A propriedade padrão é "available" <variablelist>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Todos os objetos armazenados no varslot (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Dos objetos contidos no varslot, aqueles que estão atualmente selecionados. Você provavelmente não deseja usar isso. Usado internamente (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>source</term>
	<listitem
><para
>Uma cópia dos objetos selecionados no seletor de variáveis ​​correspondente. Você provavelmente não deseja usar isso. Usado internamente (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>A propriedade padrão é "selected" <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>As strings atualmente selecionadas. Modificador "labeled" para recuperar os rótulos correspondentes. Em um &lt;valueselector&gt;, você provavelmente não deseja usar isso diretamente (somente em um &lt;select&gt;). (leitura/gravação de StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Lista de valores de string para seleção. (leitura/gravação de StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Legendas a serem exibidas para os valores de string. (lista de strings de leitura/gravação)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>Semelhante a &lt;varslot&gt;, mas as propriedades são listas de strings, em vez de RObjects.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>A propriedade padrão é "string" <variablelist>
	<varlistentry>
	<term
>string</term>
	<listitem
><para
>O valor da opção atualmente selecionada (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>number</term>
	<listitem
><para
>O número da opção atualmente selecionada (as opções são numeradas de cima para baixo, começando em 0) (número inteiro)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>O mesmo que &lt;radio&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>O mesmo que &lt;valueselector&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Não há propriedade padrão. "enabled" é a *única* propriedade e não está disponível atualmente para opções dentro de um &lt;select&gt; ou &lt;valueselector&gt;. &lt;option&gt; não possui as propriedades "visible" ou "required". <variablelist
> <varlistentry>
	<term
>enabled</term>
	<listitem
><para
>Indica se esta única opção deve ser ativada ou desativada. Na maioria dos casos, você ativará/desativará todo o &lt;radio&lt; ou &lt;dropdown&lt;. Mas isso pode ser usado para definir dinamicamente a ativação de uma única opção dentro de um &lt;radio&lt; ou &lt;dropdown&lt; (booleano)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>A propriedade padrão é "state.labeled", o que significa que os valores especificados pelos atributos <parameter
>value</parameter
> e <parameter
>value_unchecked</parameter
> são retornados, <emphasis
>não</emphasis
> a legenda exibida da caixa de seleção. <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Estado da caixa de seleção (ligada ou desligada). Observe que modificadores úteis desta propriedade (como de todas as propriedades booleanas) são "not" e "labeled" (consulte <link linkend="propertytypes"
>tipos de propriedades</link
>). No entanto, muitas vezes é mais útil conectar-se à propriedade sem modificador, ou seja, "<emphasis
>checkbox_id</emphasis
>.state", que retornará o estado da caixa de seleção em um formato adequado para uso em uma instrução if (0 ou 1). (booleano)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>A propriedade padrão é "checked" (marcada), se - e somente se - o frame for marcável. Para frames não marcáveis, não há propriedade padrão. <variablelist
> <varlistentry>
	<term
>checked</term>
	<listitem
><para
>Disponível apenas para quadros selecionáveis: estado da caixa de seleção (ativada ou desativada). Observe que modificadores úteis para esta propriedade (como para todas as propriedades booleanas) são "not" e "numeric" (consulte <link linkend="propertytypes"
>tipos de propriedades</link
>). (booleano)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>A propriedade padrão é "texto" <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Texto atual no campo de entrada (string)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;matrix&gt;</term>
	<listitem
><para
>A propriedade padrão é "cbind". <variablelist>
		<varlistentry>
			<term
>rows</term>
			<listitem
><para
>Número de linhas na matriz (inteiro). Se a matriz permitir que o usuário adicione/remova linhas, esta propriedade deve ser tratada como somente leitura. Caso contrário, alterá-la modificará o tamanho da matriz.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>columns</term>
			<listitem
><para
>Número de colunas na matriz (inteiro). Se a matriz permitir que o usuário adicione/remova colunas, esta propriedade deve ser tratada como somente leitura. Caso contrário, alterá-la modificará o tamanho da matriz.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>tsv</term>
			<listitem
><para
>Os dados na matriz estão em formato TSV (string; leitura e gravação). Observe que, em comparação com o layout TSV usual, as <emphasis
>colunas</emphasis
>, e não as linhas, são separadas por caracteres de nova linha, e as células dentro de uma coluna são separadas por caracteres de tabulação.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>0,1,2...</term>
			<listitem
><para
>Os dados de uma única coluna (0 para a coluna mais à esquerda). <function
>getValue()</function
>/<function
>getString()</function
> retorna isso como uma única string, separada por "\n". No entanto, a maneira recomendada de obter isso é usando <function
>getList()</function
>, que retorna esta coluna como uma matriz de strings.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>row.0,row.1,row.2...</term>
			<listitem
><para
>Os dados de uma única linha (0 para a linha superior). <function
>getValue()</function
>/<function
>getString()</function
> retorna isso como uma única string, separada por "\n". No entanto, a maneira recomendada de obter isso é usando <function
>getList()</function
>, que retorna esta linha como uma matriz de strings.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>cbind</term>
			<listitem
><para
>Dados em um formato adequado para colar em &R;, envolvidos em uma instrução cbind (string; somente leitura).</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;optionset&gt;</term>
	<listitem
><para
>Sem propriedade padrão. <variablelist>
		<varlistentry>
			<term
>row_count</term>
			<listitem
><para
>Número de itens no conjunto de opções (número inteiro). Somente leitura.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>current_row</term>
			<listitem
><para
>Item atualmente ativo no conjunto de opções (número inteiro). -1 para nenhum item ativo. Leitura e escrita.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
><emphasis
>optioncolumn_ids</emphasis
></term>
			<listitem
><para
>Para cada &lt;optioncolumn&gt; que você definir, uma propriedade de lista de strings será criada com o id especificado.</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>A propriedade padrão é "selection" <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Texto atual (nome do arquivo selecionado) no navegador (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>overwrite</parameter
></term>
	<listitem
><para
>Indica se a opção "overwrite" (sobrescrever) está marcada (booleano, somente leitura, ou seja, você pode ler o estado da caixa de seleção, mas não alterá-lo programaticamente)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>A propriedade padrão é "selection" <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Nome completo do objeto selecionado (string; somente leitura - para definir isso programaticamente, use "parent" e "objectname")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>parent</term>
	<listitem
><para
>O objeto parent (pai) do objeto selecionado. Este é sempre um objeto &R; existente de um tipo que pode conter outros objetos (por exemplo, uma lista ou um data.frame). Quando definido como uma string vazia ou um objeto inválido, assume-se ".GlobalEnv". (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>objectname</term>
	<listitem
><para
>O nome base do objeto selecionado, &ie;, a string inserida pelo usuário (alterada para um nome &R; válido, se necessário) (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>active</term>
	<listitem
><para
>Somente para objetos de salvamento verificáveis: Indica se o controle está marcado/habilitado. Sempre verdadeiro para objetos de salvamento não verificáveis ​​(booleano)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>A propriedade padrão é "int" ou "real.formatted", dependendo do modo do spinbox <variablelist>
	<varlistentry>
	<term
>int</term>
	<listitem
><para
>Valor inteiro armazenado na caixa de seleção, ou o inteiro mais próximo, se estiver no modo real (inteiro)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>real</term>
	<listitem
><para
>Valor real contido na caixa de seleção (e inteiro, se for um inteiro) (real)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>A propriedade padrão é "model" <variablelist>
	<varlistentry>
	<term
>model</term>
	<listitem
><para
>A string do modelo atual (string)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>table</term>
	<listitem
><para
>O data.frame que contém as variáveis ​​necessárias. Se forem usadas variáveis ​​de apenas um data.frame, o nome desse data.frame será retornado. Caso contrário, um novo data.frame será construído conforme necessário (string).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Se variáveis ​​de múltiplos data.frames estiverem envolvidas, seus nomes podem ficar alterados (por exemplo, se ambos os data.frames contiverem uma variável chamada "x"). Isso retorna uma lista com os nomes alterados como índices e a legenda descritiva como valor (string).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>fixed_factors</term>
	<listitem
><para
>Os fatores fixos. Provavelmente você não vai querer usar isso. Usado internamente (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>dependent</term>
	<listitem
><para
>A(s) variável(eis) dependente(s). Provavelmente você não vai querer usar isso. Usado internamente (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Nenhuma propriedade padrão <variablelist
> <varlistentry>
	<term
>code</term>
	<listitem
><para
>O código gerado pelo plugin incorporado (código)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>A propriedade padrão é "state" <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Indica se a caixa de pré-visualização está marcada (não necessariamente se a pré-visualização já foi exibida) (booleano)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Este elemento (usado na seção &lt;logic&gt;) é especial, pois tecnicamente *é* uma propriedade, em vez de apenas conter uma ou mais propriedades. É do tipo booleano. Observe que modificadores úteis para esta propriedade (como para todas as propriedades booleanas) são "not" e "numeric" (consulte <link linkend="propertytypes"
>tipos de propriedades</link
>)</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Este elemento (usado na seção &lt;logic&gt;) é especial, pois é tecnicamente uma propriedade (string), em vez de apenas armazenar uma ou mais propriedades. Ele permite alternar entre várias propriedades de destino dependendo do valor de uma propriedade de condição ou remapear os valores da propriedade de condição. Quaisquer modificadores fornecidos são passados ​​para as propriedades de destino; portanto, &eg;, se todas as propriedades de destino forem propriedades RObject, você também poderá usar o modificador "shortname" na chave. No entanto, se as propriedades de destino forem de tipos diferentes, o uso de modificadores pode levar a erros. Para <replaceable
>fixed_value</replaceable
>s, qualquer modificador é descartado silenciosamente. Observe que as propriedades de destino, quando acessadas por meio de uma chave, são sempre somente leitura.</para
></listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="standard_embeddable_plugins"
><title
>Plugins incorporáveis ​​incluídos na versão oficial &rkward;</title>
<para
>Vários plugins incorporáveis ​​são fornecidos com o &rkward; e podem ser usados ​​em seus próprios plugins. A documentação detalhada está disponível atualmente apenas nos arquivos de código-fonte ou de ajuda desses plugins. No entanto, aqui está uma lista para lhe dar uma visão geral rápida do que está disponível:</para>
<table frame='all'
><title
>Plugins padrão incorporáveis</title>
<tgroup cols='4'>
<thead>
<row>
  <entry
>ID</entry>
  <entry
>Pluginmap</entry>
  <entry
>Descrição</entry>
  <entry
>Exemplo de uso</entry>
</row>
</thead>
<tbody>
<row>
  <entry
>rkward::plot_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Oferece uma ampla gama de opções para gráficos. A maioria dos plugins de plotagem utiliza isto.</entry>
  <entry
>Gráficos->Gráfico de barras, a maioria dos outros plugins de plotagem</entry>
</row>
<row>
  <entry
>rkward::color_chooser</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Plugin muito simples para especificar uma cor. A implementação atual fornece uma lista de nomes de cores. Implementações futuras poderão fornecer opções de seleção de cores mais elaboradas.</entry>
  <entry
>Gráficos->Histograma</entry>
</row>
<row>
  <entry
>rkward::plot_stepfun_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opções do gráfico da função Passo</entry>
  <entry
>Gráficos->Gráfico ECDF</entry>
</row>
<row>
  <entry
>rkward::histogram_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opções (gráficas) do histograma</entry>
  <entry
>Gráficos->Histograma</entry>
</row>
<row>
  <entry
>rkward::barplot_embed</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opções da barra de gráficos</entry>
  <entry
>Gráficos->Barra de gráficos</entry>
</row>
<row>
  <entry
>rkward::one_var_tabulation</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Fornece tabelas com base em uma única variável.</entry>
  <entry
>Gráficos->Barra de gráficos</entry>
</row>
<row>
  <entry
>rkward::limit_vector_length</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Limitar o comprimento de um vetor (aos n maiores ou menores elementos).</entry>
  <entry
>Gráficos->Barra de gráficos</entry>
</row>
<row>
  <entry
>rkward::level_select</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Fornece um &lt;valueselector&gt; preenchido com os níveis (ou valores únicos) de um vetor.</entry>
  <entry
>Dados->Recodificar dados categóricos</entry>
</row>
<row>
  <entry
>rkward::multi_input</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Combina controles de spinbox, entrada e rádio para fornecer entrada de dados de caracteres, numéricos e lógicos.</entry>
  <entry
>Dados->Recodificar dados categóricos</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>

<sect1 id="pluginmapelements"
><title
>Elementos para uso em arquivos &pluginmap;</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Precisa estar presente em cada arquivo &pluginmap; como nó raiz (exatamente uma vez). Atributos: <variablelist>
	<varlistentry>
	<term
>base_prefix</term>
	<listitem
><para
>Os nomes de arquivo especificados no arquivo &pluginmap; são considerados relativos ao diretório do arquivo &pluginmap; + o prefixo especificado aqui. Útil, especialmente se todos os seus componentes estiverem localizados em um único subdiretório.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>namespace</term>
	<listitem
><para
>Um espaço de nomes para os IDs dos componentes. Ao procurar componentes para incorporação, os componentes poderão ser recuperados por meio da string "namespace::component_id". Definido como "rkward" por enquanto.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Uma string identificadora opcional para este &pluginmap;. Especificar isso permite que autores terceirizados se refiram ao seu &pluginmap; e o carreguem a partir do deles (consulte o <link linkend="chapter_dependencies"
>capítulo sobre como lidar com dependências</link
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>priority</term>
	<listitem
><para
>Uma das opções <replaceable
>"hidden"</replaceable
>, <replaceable
>"low"</replaceable
>, <replaceable
>"medium"</replaceable
> ou <replaceable
>"high"</replaceable
>. Os &pluginmap; com prioridade "medium" ou "high" são ativados automaticamente quando o &rkward; os encontra pela primeira vez. Use <replaceable
>priority="hidden"</replaceable
> para &pluginmap;s que não devem ser ativados, diretórios (apenas para inclusão). Na implementação atual, isso não oculta o &pluginmap;. (Opcional, o padrão é "medium").</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;dependencies&gt;</term>
<listitem
><para
>Este elemento, que especifica dependências, é permitido como filho direto do elemento &lt;document&gt; (uma vez) e como filho de elementos &lt;component&gt; (uma vez para cada elemento &lt;component&gt;). Especifica as dependências que devem ser atendidas para usar o(s) plugin(s). Consulte o <link linkend="chapter_dependencies"
>capítulo sobre dependências</link
> para uma visão geral. Atributos:</para>
	<variablelist>
	<varlistentry>
	<term
>rkward_min_version, rkward_max_version</term>
	<listitem
><para
>Versão mínima e máxima permitida do &rkward;. As especificações de versão podem incluir sufixos não numéricos, como "0.5.7z-devel1". Se uma dependência especificada não for atendida, o(s) plugin(s) ao(s) qual(is) ela se aplica <emphasis
>serão ignorados</emphasis
>. <link linkend="sect_dependencies_rkward_version"
>Mais informações</link
>. Opcional; se não for especificado, nenhuma versão mínima/máxima do &rkward; será exigida.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>R_min_version, R_max_version</term>
	<listitem
><para
>Versão mínima e máxima permitida do &R;. As especificações de versão <emphasis
>não</emphasis
> podem incluir sufixos não numéricos, como "0.5.7z-devel1". A dependência da versão do &R; será exibida nas páginas de ajuda dos plugins, mas não tem efeito direto, a partir da versão 0.6.1 do &rkward;. <link linkend="sect_dependencies_r_version"
>Mais informações</link
>. Opcional; se não for especificado, nenhuma versão mínima/máxima do &R; será exigida.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>platforms</term>
	<listitem
><para
>Plataformas onde este plugin está disponível. Os valores suportados são <replaceable
>"unix"</replaceable
>, <replaceable
>"windows"</replaceable
>, <replaceable
>"macos"</replaceable
>, <replaceable
>"any"</replaceable
> e combinações separadas por dois pontos (por exemplo, <replaceable
>"unix:macos"</replaceable
>). <replaceable
>"unix"</replaceable
> inclui quaisquer variantes de Linux e BSD, mas <emphasis
>não</emphasis
> MacOS. Se o seu plugin não depender de plataforma, basta omitir este atributo.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elementos-filho:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;package&gt;</term>
	<listitem
><para
>Adiciona uma dependência a um pacote &R; específico. Atributos: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Nome do pacote (obrigatório).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Versão mínima/máxima permitida (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>repository</term>
		<listitem
><para
>Repositório onde o pacote pode ser encontrado. Opcional, mas altamente recomendado, caso o pacote não esteja disponível no CRAN.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;pluginmap&gt;</term>
	<listitem
><para
>Adiciona uma dependência a um específico &pluginmap; do &rkward;. Atributos: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>String de identificação do &pluginmap; obrigatório (obrigatório).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Versão mínima/máxima permitida (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>&URL; onde o &pluginmap; pode ser encontrado. Obrigatório.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Pode estar presente exatamente uma vez como filho direto do elemento &lt;document&gt;. Contém metainformações sobre o &pluginmap; (ou plugin). Consulte o <link linkend="chapter_about_information"
>capítulo sobre informações do 'about'</link
> para obter uma visão geral. Atributos:</para>
	<variablelist>
	<varlistentry>
	<term
>name</term>
	<listitem
><para
>Nome visível do usuário. Opcional. Não precisa ser o mesmo que o "id".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>version</term>
	<listitem
><para
>Número da versão. Opcional. O formato não é restrito, mas para maior segurança, siga esquemas de versionamento comuns, como "x.y.z".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>releasedate</term>
	<listitem
><para
>Especificação da data de lançamento. Opcional, no formato "YYYY-MM-DD".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>shortinfo</term>
	<listitem
><para
>Uma <emphasis
>breve</emphasis
> descrição do plugin / &pluginmap;. Opcional.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>url</term>
	<listitem
><para
>&URL; onde você pode encontrar mais informações. Opcional, mas recomendado.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>copyright</term>
	<listitem
><para
>Especificação de direitos autorais, &eg;: "2012-2013 por John Doe". Opcional, mas recomendado.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>licence</term>
	<listitem
><para
>Especificação da licença, &eg;, "GPL" ou "BSD". Certifique-se de acompanhar seus arquivos com uma cópia completa da licença relevante. Opcional, mas recomendado.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>category</term>
	<listitem
><para
>Categoria de plugin(s), &eg;, "Teoria de resposta ao item". A partir da versão 0.6.1, nenhuma categoria está predefinida. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elementos-filho:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;author&gt;</term>
	<listitem
><para
>Adiciona informações sobre um autor. Atributos: <variablelist>
		<varlistentry>
		<term
>name, given, family</term>
		<listitem
><para
>Especifique o nome completo para <parameter
>name</parameter
>, ou especifique <parameter
>given</parameter
> e <parameter
>family</parameter
> separadamente.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>role</term>
		<listitem
><para
>Descrição da função do autor (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>email</term>
		<listitem
><para
>Endereço de e-mail para contato com o autor. Obrigatório. Pode ser definido como a lista de discussão rkward-devel, caso você esteja inscrito e seu plugin seja destinado a ser incluído na versão oficial do &rkward;.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>&URL; com mais informações sobre o autor, &eg; página inicial (opcional).</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;components&gt;</term>
<listitem
><para
>Precisa estar presente exatamente uma vez como filho direto do elemento &lt;document&gt;. Contém os elementos &lt;component&gt; individuais descritos abaixo. Sem atributos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;component&gt;</term>
<listitem
><para
>Um ou mais elementos &lt;component&gt; devem ser fornecidos como filhos diretos do elemento &lt;components&gt; (e somente lá). Registra um componente/plugin com o rkward. Atributos: <variablelist>
	<varlistentry>
	<term
>type</term>
	<listitem
><para
>Para futuras extensões: O tipo de componente/plugin. Por enquanto, sempre definido como "padrão" (o único tipo atualmente suportado).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>O ID pelo qual este componente pode ser recuperado (para colocá-lo no menu (veja abaixo), ou para incorporá-lo). Veja &lt;document&gt;-namespace acima.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Requerido pelo menos para componentes do tipo "padrão": O nome do arquivo &XML; que descreve a &GUI;.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>A legenda para este componente, quando colocado na hierarquia do menu.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>optional</term>
	<listitem
><para
>Só faz sentido para componentes com <link linkend="chapter_dependencies"
>dependencies</link
> definidas: Normalmente, é considerado um erro reportável se um componente não for compatível com esta versão do RKWard. No entanto, se o componente realmente não for necessário no ambiente atual, definir este atributo como <replaceable
>"true"</replaceable
> suprime qualquer aviso (<replaceable
>"false"</replaceable
> por padrão).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;attribute&gt;</term>
<listitem
><para
>Define um atributo de um componente. Até o momento, só faz sentido para <link linkend="context_import"
>plugins de importação</link
>. Permitido apenas como um filho direto de &lt;component&gt;. Atributos: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Id do atributo</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>value</term>
	<listitem
><para
>Valor do atributo</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Legenda associada ao atributo</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;hierarchy&gt;</term>
<listitem
><para
>Precisa estar presente exatamente uma vez como filho direto do elemento &lt;document&gt;. Descreve onde os componentes declarados acima devem ser colocados na hierarquia do menu. Aceita apenas elementos &lt;menu&gt; como filhos diretos. Sem atributos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;menu&gt;</term>
<listitem
><para
>Um ou mais elementos &lt;menu&gt; devem ser fornecidos como filhos diretos do elemento &lt;hierarchy&gt;. Declara um novo (sub)menu. Se um menu com o ID fornecido (veja abaixo) já existir, os dois menus serão mesclados. O elemento &lt;menu&gt; pode ser um filho direto do elemento &lt;hierarchy&gt; (menu de nível superior) ou um filho direto de qualquer outro elemento &lt;menu&gt; (submenu). Por outro lado, o elemento &lt;menu&gt; aceita outros elementos &lt;menu&gt; ou &lt;entry&gt; como filhos. Atributos: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Uma string identificadora do menu. Útil quando as definições de menu são lidas de vários arquivos &pluginmap; para garantir que os plugins possam ser colocados no(s) mesmo(s) menu(s). Alguns IDs de menu, como "file", referem-se a menus predefinidos (neste caso, o menu "File"). Certifique-se de verificar os arquivos &pluginmap; existentes para usar IDs consistentes.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Uma legenda para o menu.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Permite controlar a ordem dos itens do menu. Consulte <link linkend="pluginmap_grouping"
>ordem dos itens do menu</link
>. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;entry&gt;</term>
<listitem
><para
>Uma entrada de menu, &ie;, uma opção de menu para invocar um plugin. Pode ser usado apenas como filho direto de um elemento &lt;menu&gt;, não aceitando elementos filhos. Atributos: <variablelist>
	<varlistentry>
	<term
>component</term>
	<listitem
><para
>O ID do componente que deve ser invocado quando esta entrada de menu for ativada.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Permite controlar a ordem dos itens do menu. Consulte <link linkend="pluginmap_grouping"
>ordem dos itens do menu</link
>. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;group&gt;</term>
<listitem
><para
>Declara um grupo de itens no menu. Consulte <link linkend="pluginmap_grouping"
>ordenação de itens do menu</link
>. Atributos: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>O nome deste grupo.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>separated</term>
	<listitem
><para
>Opcional. Se definido como "verdadeiro", o item neste grupo será visualmente separado dos itens ao redor.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Nome do grupo ao qual este grupo será adicionado (opcional).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;context&gt;</term>
<listitem
><para
>Declara as entradas em um <link linkend="contextualized_plugins"
>contexto</link
>. Permitido apenas como filho direto da tag &lt;document&gt;. Aceita apenas tags &lt;menu&gt; como filhos diretos. Atributos: <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>O ID do contexto. Até o momento, apenas dois contextos foram implementados: "x11" e "import".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;require&gt;</term>
<listitem
><para
>Inclui outro arquivo &pluginmap;. Este arquivo &pluginmap; é carregado apenas uma vez, mesmo que seja &lt;require&gt; de vários outros arquivos. O caso de uso mais importante é incluir um arquivo pluginmap, que declara alguns componentes, que são incorporados por componentes declarados neste &pluginmap;. Elementos &lt;require&gt; são permitidos apenas como filhos diretos do nó &lt;document&gt;. Atributos: <variablelist>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>O nome do arquivo do &pluginmap; a ser incluído. Isso é visto em relação ao diretório do arquivo &pluginmap; atual + o prefixo base (veja acima, elemento &lt;document&gt;). Se você não souber o caminho relativo para o &pluginmap; a ser incluído, use o atributo <parameter
>map</parameter
> para referenciá-lo pelo id.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>map</term>
	<listitem
><para
>Para incluir um arquivo &pluginmap; de um pacote diferente (ou um &pluginmap; do &rkward; de seu &pluginmap; externo), você pode se referir a ele pelo seu<replaceable
>namespacename::id</replaceable
>, conforme especificado no elemento&lt;document&gt; do &pluginmap; obrigatório. A inclusão falhará se nenhum &pluginmap; com esse id for conhecido (por exemplo, não estiver instalado no sistema do usuário). Você deve usar este método apenas para incluir &pluginmap;s fora do seu pacote. Para mapas dentro do seu pacote, especificar um caminho relativo (atributo <parameter
>file</parameter
>) é mais rápido e confiável. </para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="helpfileelements"
><title
>Elementos para uso em arquivos .rkh (ajuda)</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Precisa estar presente em cada arquivo <literal role="extension"
>.xml</literal
> como nó raiz (exatamente uma vez). Sem atributos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;title&gt;</term>
<listitem
><para
>Título da página de ajuda. Isto <emphasis
>não</emphasis
> é interpretado para páginas de ajuda de um plugin (este título é obtido do próprio plugin), apenas para páginas independentes. Sem atributos. O texto contido na tag &lt;title&gt; se tornará a legenda da página de ajuda. Pode ser definido apenas uma vez, como filho direto do nó &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;summary&gt;</term>
<listitem
><para
>Um breve resumo da página de ajuda (ou para que serve este plugin). Este será sempre exibido no topo da página de ajuda. Sem atributos. O texto contido na tag &lt;summary&gt; será exibido. Recomendado, mas não obrigatório. Pode ser definido apenas uma vez, como filho direto do nó &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;usage&gt;</term>
<listitem
><para
>Um resumo um pouco mais detalhado do uso. Este será sempre exibido diretamente após o &lt;summary&gt;. Sem atributos. O texto contido na tag &lt;usage&gt; será exibido. Recomendado para páginas de ajuda de plugins, mas não obrigatório. Pode ser definido apenas uma vez, como filho direto do nó &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;section&gt;</term>
<listitem
><para
>Uma seção de uso geral. Pode ser usada qualquer número de vezes como um filho direto do nó &lt;document&gt;. Essas seções são exibidas na ordem de sua definição, mas todas <emphasis
>após</emphasis
> a seção &lt;usage&gt; e <emphasis
>antes</emphasis
> a seção &lt;settings&gt;. O texto contido na tag &lt;section&gt; será exibido. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Um identificador necessário para acessar esta seção a partir da barra de navegação (ou um link). Precisa ser único dentro do arquivo. Obrigatório, sem valor padrão.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Título (legenda) desta seção. Obrigatório, sem valor padrão.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>short_title</term>
	<listitem
><para
>Um título curto adequado para ser exibido na barra de navegação. Opcional, o padrão é o título completo.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;settings&gt;</term>
<listitem
><para
>Define a seção que contém referências às várias configurações da &GUI;. Somente significativo e usado apenas para páginas de ajuda relacionadas a plugins. Use como um filho direto do &lt;document&gt;. Pode conter apenas elementos &lt;settings&gt; e &lt;caption&gt; como filhos diretos. Sem atributos.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;setting&gt;</term>
<listitem
><para
>Explica uma única configuração na &GUI;. Permitido apenas como filho direto do elemento &lt;settings&gt;. O texto contido no elemento é exibido. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>O ID da configuração no plugin <literal role="extension"
>.xml</literal
>. Obrigatório, sem valor padrão.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Um título opcional para a configuração. Se omitido (a omissão é recomendada na maioria dos casos), o título será obtido do plugin <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;caption&gt;</term>
<listitem
><para
>Uma legenda para agrupar visualmente várias configurações. Só pode ser usada como um elemento filho direto do elemento &lt;settings&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>O ID do elemento correspondente (normalmente um &lt;frame&gt;, &lt;page&gt; ou &lt;tab&gt;) no plugin <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Um título opcional para a legenda. Se omitido (a omissão é recomendada na maioria dos casos), o título será retirado do plugin <literal role="extension"
>.xml</literal
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;related&gt;</term>
<listitem
><para
>Define uma seção contendo links para informações adicionais relacionadas. Será sempre exibida após a seção &lt;settings&gt;. Sem atributos. O texto contido na tag &lt;related&gt; será exibido. Normalmente, isso conterá uma lista no estilo &HTML;. Recomendado para páginas de ajuda de plugins, mas não obrigatório. Pode ser definido apenas uma vez, como filho direto do nó &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;technical&gt;</term>
<listitem
><para
>Define uma seção contendo informações técnicas irrelevantes para os usuários finais (como a estrutura interna do plugin). Será sempre exibida por último em uma página de ajuda. Sem atributos. O texto contido na tag &lt;related&gt; será exibido. Não é obrigatório e não é recomendado para a maioria das páginas de ajuda de plugins. Pode ser definido apenas uma vez, como filho direto do nó &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;link&gt;</term>
<listitem
><para
>Um link. Pode ser usado em qualquer uma das seções descritas acima. <variablelist
> <varlistentry>
	<term
>href</term>
	<listitem
><para
>O destino &URL;. Observe que vários &URL;s específicos para &rkward; estão disponíveis. Consulte a seção <link linkend="pluginhelp"
>sobre como escrever páginas de ajuda</link
> para obter detalhes.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;label&gt;</term>
<listitem
><para
>Insere o valor de um rótulo da interface do usuário. Pode ser usado em qualquer uma das seções descritas acima. <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>O ID do elemento no plugin, do qual copiar o atributo <replaceable
>label</replaceable
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;várias tags &HTML;&gt;</term>
<listitem
><para
>A maioria das tags &HTML; básicas são permitidas dentro das seções. No entanto, por favor, mantenha a formatação manual ao mínimo.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="guilogic_functions"
><title
>Funções disponíveis para scripts de lógica de &GUI;</title>
<variablelist>
<varlistentry
><term
>Classe "Component"</term>
<listitem
><para
>Classe que representa um único componente ou propriedade de componente. A instância mais importante desta classe é a variável "gui", que é predefinida como a propriedade raiz do componente atual. Os seguintes métodos estão disponíveis para instâncias da classe "Component": <variablelist>
	<varlistentry
><term
>absoluteId(base_id)</term
><listitem
><para
>Retorna o ID absoluto de <emphasis
>base_id</emphasis
>, ou - se base_id for omitido - o identificador do componente.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getValue(id)</term
><listitem
><para
>Desaconselhado. Use <function
>getString(), getBoolean() ou getList()</function
> em vez disso. Retorna o valor da propriedade filha fornecida. Retorna o valor desta propriedade, se o ID for omitido.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getString(id)</term
><listitem
><para
>Retorna o valor da propriedade filha fornecida como uma string. Retorna o valor desta propriedade, se o ID for omitido.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getBoolean(id)</term
><listitem
><para
>Retorna o valor da propriedade filha fornecida como um booleano (se possível). Retorna o valor desta propriedade, caso o ID seja omitido.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getList(id)</term
><listitem
><para
>Retorna o valor da propriedade filha fornecida como uma matriz de strings (se possível). Retorna o valor desta propriedade, se o ID for omitido.</para
></listitem
></varlistentry>
	<varlistentry
><term
>setValue(id, valor)</term
><listitem
><para
>Defina o valor da propriedade filha fornecida como <emphasis
>valor</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getChild(id)</term
><listitem
><para
>Retorna uma instância da propriedade filha com o <emphasis
>id</emphasis
> fornecido.</para
></listitem
></varlistentry>
	<varlistentry
><term
>addChangeCommand(id, comando)</term
><listitem
><para
>Execute o comando <replaceable
>comando</replaceable
> sempre que a propriedade filha fornecida por <emphasis
>id</emphasis
> for alterada. <replaceable
>id</replaceable
> pode ser fornecido como uma única string ou como um array de IDs (se a função for chamada para alterações em várias propriedades). <replaceable
>comando</replaceable
> é um valor chamável (geralmente uma função), porém, para compatibilidade com plugins escritos para versões anteriores do RKWard, também pode ser fornecido como uma string para ser avaliada.</para>
	<para
>A função retorna o parâmetro <replaceable
>comando</replaceable
>, para conveniência (para que você possa, por exemplo, atribuí-lo a uma variável e/ou chamá-lo durante a inicialização).</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Classe "RObject"</term>
<listitem
><para
>Classe que representa um único objeto &R;. Uma instância desta classe pode ser obtida usando o comando <command
>makeRObject(nome_do_objeto)</command
>. Os seguintes métodos estão disponíveis para instâncias da classe "RObject": <warning
><para
>Se ainda houver comandos pendentes no servidor, as informações fornecidas por esses métodos podem estar desatualizadas no momento da execução do código do plugin. <emphasis
>Não</emphasis
> confie nelas para operações críticas (correndo o risco de perda de dados).</para
></warning>
	<variablelist>
	<varlistentry
><term
>getName()</term
><listitem
><para
>Retorna o nome absoluto do objeto.</para
></listitem
></varlistentry>
	<varlistentry
><term
>exists()</term
><listitem
><para
>Retorna se o objeto existe. Geralmente, você deve verificar isso antes de usar qualquer um dos métodos listados abaixo.</para
></listitem
></varlistentry>
	<varlistentry
><term
>dimensions()</term
><listitem
><para
>Retorna uma matriz de dimensões (semelhante a <command
>dim()</command
> em R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>classes()</term
><listitem
><para
>Retorna uma matriz de classes (semelhante a <command
>class()</command
> em R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>isClass(classe)</term
><listitem
><para
>Retorna verdadeiro se o objeto for da classe <emphasis
>classe</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFrame()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um data.frame.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isMatrix()</term
><listitem
><para
>Retorna verdadeiro se o objeto for uma matriz.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isList()</term
><listitem
><para
>Retorna verdadeiro se o objeto for uma lista.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isFunction()</term
><listitem
><para
>Retorna verdadeiro se o objeto for uma função.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isEnvironment()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um ambiente.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataNumeric()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um vetor de dados numéricos.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFactor()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um vetor de dados fatoriais.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataCharacter()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um vetor de dados de caracteres.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataLogical()</term
><listitem
><para
>Retorna verdadeiro se o objeto for um vetor de dados lógicos.</para
></listitem
></varlistentry>
	<varlistentry
><term
>parent()</term
><listitem
><para
>Retorna uma instância de "RObject" representando o objeto pai deste objeto.</para
></listitem
></varlistentry>
	<varlistentry
><term
>child(nomefilho)</term
><listitem
><para
>Retorna uma instância de "RObject" representando o filho <emphasis
>nomefilho</emphasis
> deste objeto.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Classe "RObjectArray"</term>
<listitem
><para
>Uma matriz de instâncias de RObject. Uma instância desta classe pode ser obtida usando o comando <command
>makeRObjectArray(nomesobjetos)</command
>. É particularmente útil ao lidar com `varslots`, que permitem selecionar vários objetos.</para
></listitem>
</varlistentry>
<varlistentry
><term
>Função include()</term>
<listitem
><para
>O comando <command
>include(filename)</command
> pode ser usado para incluir um arquivo JS separado.</para
></listitem>
</varlistentry>
<varlistentry
><term
>Função doRCommand()</term>
<listitem
><para
><emphasis
>Obsoleto. Não use em novos plugins:</emphasis
> <command
>doRCommand(comando, callback)</command
>. Use <command
>new RCommand()</command
> em vez disso.</para
></listitem>
</varlistentry>
<varlistentry
><term
>Função new RCommand()</term>
<listitem
><para
><command
>new RCommand(comando, id_opcional)</command
> pode ser usado para consultar o &R; para obter informações. Leia a seção sobre <link linkend="querying_r_for_info"
>consultando o &R; de dentro de um plugin</link
> para obter detalhes e ressalvas.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

</appendix>

<appendix id="troubleshooting">
<title
>Solução de problemas durante o desenvolvimento de plugins</title>
<para
>Então você leu toda a documentação, fez tudo certo e ainda assim não consegue fazer o plugin funcionar? Não se preocupe, vamos resolver isso. A primeira coisa a fazer é: ativar a janela <guilabel
>Mensagens de depuração do &rkward;</guilabel
> (disponível no menu <guimenu
>Janelas</guimenu
> ou clicando com o botão direito em uma das barras de ferramentas) e, em seguida, iniciar seu plugin novamente. Como regra geral, você não deve ver nenhuma saída na janela de mensagens quando seu plugin for invocado ou em qualquer outro momento. Se houver alguma, provavelmente está relacionada ao seu plugin. Veja se isso ajuda. </para>
<para
>Se tudo parecer normal no console, tente aumentar o nível de depuração (na linha de comando, usando <command
>rkward --debug-level 3</command
> ou definindo o nível de depuração para 3 em <menuchoice
><guimenu
>Configurações</guimenu
> <guimenuitem
>Configurar &rkward;</guimenuitem
><guimenuitem
>Depurar</guimenuitem
></menuchoice
>). Nem todas as mensagens exibidas em níveis de depuração mais altos indicam necessariamente um problema, mas é provável que o seu problema apareça em algum lugar entre as mensagens. </para>
<para
>Se você ainda não conseguiu descobrir o que está errado, não se desespere. Sabemos que isso é complicado e, afinal, talvez você também tenha se deparado com um bug no &rkward; que precisa ser corrigido. Basta escrever para a lista de discussão de desenvolvimento e nos contar sobre o problema. Ficaremos felizes em ajudar. </para>
<para
>Por fim, mesmo que você tenha descoberto como fazer por conta própria, mas achou a documentação pouco útil ou até mesmo incorreta em alguns aspectos, por favor, nos informe também na lista de discussão, para que possamos corrigir/melhorar a documentação. </para>
</appendix>

<appendix id="license">
<title
>Licença</title>
<para
>Tradução de Marcus Gama <email
>marcus.gama@kde.org</email
></para
> 
&underFDL;
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
