<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.5-Based Variant V1.1//EN" "dtd/kdedbx45.dtd" [
  <!ENTITY rkward '<application
>RKWard</application
>'>
  <!ENTITY R '<application
>R</application
>'>
  <!ENTITY javascript 'JavaScript'>
  <!ENTITY pluginmap '<literal role="extension"
>.pluginmap</literal
>'>
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % Catalan  "INCLUDE"
><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!--- This file is part of the RKWard project (https://rkward.kde.org).
SPDX-FileCopyrightText: by Thomas Friedrichsmeier <thomas.friedrichsmeier@kdemail.net>
SPDX-FileCopyrightText: by Meik Michalke <meik.michalke@hhu.de>
SPDX-FileContributor: The RKWard Team <rkward-devel@kde.org>
SPDX-License-Identifier: GFDL-1.2-no-invariants-or-later OR GPL-2.0-or-later
-->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title
>Introducció a l'escriptura de connectors per al &rkward;</title>

<authorgroup>
<author
><firstname
>Thomas</firstname
> <surname
>Friedrichsmeier</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>

<author
><firstname
>Meik</firstname
> <surname
>Michalke</surname
> <affiliation
> <address
><email
>rkward-devel AT kde DOT org</email
></address>
</affiliation>
</author>
<!-- Additional authors go here -->

&traductor.JosepMa.Ferrer; 
</authorgroup>



<copyright>
<year
>2006-2022</year>
<holder
>Thomas Friedrichsmeier</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook 
     and in the FDL itself on how to use it. -->
<legalnotice
>&FDLNotice;</legalnotice>

<date
>24 d'abril de 2022</date>
<releaseinfo
>0.7.4</releaseinfo>

<abstract>
<para
>Aquesta és una guia a l'escriptura de connectors per al &rkward;. </para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>R</keyword>
<keyword
>rkward</keyword>
<keyword
>connectors</keyword>
</keywordset>

</bookinfo>

<chapter id="introduction">
<title
>Introducció</title>

	<para
>Aquest document descriu com escriure els vostres propis connectors. La documentació ha crescut força amb el temps. No deixeu que això us espanti. Recomanem llegir els quatre passos bàsics (en termes generals, a continuació), per a obtenir una idea bàsica de com funcionen les coses. Després d'això, és possible que vulgueu fullejar la taula de continguts per a veure quins temes avançats podrien ser rellevants per a vós. </para>
	<para
>Per a preguntes i comentaris, escriviu a la llista de correu de desenvolupament del &rkward;. </para>
	<para
><emphasis
>No cal que ho llegiu per a utilitzar el &rkward;.</emphasis
> Aquest document tracta sobre l'ampliació del &rkward;. Està dirigit a usuaris avançats, o persones disposades a ajudar a millorar el &rkward;. </para>
	<para
>Escriure un connector estàndard és bàsicament un procés de quatre passos: </para>
		<itemizedlist>
			<listitem
><para
><link linkend="pluginmap"
>Col·locar una acció nova a la jerarquia del menú</link
></para
></listitem>
			<listitem
><para
><link linkend="mainxml"
>Descriure l'aparença i el comportament de la &IGU; del connector</link
></para
></listitem>
			<listitem
><para
><link linkend="jstemplate"
>Definir com s'ha de generar el codi R a partir de la configuració que l'usuari fa a la &IGU;</link
></para
></listitem>
			<listitem
><para
><link linkend="pluginhelp"
>Afegir una pàgina d'ajuda al vostre connector</link
></para
></listitem>
		</itemizedlist>
	<para
>Aquests es tractaran per ordre. </para>
	<para
>Es poden utilitzar alguns conceptes avançats en aquests quatre passos, però es tracten en capítols separats, per a mantenir les coses senzilles: <itemizedlist>
			<listitem
><para
><link linkend="logic"
>Lògica de la &IGU;</link
></para
></listitem>
			<listitem
><para
><link linkend="embedding"
>Incrustar connectors en connectors</link
></para
></listitem>
			<listitem
><para
><link linkend="plugin_series"
>Conceptes útils per a crear moltes sèries de connectors similars</link
></para
></listitem>
		</itemizedlist>
	</para>
	<para
>A més, cap dels capítols mostra totes les opcions, sinó només els conceptes bàsics. Es proporciona per separat una <link linkend="reference"
>referència</link
> completa d'opcions. </para>
</chapter>

<chapter id="whatareplugins">
<title
>Preliminars: Què són els connectors en el &rkward;? Com funcionen?</title>
	<para
>Per descomptat, la primera pregunta que us podríeu fer és: quines parts de la funcionalitat del &rkward; s'han realitzat utilitzant connectors? O: què poden fer els connectors? </para>
	<para
>Una manera de respondre-ho és: desseleccionar tots els fitxers del &pluginmap; de l'<menuchoice
><guimenu
>Arranjament</guimenu
><guimenuitem
>Configura el &rkward;</guimenuitem
><guimenuitem
>Connectors</guimenuitem
></menuchoice
>, i veure què falta. Una resposta una mica més útil: la majoria de les funcions estadístiques reals accessibles a través de la &IGU; es realitzen utilitzant connectors. També podeu crear &IGU; bastant flexibles per a tota mena d'operacions utilitzant connectors. </para>
	<para
>El paradigma bàsic darrere dels connectors del &rkward; és el que us ensenyarem en aquest document: un fitxer &XML; descriu com es veu la &IGU;. S'utilitza un fitxer &javascript; addicional per a generar la sintaxi de l'&R; des de la configuració de la &IGU;. És a dir, els connectors no han de realitzar cap càlcul estadístic. Els connectors generen la sintaxi de l'&R; necessària per a executar aquests càlculs. La sintaxi de l'&R; s'envia al dorsal de l'&R; per a l'avaluació, i normalment es mostra un resultat a la finestra de sortida. </para>
	<para
>Llegiu en els capítols següents per a veure com es fa això. </para>
</chapter>

<chapter id="pluginmap">
<title
>Creació d'entrades del menú</title>
	<para
>Quan creeu un connector nou, haureu de dir-li-ho al &rkward;. Per tant, el primer que cal fer és escriure un fitxer &pluginmap; (o modificar-ne un d'existent). El format del &pluginmap; és &XML;. Us ensenyaré un exemple (també, per descomptat, assegureu-vos que el &rkward; està configurat per a carregar el &pluginmap;: <menuchoice
><guimenu
>Arranjament</guimenu
><guimenuitem
>Configura el &rkward;</guimenuitem
><guimenuitem
>Connectors</guimenuitem
></menuchoice
>): </para>
	<tip>
		<para
>Després de llegir aquest capítol, mireu també el <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>. Proporciona algunes funcions de l'&R; per a crear la majoria de les etiquetes &XML; del &rkward;. </para>
	</tip>
	<programlisting
>&lt;!DOCTYPE rkpluginmap&gt;
        </programlisting>
	<para
>El «doctype» no s'interpreta realment, però de totes maneres es defineix com a <replaceable
>"rkpluginmap"</replaceable
>. </para>
	<programlisting
>&lt;document base_prefix="" namespace="myplugins" id="mypluginmap"&gt;
        </programlisting>
	<para
>Es pot utilitzar l'atribut <parameter
>base_prefix</parameter
>, si tots els connectors resideixen en un directori comú. Bàsicament, aleshores podeu ometre aquest directori dels noms de fitxers especificats a continuació. És segur deixar això com a <replaceable
>""</replaceable
>. </para
><para
>Com podeu veure a continuació, tots els connectors tenen un identificador únic, <parameter
>id</parameter
>. El <parameter
>namespace</parameter
> és una manera d'organitzar aquests ID, i fer que sigui menys probable crear accidentalment un identificador duplicat. Internament, s'anteposa l'espai de noms i després un «::» a tots els identificadors que especifiqueu en aquest &pluginmap;. En general, si teniu la intenció de <link linkend="sect_external_plugins"
>distribuir els connectors en un paquet &R;</link
>, és una bona idea utilitzar el nom del paquet com a paràmetre <parameter
>namespace</parameter
>. Els connectors enviats amb la distribució oficial del &rkward; tenen el <replaceable
>namespace="rkward"</replaceable
>. </para>
	<para
>L'atribut <parameter
>id</parameter
> és opcional, però especificar un identificador per al vostre &pluginmap; fa possible que altres persones facin que el seu &pluginmap; carreguin automàticament el vostre &pluginmap; (vegeu <link linkend="chapter_dependencies"
>la secció sobre dependències</link
>). </para>
	<programlisting
>&lt;components&gt;
        </programlisting>
	<para
>Components? No estem parlant de connectors? Sí, però en el futur, els connectors no seran més que una classe especial de components. El que fem aquí, és registrar tots els components/connectors en el &rkward;. Vegem una entrada d'exemple: </para>
	<programlisting
>&lt;component type="standard" id="t_test_two_vars" file="t_test_two_vars.xml" label="Two Variable t-Test" /&gt;
        </programlisting>
	<para
>Primer l'atribut <parameter
>type</parameter
>: deixeu-ho com a <replaceable
>"standard"</replaceable
> per ara. Encara no s'han implementat altres tipus. L'<parameter
>id</parameter
> que ja hem indicat. A cada component se li ha de donar un identificador únic (en el seu espai de noms). Trieu-ne un que sigui fàcilment reconeixible. Eviteu espais i qualsevol caràcter especial. Fins ara no estan prohibits, però podrien tenir significats especials. Amb l'atribut <parameter
>file</parameter
>, especifiqueu on es troba la <link linkend="mainxml"
>descripció del connector real</link
>. Això és relatiu al directori on es troba el fitxer &pluginmap;, i el <parameter
>base_prefix</parameter
> anterior. Finalment, doneu una etiqueta al component. Aquesta etiqueta es mostrarà on es col·loqui el connector al menú (o en el futur potser també en altres llocs). </para>
	<para
>Normalment, un fitxer de &pluginmap; contindrà diversos components, de manera que aquí en trobareu alguns més: </para>
	<programlisting
>&lt;component type="standard" id="unimplemented_test" file="means/unimplemented.xml" /&gt;
                &lt;component type="standard" id="fictional_t_test" file="means/ttests/fictional.xml" label="This is a fictional t-test" /&gt;
                &lt;component type="standard" id="descriptive" file="descriptive.xml" label="Descriptive Statistics" /&gt;
                &lt;component type="standard" id="corr_matrix" file="corr_matrix.xml" label="Correlation Matrix" /&gt;
                &lt;component type="standard" id="simple_anova" file="simple_anova.xml" label="Simple Anova" /&gt;
        &lt;/components&gt;
        </programlisting>
	<para
>D'acord, aquest ha estat el primer pas. Ara el &rkward; coneix que aquests connectors existeixen. Però com invocar-los? S'han de col·locar en una jerarquia de menús: </para>
	<programlisting
>&lt;hierarchy&gt;
                &lt;menu id="analysis" label="Analysis"&gt;
        </programlisting>
	<para
>Just a sota de l'etiqueta <command
>&lt;hierarchy&gt;</command
>, comenceu a descriure, en quin <command
>&lt;menu&gt;</command
> haurien d'anar els vostres connectors. Amb la línia anterior, bàsicament dieu que el vostre connector hauria d'estar en el menú <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> (no necessàriament directament allà, sinó en un submenú). El menú <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
> és estàndard en el &rkward;, de manera que en realitat no s'ha de crear des de zero. Tanmateix, si encara no existís, utilitzant l'atribut <parameter
>label</parameter
> li donaríeu el seu nom. Finalment, l'<parameter
>id</parameter
> identifica de nou aquest <command
>&lt;menu&gt;</command
>. Això és necessari, de manera que diversos fitxers del &pluginmap; poden col·locar els seus connectors en els mateixos menús. Ho fan buscant un <command
>&lt;menu&gt;</command
> amb l'<parameter
>id</parameter
> donat. Si l'ID encara no existeix, es crearà un menú nou. En cas contrari, les entrades s'afegiran al menú existent. </para>
	<programlisting
>&lt;menu id="means" label="Means"&gt;
        </programlisting>
	<para
>Bàsicament, aquí és el mateix: ara definim un submenú al menú <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Es diu <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>). </para>
	<programlisting
>&lt;menu id="ttests" label="t-Tests"&gt;
        </programlisting>
	<para
>I un nivell final en la jerarquia del menú: un submenú del submenú <menuchoice
><guimenuitem
>Means</guimenuitem
></menuchoice
>. </para>
	<programlisting
>&lt;entry component="t_test_two_vars" /&gt;
        </programlisting>
	<para
>Ara, finalment, aquest és el menú en què volem col·locar el connector. L'etiqueta <command
>&lt;entry&gt;</command
> indica que aquesta és realment la cosa real, en lloc d'un altre submenú. L'atribut <parameter
>component</parameter
> es refereix a l'<parameter
>id</parameter
> que heu donat al connector/component anterior. </para>
	<programlisting
>&lt;entry component="fictional_t_test" /&gt;
                                &lt;/menu&gt;
                                &lt;entry component="fictional_t_test" /&gt;
                        &lt;/menu&gt;
                        &lt;menu id="frequency" label="Frequency" index="2"/&gt;
        </programlisting>
	<para
>En el cas que us hàgiu perdut: aquest és un altre submenú al menú <menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. Vegeu la captura de pantalla següent. S'ometran algunes de les coses que no són visibles, marcades amb [...]. </para>
	<programlisting
>[...]
                        &lt;/menu&gt;
                        &lt;entry component="corr_matrix"/&gt;
                        &lt;entry component="descriptive"/&gt;
                        &lt;entry component="simple_anova"/&gt;
                &lt;/menu&gt;
        </programlisting>
	<para
>Aquestes són les entrades finals visibles en les captures de pantalla de sota. </para>
	<programlisting
>&lt;menu id="plots" label="Plots"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Per descomptat, també podeu col·locar els vostres connectors en menús diferents d'<menuchoice
><guimenu
>Analysis</guimenu
></menuchoice
>. </para>
	<programlisting
>&lt;menu id="file" label="File"&gt;
                        [...]
                &lt;/menu&gt;
        </programlisting>
	<para
>Fins i tot en menús estàndard com <menuchoice
><guimenu
>Fitxer</guimenu
></menuchoice
>. Tot el que necessiteu és l'<parameter
>id</parameter
> correcte. </para>
	<programlisting
>&lt;/hierarchy&gt;        
&lt;/document&gt;
        </programlisting>
	<para
>Així és com es fa. I aquesta captura de pantalla mostra el resultat: </para>
	<screenshot>
	<screeninfo
>Jerarquia de menú creada pel codi mostrat anteriorment</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="menu_hierarchy_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Jerarquia de menú creada pel codi mostrat anteriorment</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>És confús? La manera més fàcil d'iniciar-se és probablement prenent alguns dels fitxers existents del &pluginmap; enviats amb la distribució, i modificant-los segons les vostres necessitats. A més, si necessiteu ajuda, no dubteu a escriure a la llista de correu de desenvolupament. </para>
	<sect1 id="pluginmap_grouping"
><title
>Control de l'ordre de les entrades del menú</title>
		<para
>De manera predeterminada, tots els elements (entrades/submenús) dins d'un menú s'ordenaran alfabèticament, automàticament. En <emphasis
>alguns</emphasis
> casos, és possible que vulgueu més control. En aquest cas podeu agrupar elements de la manera següent:</para>
		<itemizedlist>
			<listitem>
				<para
>Podeu definir grups dins de qualsevol menú com aquest. Tots els elements que pertanyin al mateix grup s'agruparan junts:</para>
				<programlisting
>&lt;group id="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
			<para
>Si voleu que el grup estigui visualment separat d'altres entrades, utilitzeu:</para>
				<programlisting
>&lt;group id="somegroup" separated="true"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Les entrades, menús i grups es poden afegir a un grup especificat, utilitzant:</para>
				<programlisting
>&lt;entry component="..." group="somegroup"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>De fet, també és possible definir grups (sense línies de separació) implícitament:</para>
				<programlisting
>&lt;entry component="first" group="a"/&gt;
                &lt;entry component="third"/&gt;
                &lt;entry component="second" group="a"/&gt;
                                </programlisting>
			</listitem
><listitem>
				<para
>Els noms dels grups són específics de cada menú. El grup «a» al menú «Data» no entra en conflicte amb el grup «a» del menú «Analysis», per exemple.</para>
			</listitem
><listitem>
				<para
>El cas d'ús més comú és definir grups a la part superior, o a la part inferior d'un menú. Per això, hi ha grups predefinits "top" i "bottom" a cada menú.</para>
			</listitem
><listitem>
				<para
>Les entrades dins de cada grup estan ordenades alfabèticament. Els grups apareixen en l'ordre de declaració (llevat que s'afegeixi a un altre grup, per descomptat).</para>
			</listitem
><listitem>
				<para
>Els menús i les entrades sense especificació de grup formen lògicament un grup ("").</para>
			</listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="mainxml">
<title
>Definir la &IGU;</title>
<sect1 id="sect_defining_the_GUI"
><title
>Definir un diàleg</title>
	<para
>En el <link linkend="pluginmap"
>capítol anterior</link
> heu vist com registrar un connector amb el &rkward;. L'ingredient més important era especificar el camí a un fitxer &XML; amb una descripció de l'aspecte real del connector. En aquest capítol aprendreu a crear aquest fitxer &XML;. </para>
	<tip>
		<para
>Després de llegir aquest capítol, mireu també el <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>. Proporciona algunes funcions de l'&R; per a crear la majoria de les etiquetes &XML; del &rkward;. </para>
	</tip>
	<para
>Una vegada més, us ensenyarem amb un exemple. L'exemple és una versió (lleugerament simplificada) de la «prova t» de dues variables. </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
        </programlisting>
	<para
>El «doctype» realment encara no s'interpreta. Poseu-lo a <replaceable
>rkplugin</replaceable
>, de totes maneres. </para>
	<programlisting
>&lt;document&gt;
        &lt;code file="t_test_two_vars.js"/&gt;
        </programlisting>
	<para
>Tots els connectors generen codi. Actualment, l'única manera de fer-ho és utilitzant JS tal com es detalla <link linkend="jstemplate"
>al capítol següent</link
>. Això defineix on cercar el codi JS. El nom del fitxer és relatiu al directori on es troba el connector &XML;. </para>
	<programlisting
>&lt;help file="t_test_two_vars.rkh"/&gt;
        </programlisting>
	<para
>Normalment, és una bona idea proporcionar també una pàgina d'ajuda per al vostre connector. El nom del fitxer d'aquesta pàgina d'ajuda es dona, aquí, en relació amb el directori, a on està l'&XML; del connector. L'escriptura de pàgines d'ajuda està documentada <link linkend="pluginhelp"
>aquí</link
>. Si no proporcioneu un fitxer d'ajuda, ometeu aquesta línia. </para>
	<programlisting
>&lt;dialog label="Two Variable t-Test"&gt;
        </programlisting>
	<para
>Com ja sabeu, els connectors poden tenir un diàleg o una interfície assistent o ambdós. Aquí comencem a definir una interfície de diàleg. L'atribut <parameter
>label</parameter
> especifica la llegenda del diàleg. </para>
	<programlisting
>&lt;tabbook&gt;
                        &lt;tab label="Basic settings"&gt;
        </programlisting>
	<para
>Els elements de la &IGU; es poden organitzar utilitzant un «tabbook». Aquí definim un «tabbook» com el primer element del diàleg. Utilitzeu <command
>&lt;tabbook&gt;</command
>[...]<command
>&lt;/tabbook&gt;</command
> per a definir el «tabbook» i després per a cada pàgina del «tabbook» utilitzeu <command
>&lt;tab&gt;</command
>[...]<command
>&lt;/tab&gt;</command
>. L'atribut <parameter
>label</parameter
> a l'element <command
>&lt;tab&gt;</command
> us permet especificar una llegenda per a aquesta pàgina del «tabbook». </para>
	<programlisting
>&lt;row id="main_settings_row"&gt;
        </programlisting>
	<para
>Les etiquetes <command
>&lt;row&gt;</command
> i <command
>&lt;column&gt;</command
> especifiquen la disposició dels elements de la &IGU;. Aquí diu que vol col·locar alguns elements un al costat de l'altre (d'esquerra a dreta). L'atribut <parameter
>id</parameter
> no és estrictament necessari, però l'utilitzarem més endavant, quan afegiu una interfície assistent al nostre connector. El primer element a col·locar a la fila és: </para>
	<programlisting
>&lt;varselector id="vars"/&gt;
        </programlisting>
	<para
>Amb aquesta etiqueta simple creareu una llista des de la qual l'usuari podrà seleccionar variables. Heu d'especificar un <parameter
>id</parameter
> per a aquest element, de manera que el &rkward; sàpiga com trobar-lo. </para>
	<warning>
		<para
>NO podeu utilitzar un punt (.) a la cadena <parameter
>id</parameter
>. </para>
	</warning>
	<programlisting
>&lt;column&gt;
        </programlisting>
	<para
>A continuació, imbriquem un <command
>&lt;column&gt;</command
> dins la fila. Aquests són els elements següents que es col·locaran sobre dels altres (de dalt a baix), i tots estaran a la dreta del <command
>&lt;varselector&gt;</command
>. </para>
	<programlisting
>&lt;varslot types="number" id="x" source="vars" required="true" label="compare"/&gt;
                                                &lt;varslot types="number" id="y" source="vars" required="true" label="against" i18n_context="compare against"/&gt;
        </programlisting>
	<para
>Aquests elements són l'equivalent a <command
>&lt;varselector&gt;</command
>. Representen «ranures» en les quals l'usuari pot posar variables. Observeu que <parameter
>source</parameter
> s'estableix al mateix valor que la <parameter
>id</parameter
> de <command
>&lt;varselector&gt;</command
>. Això vol dir que els <command
>&lt;varslot&gt;</command
> prendran cadascuna de les seves variables del «varselector». També cal donar als <command
>&lt;varslot&gt;</command
> un <parameter
>id</parameter
>. Poden tenir una <parameter
>label</parameter
>, i es poden establir a <parameter
>required</parameter
>. Això vol dir que el botó <guibutton
>Submit</guibutton
> no estarà habilitat fins que el <command
>&lt;varslot&gt;</command
> tingui un valor vàlid. Finalment, l'atribut <parameter
>type</parameter
> encara no s'ha interpretat, però s'utilitzarà per a tenir en compte que només es permeten els tipus correctes de variables a <command
>&lt;varslot&gt;</command
>. </para>
	<para
>En cas que us pregunteu sobre l'atribut <parameter
>i18n_context</parameter
>: aquest és per a proporcionar context per a ajudar a la traducció correcta de la paraula "against", utilitzada com a etiqueta de <command
>&lt;varslot&gt;</command
>, però no afecta directament la funcionalitat del connector. Més sobre això en <link linkend="i18n_general"
>un capítol separat</link
>. </para>
	<programlisting
>&lt;radio id="hypothesis" label="using test hypothesis"&gt;
                                                        &lt;option value="two.sided" label="Two-sided"/&gt;
                                                        &lt;option value="greater" label="First is greater"/&gt;
                                                        &lt;option value="less" label="Second is greater"/&gt;
                                                &lt;/radio&gt;
        </programlisting>
	<para
>Aquí, definiu un grup de botons exclusius <command
>&lt;radio&gt;</command
>. El grup té una <parameter
>label</parameter
> i un <parameter
>id</parameter
>. Cada <command
>&lt;option&gt;</command
> (botó) té una <parameter
>label</parameter
> i se li assigna un <parameter
>value</parameter
>. Aquest és el valor que l'element <command
>&lt;radio&gt;</command
> retornarà quan se seleccioni l'opció. </para>
	<programlisting
>&lt;/column&gt;
                                &lt;/row&gt;
                        &lt;/tab&gt;
        </programlisting>
	<para
>Cal tancar cada etiqueta. Hem posat tots els elements que volíem (els dos <command
>&lt;varslots&gt;</command
> i el <command
>&lt;radio&gt;</command
>) a la <command
>&lt;column&gt;</command
>). Posem tots els elements que volíem (el <command
>&lt;varselector&gt;</command
> i el <command
>&lt;column&gt;</command
> amb aquests elements) en la <command
>&lt;row&gt;</command
>. I hem posat tots els elements que volíem a la primera pàgina del <command
>&lt;tabbook&gt;</command
>. Encara no hem acabat de definir el <command
>&lt;tabbook&gt;</command
> (vindran més pàgines), i per descomptat hi ha més en el <command
>&lt;dialog&gt;</command
>, també. Però aquesta captura de pantalla és bàsicament el que hem fet fins ara: </para>
	<screenshot>
	<screeninfo
>Connector de la prova t</screeninfo>
		<mediaobject>
		<imageobject>
			<imagedata fileref="t_test_plugin_example.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase
>Connector de la prova t</phrase>
		</textobject>
		</mediaobject>
	</screenshot>
	<para
>Tingueu en compte que no s'han especificat els botons <guibutton
>Submit</guibutton
>, <guibutton
>Close</guibutton
>, &etc; o la vista de codi. Aquests elements es generen automàticament. Però, per descomptat, encara hem de definir la segona pàgina del <command
>&lt;tabbook&gt;</command
>: </para>
	<programlisting
>&lt;tab label="Options"&gt;
                                &lt;checkbox id="varequal" label="assume equal variances" value=", var.equal=TRUE"/&gt;
        </programlisting>
	<para
>De manera predeterminada els elements es col·locaran de dalt a baix com en una <command
>&lt;column&gt;</command
>. Com que això és el que volem aquí, no hem d'indicar explícitament una disposició <command
>&lt;row&gt;</command
> ni <command
>&lt;column&gt;</command
>. El primer element que definim és una casella de selecció. Igual que <command
>&lt;radio&gt;</command
><command
>&lt;option&gt;</command
>, la casella de selecció té una <parameter
>label</parameter
> i un <parameter
>value</parameter
>. El <parameter
>value</parameter
> és el que es retorna, si la casella de selecció està marcada. Per descomptat, la casella de selecció també necessita un <parameter
>id</parameter
>. </para>
	<programlisting
>&lt;frame label="Confidence Interval" id="frame_conf_int"&gt;
        </programlisting>
	<para
>Aquí hi ha un altre element de la disposició: per a indicar que els dos elements següents estan junts, dibuixem un <command
>&lt;frame&gt;</command
> (quadre). Aquest marc pot tenir una <parameter
>label</parameter
> (llegenda). Com que el marc només és un element de disposició passiva, no necessita un <parameter
>id</parameter
>, tot i que en definim un aquí, com que hi farem referència més tard, quan definim una interfície assistent addicional. </para>
	<programlisting
>&lt;checkbox id="confint" label="print confidence interval" value="1" checked="true"/&gt;
                                        &lt;spinbox type="real" id="conflevel" label="confidence level" min="0" max="1" initial="0.95"/&gt;
                                &lt;/frame&gt;
        </programlisting>
	<para
>Dins del <command
>&lt;frame&gt;</command
> col·loquem un altre <command
>&lt;checkbox&gt;</command
> (usant <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, senyalem que la casella de selecció s'ha de marcar de manera predeterminada), i un <command
>&lt;spinbox&gt;</command
>. El botó de selecció de valors permet a l'usuari seleccionar un valor entre <replaceable
>"min"</replaceable
> i <replaceable
>"max"</replaceable
> amb el valor per defecte/inicial <replaceable
>"0,95"</replaceable
>. Establir el <parameter
>type</parameter
> a <replaceable
>"real"</replaceable
> indica que s'accepten els nombres reals en lloc de <parameter
>type=</parameter
><replaceable
>"integer"</replaceable
> que només acceptaria enters. </para>
	<note
><para
>També és possible, i sovint preferible, fer que el <command
>&lt;frame&gt;</command
> es pugui marcar, en lloc d'afegir una <command
>&lt;checkbox&gt;</command
> a l'interior. Vegeu la referència per a més detalls. Això no es fa aquí, amb finalitats il·lustratives. </para
></note>
	<programlisting
>&lt;/tab&gt;
                &lt;/tabbook&gt;
        &lt;/dialog&gt;
        </programlisting>
	<para
>Això és tot en la segona pàgina del <command
>&lt;tabbook&gt;</command
>, totes les pàgines del <command
>&lt;tabbook&gt;</command
> i tots els elements en el <command
>&lt;dialog&gt;</command
>. Hem acabat de definir l'aspecte del diàleg. </para>
	<programlisting
>&lt;/document&gt;
        </programlisting>
	<para
>Finalment tanquem l'etiqueta <command
>&lt;document&gt;</command
>, i ja està. La &IGU; està definida. Ara podeu desar el fitxer. Però com es genera la sintaxi de l'&R; a partir de la configuració de la &IGU;? Ho tractarem en el <link linkend="jstemplate"
>capítol següent</link
>. En primer lloc, però, mirarem d'afegir una interfície assistent i algunes consideracions generals. </para>
</sect1>

<sect1 id="wizard_interface">
	<title
>Afegir una interfície assistent</title>
	<para
>En realitat no cal definir una interfície addicional <command
>&lt;wizard&gt;</command
>, però així és com es faria. Per a afegir una interfície assistent, afegiu una etiqueta <command
>&lt;wizard&gt;</command
> al mateix nivell que l'etiqueta <command
>&lt;dialog&gt;</command
>: </para>
	<programlisting
>&lt;wizard label="Two Variable t-Test"&gt;
                        &lt;page id="firstpage"&gt;
                                &lt;text&gt;As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater.&lt;/text&gt;
                                &lt;copy id="main_settings_row"/&gt;
                        &lt;/page&gt;
        </programlisting>
	<para
>Algunes d'aquestes coses s'expliquen per si mateixes: afegim una etiqueta <command
>&lt;wizard&gt;</command
> amb una <parameter
>label</parameter
> per a l'assistent. Com que un assistent pot contenir diverses pàgines que es mostren una després de l'altra, a continuació definim la primera nota <command
>&lt;page&gt;</command
>, i hi posem una nota explicativa <command
>&lt;text&gt;</command
>. Llavors utilitzem una etiqueta <command
>&lt;copy&gt;</command
>. El que fa això, és que realment ens estalvia haver de definir de nou el que ja escrivim per al <command
>&lt;dialog&gt;</command
>: l'etiqueta copy cerca una altra etiqueta amb el mateix <parameter
>id</parameter
> abans en l'&XML;. Això es defineix en la secció <command
>&lt;dialog&gt;</command
>, i és un <command
>&lt;row&gt;</command
> en el qual hi ha el <command
>&lt;varselector&gt;</command
>, <command
>&lt;varslots&gt;</command
> i el control <command
>&lt;radio&gt;</command
> de la «hipòtesi». Tot això es copia 1:1 i s'insereix just a l'element <command
>&lt;copy&gt;</command
>. </para>
	<para
>Ara la segona pàgina: </para>
	<programlisting
>&lt;page id="secondpage"&gt;
                                &lt;text&gt;Below are some advanced options. It is generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing "assume equal variances" may increase test-strength, however.&lt;/text&gt;
                                &lt;copy id="varequal"/&gt;
                                &lt;text&gt;Sometimes it is helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance).&lt;/text&gt;
                                &lt;copy id="frame_conf_int"/&gt;
                        &lt;/page&gt;
                &lt;/wizard&gt;
        </programlisting>
	<para
>Aquí ocorre el mateix. S'afegeixen alguns textos, i entre ells hi ha la <command
>&lt;copy&gt;</command
> d'altres seccions de la interfície de diàleg. </para>
	<para
>Per descomptat, podeu fer que la interfície de l'assistent sembli molt diferent del diàleg, i no utilitzar l'etiqueta <command
>&lt;copy&gt;</command
> en absolut. Assegureu-vos, però, d'assignar els elements corresponents el mateix <parameter
>id</parameter
> en ambdues interfícies. Això no només s'utilitza per a transferir la configuració des de la interfície de diàleg a la interfície assistent i al revés, quan l'usuari canvia d'interfície (això encara no succeeix a la versió actual del &rkward;), sinó que també simplifica l'escriptura de la plantilla de codi (vegeu a sota). </para>
</sect1>

<sect1 id="mainxmltips">
	<title
>Algunes consideracions sobre el disseny de la &IGU;</title>
	<para
>Aquesta secció conté algunes consideracions generals sobre quins elements de la &IGU; s'utilitzaran i a on. Si aquest és el primer intent de crear un connector, no dubteu a ometre aquesta secció, ja que no és rellevant per a aconseguir que una &IGU; bàsica funcioni. Torneu aquí, més tard, per a veure si podeu refinar la &IGU; del connector d'alguna manera o d'altra. </para>
	
	<sect2 id="radio_vs_checkbox_vs_dropdown">
		<title
>&lt;radio&gt;, &lt;checkbox&gt; i &lt;dropdown&gt;</title>
		<para
>Els tres elements <command
>&lt;radio&gt;</command
>, <command
>&lt;checkbox&gt;</command
>, <command
>&lt;dropdown&gt;</command
>, tots tenen una funció similar: per a seleccionar una de diverses opcions. Òbviament, una casella de selecció només permet triar entre dues opcions: marcada o no, de manera que no la podeu utilitzar si hi ha més de dues opcions per a triar. Però quan utilitzar quin dels elements? Algunes regles generals: </para>
		<para
>Si esteu creant un <command
>&lt;radio&gt;</command
> o <command
>&lt;dropdown&gt;</command
> amb només dues opcions, pregunteu-vos si la pregunta és essencialment un tipus de pregunta sí/no. Per exemple, una tria entre «ajusta els resultats» i «no ajusta els resultats», o entre «elimina els valors que manquen» i «mantén els valors que manquen». En aquest cas una <command
>&lt;checkbox&gt;</command
> és la millor opció: utilitza poc espai, tindrà menys paraules d'etiquetes i és més fàcil de llegir per l'usuari. Hi ha molt poques situacions en què hauríeu de triar un <command
>&lt;radio&gt;</command
> sobre una <command
>&lt;checkbox&gt;</command
> quan només hi ha dues opcions. Un exemple d'això podria ser: «Mètode de càlcul: 'pearson'/'spearman'». Aquí, podrien pensar-se més mètodes, i en realitat no formen un parell de contraris. </para>
		<para
>Triar entre <command
>&lt;radio&gt;</command
> i <command
>&lt;dropdown&gt;</command
> és principalment una qüestió d'espai. El <command
>&lt;dropdown&gt;</command
> té l'avantatge d'utilitzar poc espai, fins i tot si hi ha moltes opcions per a triar. D'altra banda, un <command
>&lt;radio&gt;</command
> té l'avantatge de fer visibles alhora totes les opcions possibles per a l'usuari, sense fer clic a la fletxa desplegable. Generalment, si hi ha sis o més opcions per a triar, és preferible un <command
>&lt;dropdown&gt;</command
>. Si hi ha cinc o menys opcions, un <command
>&lt;radio&gt;</command
> és la millor opció. </para>
	</sect2>
</sect1>
</chapter>

<chapter id="jstemplate">
<title
>Generació de codi &R; a partir de la configuració de la &IGU;</title>
<sect1 id="sect_generating_R_code"
><title
>Ús del &javascript; en els connectors del &rkward;</title>
	<para
>Ara tenim una &IGU; definida, però encara necessitem generar codi &R; a partir d'això. Per tant, necessitem un altre fitxer de text, <filename
>code.js</filename
>, ubicat al mateix directori que el <link linkend="mainxml"
><filename
>description.xml</filename
></link
>. Podeu estar o no familiaritzats amb el &javascript; (o, per a ser tècnicament precís: ECMA-script). La documentació sobre JS es pot trobar en abundància, tant en forma impresa, com a Internet (&pex;: <ulink url="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide"
>https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide</ulink
>). Però per a la majoria de les finalitats no necessitareu saber gaire sobre JS, ja que només utilitzarem algunes característiques molt bàsiques. </para>
	<tip>
		<para
>Després de llegir aquest capítol, també doneu un cop d'ull al <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>. Proporciona algunes funcions de l'&R; per a crear codi &javascript; utilitzat habitualment en el &rkward;. També pot detectar automàticament les variables utilitzades en un fitxer &XML; de connector i crear codi bàsic &javascript; a partir d'aquest per a començar. </para>
	</tip>
	<note>
		<para
>S'assumeix que els fitxers <literal role="extension"
>.js</literal
> del connector estan codificats en UTF-8. Assegureu-vos de comprovar la codificació de l'editor, si utilitzeu qualsevol caràcter no ASCII. </para>
	</note>
	<para
>Per a la prova t de dues variables, el fitxer <filename
>code.js</filename
> es mostra de la manera següent (amb comentaris entremig): </para>
	<sect2 id="sect_JS_preprocess"
><title
>preprocess()</title>
		<programlisting
>function preprocess () {
}
                </programlisting>
		<para
>El fitxer JS està organitzat en tres funcions separades: <function
>preprocess()</function
>, <function
>calculate()</function
>, i <function
>printout()</function
>. Això es deu al fet que no es necessita tot el codi en totes les etapes. Actualment, la funció de preprocessament no s'utilitza realment en molts llocs (normalment l'ometreu). </para>
	</sect2>
	<sect2 id="sect_JS_calculate"
><title
>calculate()</title>
		<programlisting
>function calculate () {
        echo ('res &lt;- t.test (x=' + getString ("x") + ', y=' + getString ("y") + ', hypothesis="' + getString ("hypothesis") + '"' + getString ("varequal"));
        var conflevel = getString ("conflevel");
        if (conflevel != "0.95") echo (', conf.level=' + conflevel);
        echo (')\n');
}
                </programlisting>
		<para
>Aquesta funció genera la sintaxi real de l'&R; que s'executarà des de la configuració de la &IGU;. Mirem això en detall: el codi que s'utilitza es genera utilitzant la sentència <function
>echo()</function
>. Mirant la sentència <function
>echo()</function
> pas a pas, la primera part d'aquesta és </para>
		<screen
>res &lt;- t.test (
                </screen>
		<para
>com a text net. A continuació cal omplir el valor que l'usuari ha seleccionat com a primera variable. Ho obtenim utilitzant <function
>getString ("x")</function
>, i l'afegeix a la cadena per a ser «reproduït». Això mostra el valor de l'element de la &IGU; amb <parameter
>id=</parameter
><replaceable
>"x"</replaceable
>: la nostra primera <command
>&lt;checkbox&gt;</command
>. A continuació, afegim una «, » i fem el mateix per a obtenir el valor de l'element <replaceable
>"y"</replaceable
>, la segona <command
>&lt;checkbox&gt;</command
>. Per a la hipòtesi (el grup <command
>&lt;radio&gt;</command
>), i les variàncies iguals <command
>&lt;checkbox&gt;</command
>, el procediment és molt similar. </para>
		<para
>Tingueu en compte que en lloc de concatenar els fragments de sortida amb «+», també podeu utilitzar diverses sentències <function
>echo()</function
>. Tot s'imprimeix en una sola línia. Per a produir un salt de línia en el codi generat, inseriu una <replaceable
>"\n"</replaceable
> en la cadena reproduïda. En teoria, fins i tot podeu produir moltes línies amb una única sentència d'eco, però manteniu-la en una (o menys) línia de codi generat per <function
>echo()</function
>. </para>
		<note>
			<para
>A més de <function
>getString()</function
>, també hi ha funcions <function
>getBoolean()</function
>, que intentaran retornar el valor com un element binari (apropiat per a utilitzar en una sentència <function
>if()</function
>), i <function
>getList()</function
>, que intentarà retornar dades semblants a una llista en un JS <function
>Array()</function
>. Més tard mostrarem exemples d'això.</para>
			<para
>En mirar els connectors existents, també trobareu molts connectors que utilitzen <function
>getValue()</function
>, en lloc de <function
>getString()</function
>, i de fet els dos són <emphasis
>gairebé</emphasis
> idèntics. No obstant això, utilitzar <function
>getString()</function
>, <function
>getBoolean()</function
> i <function
>getList()</function
> és la pràctica recomanada des de la versió 0.6.1. </para>
		</note>
		<para
>Es torna una mica més complicat per al nivell de confiança. Per raons d'estètica, no volem especificar explícitament el nivell de confiança a utilitzar, si correspon al valor predeterminat. Per tant, en lloc d'imprimir el valor incondicionalment, primer el recuperarem en una variable. Després comprovem si aquesta variable difereix de <replaceable
>"0,95"</replaceable
> i, si és així, imprimeix un argument addicional. Finalment, reproduïm un parèntesi de tancament i un salt de línia: <replaceable
>")\n"</replaceable
>. Això és tot per a la funció de càlcul. </para>
	</sect2>
	<sect2 id="sect_JS_printout"
><title
>printout()</title>
		<programlisting
>function printout () {
        echo ('rk.header (' + i18n ("Two Variable t-Test") + ')\n');
        echo ('rk.print (res)\n');
}
                </programlisting>
		<para
>I això era tot el que hi ha a la funció d'impressió en la majoria dels casos. <function
>rk.header()</function
> imprimeix un titular estàndard del resultat. Tingueu en compte que en els fitxers <literal role="extension"
>.js</literal
> haureu de marcar totes les cadenes traduïbles a mà, utilitzant <command
>i18n()</command
>, o altres ordres alternatives. Més informació en el <link linkend="i18n_js"
>capítol sobre internacionalització</link
>. També podeu afegir més informació a això, si voleu, &pex;: </para>
		<programlisting
>function printout () {
        new Header (i18n ("Two Variable t-Test"))
                  .addFromUI ("varequal")
                  .add (i18n ("Confidence level"), getString ("conflevel"))  // Note: written like this for illustration purposes. More automatic:
        //        .addFromUI ("conflevel")
                  .print ();
echo ('rk.print (res)\n');
}
                </programlisting>
		<para
><function
>rk.print()</function
> utilitza el paquet R2HTML per a proporcionar una sortida amb format &HTML;. Una altra funció útil és <function
>rk.results()</function
>, que també pot generar tipus diferents de taules de resultats. No obstant això, si hi ha dubtes, només cal utilitzar <function
>rk.print()</function
>, i amb això és suficient. La classe JS <function
>Header</function
> és un ajudant de nivell JS per a generar una crida a <function
>rk.header()</function
> (només cal donar un cop d'ull al codi &R; generat). En alguns casos, és possible que vulgueu cridar <function
>echo («rk.header (...)»)</function
> directament per a imprimir una capçalera per la sortida. </para>
		<para
>Tingueu en compte que internament la sortida és només un document &HTML; normal en aquest moment. Per tant, podeu estar temptats d'afegir &HTML; personalitzat utilitzant <function
>rk.cat.output()</function
>. Encara que això funcionarà, no ho feu. El format de sortida pot canviar (&pex;, a ODF) en el futur, de manera que és millor no introduir codi &HTML; específic. Més aviat, manteniu-ho senzill amb <function
>rk.header()</function
>, <function
>rk.print()</function
>, <function
>rk.results()</function
>, i si cal, <function
>rk.print.literal()</function
>. Si això no sembla satisfer les vostres necessitats de format, contacteu amb nosaltres a la llista de correu per a obtenir ajuda. </para>
		<para
>Felicitats! Heu creat el vostre primer connector. Llegiu en els capítols següents quant a conceptes més avançats. </para>
	</sect2>
</sect1>

<sect1 id="jsconventions">
<title
>Convencions, polítiques i coneixement general</title>
	<para
>Hi ha moltes maneres d'escriure codi &R; per a una determinada tasca, i hi ha encara més maneres de generar aquest codi &R; a partir de JS. Com ho feu exactament, és cosa vostra. Encara hi ha una sèrie de consideracions que hauríeu de seguir, i la informació de base que hauríeu d'entendre. </para>

	<sect2 id="policylocal">
	<title
>Entendre l'entorn <function
>local()</function
></title>
		<para
>Amb freqüència haureu de crear un o més objectes &R; temporals en el codi generat pel connector. Normalment, no voleu que es col·loquin a l'espai de treball de l'usuari, fins i tot sobreescrivint les variables d'usuari. Per tant, tot el codi generat pel connector s'executa en un entorn <function
>local()</function
> (vegeu la pàgina d'ajuda de la funció <function
>local()</function
> de l'&R;). Això vol dir que totes les variables que creeu són temporals i no es desaran permanentment. </para>
		<para
>Si l'usuari demana explícitament que es desi una variable, haureu d'assignar a aquest objecte utilitzant <function
>.GlobalEnv$objectname &lt;- value</function
>. En general, no utilitzeu l'operador <function
>&lt;&lt;</function
>. No s'assignarà necessàriament a .GlobalEnv. </para>
		<para
>Un escull important és utilitzar <function
>eval()</function
>. Aquí, haureu de tenir en compte que «eval» utilitzarà de manera predeterminada l'entorn actual per a l'avaluació, &ead;, el local. Això funcionarà bé la majoria de les vegades, però no sempre. Per tant, si necessiteu utilitzar <function
>eval()</function
>, probablement voldreu especificar el paràmetre <parameter
>envir</parameter
>: <function
>eval(..., envir=globalenv()</function
>). </para>
	</sect2>

	<sect2 id="policyformatting">
	<title
>Format del codi</title>
		<para
>El més important és que el codi &R; generat funcioni, però també hauria de ser fàcil de llegir. Per tant, vigileu també el format. Algunes consideracions: </para>
		<para
>S'han d'alinear a l'esquerra les sentències &R; normals de nivell superior. </para>
		<para
>Les sentències d'un bloc inferior s'han de sagnar amb una tabulació (vegeu l'exemple a continuació). </para>
		<para
>Si feu càlculs molt complexos, afegiu un comentari aquí i allà, especialment per a marcar les seccions lògiques. Tingueu en compte que hi ha una funció dedicada <command
>comment()</command
> per a inserir comentaris traduïbles en el codi generat. </para>
		<para
>Per exemple, el codi generat podria tenir aquest aspecte. El mateix codi sense sagnat o comentaris seria bastant difícil de llegir, malgrat la seva modesta complexitat: </para>
		<programlisting
># primer determina el balanceig i la rotació
my.wobble &lt;- wobble (x, y)
my.rotation &lt;- wobble.rotation (my.wobble, z)

# cal triar el mètode de balanceig segons la rotació
if (my.rotation &gt; wobble.rotation.limit (x)) {
        method &lt;- "foo"
        result &lt;- boggle.foo (my.wobble, my.rotation)
} else {
        method &lt;- "bar"
        result &lt;- boggle.bar (my.wobble, my.rotation)
}
                </programlisting>
	</sect2>

	<sect2 id="policysimplicity">
	<title
>Tractament amb opcions complexes</title>
		<para
>Molts connectors poden fer més d'una cosa. Per exemple, el connector «Estadístiques descriptives» pot calcular la mitjana, l'interval, la suma, el producte, la mediana, la longitud, &etc; No obstant això, normalment l'usuari només triarà fer alguns d'aquests càlculs. En aquest cas, intenteu mantenir el codi generat el més senzill possible. Només hauria de contenir porcions rellevants per a les opcions realment seleccionades. Per a aconseguir-ho, aquí hi ha un exemple d'un patró de disseny comú tal com l'utilitzaríeu (en JS; aquí, "domean", "domedian" i "dosd" serien elements de &lt;checkbox&gt;): </para>
		<programlisting
>function calculate () {
        echo ('x &lt;- &lt;' + getString ("x") + ')\n');
        echo ('results &lt;- list ()\n');

        if (getBoolean ("domean.state")) echo ("results$" + i18n ("Mean value") + " &lt;- mean (x)\n");
        if (getBoolean ("domedian.state")) echo ("results$" + i18n ("Median") + " &lt;- median (x)\n");
        if (getBoolean ("dosd.state")) echo ("results$" + i18n ("Standard deviation") + " &lt;- sd (x)\n");
        //...
}
                </programlisting>
	</sect2>
</sect1>

<sect1 id="jstips">
<title
>Consells i trucs</title>
	<para
>Aquí hi ha alguns trucs diversos que poden fer que l'escriptura de connectors sigui menys tediosa: </para>
	<para
>Si necessiteu el valor d'un paràmetre de la &IGU; en diversos llocs en el codi del connector, considereu assignar-la a una variable en JS, i utilitzant-la en lloc de recuperar-la una vegada i una altra amb <function
>getString()/getBoolean()/getList()</function
>. Això és més ràpid, més llegible i amb menys tecleig, tot alhora: </para>
	<programlisting
>function calculate () {
        var narm = "";        // na.rm=FALSE is the default in all functions below
        if (getBoolean ("remove_nas")) {
                $narm = ", na.rm=TRUE";
        }
        // ...
        echo ("results$foo &lt;- foo (x" + narm + ")\n");
        echo ("results$bar &lt;- bar (x" + narm + ")\n");
        echo ("results$foobar &lt;- foobar (x" + narm "\n");
        // ...
}
        </programlisting>
	<para
>La simple funció d'ajuda <function
>makeOption()</function
> pot facilitar l'omissió dels paràmetres que tenen el seu valor predeterminat, en molts casos: </para>
	<programlisting
>function calculate () {
        var options
        //...
        // This will do nothing, if VALUE is 0.95 (the default). Otherwise it will append ', conf.int=VALUE' to options.
        options += makeOption ("conf.int", getString ("confint"), "0.95");
        //...
}
        </programlisting>
</sect1>
</chapter>

<chapter id="pluginhelp">
	<title
>Escriure una pàgina d'ajuda</title>
	<para
>Quan el vostre connector funciona bàsicament, ha arribat el moment de proporcionar una pàgina d'ajuda. Encara que normalment no voldreu explicar tots els conceptes subjacents en profunditat, és possible que vulgueu afegir alguna explicació més per a alguna de les opcions, i enllaçar amb connectors relacionats i funcions de l'&R;. </para>
	<tip>
		<para
>Després de llegir aquest capítol, doneu també un cop d'ull al <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>. Proporciona algunes funcions de l'&R; per a crear la majoria de les etiquetes &XML; del &rkward;. També és capaç de crear esquelets bàsics de fitxers d'ajuda a partir dels fitxers &XML; existents per a començar. </para>
	</tip>
	<para
>Potser recordareu posar això dins del connector &XML; (si no l'heu posat, feu-ho ara): </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;help file="filename.rkh" /&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>On, òbviament, substituireu <filename
>filename</filename
> per un nom més apropiat. Ara és el moment de crear aquest fitxer <literal role="extension"
>.rkh</literal
>. Aquest és un exemple autodescriptiu: </para>
	<programlisting
>&lt;!DOCTYPE rkhelp&gt;
&lt;document&gt;
        &lt;summary&gt;
En aquesta secció, posareu informació breu i molt bàsica sobre què fa el connector.
Aquesta secció sempre es mostrarà a la part superior de la pàgina d'ajuda.
        &lt;/summary&gt;

        &lt;usage&gt;
La secció d'ús pot contenir una mica més d'informació pràctica. Però
no explica tots els paràmetres en detall (això es fa a la secció «settings»).

Per a iniciar un paràgraf nou, inseriu una línia buida, com es mostra a dalt.
Aquesta línia, en canvi, serà al mateix paràgraf.

En totes les seccions podeu inserir codi HTML senzill, com ara el text &lt;b&gt;bold&lt;/b&gt; o &lt;i&gt;italic&lt;/i&gt;. No obstant això, manteniu el format al mínim necessari.

La secció d'ús és sempre la segona secció que es mostra en una pàgina d'ajuda.
        &lt;/usage&gt;

        &lt;section id="sectionid" title="Secció genèrica" short_title="Genèrica"&gt;
Si cal, podeu afegir seccions addicionals entre les seccions d'ús i de configuració.
No obstant això, normalment no ho necessitareu mentre documenteu els connectors.
L'atribut «id» proporciona un punt d'ancoratge per a saltar a aquesta secció
des del menú de navegació. L'atribut «short_title» proporciona un títol curt per a utilitzar a la barra de navegació.
Això és opcional, per defecte el "títol" principal s'utilitzarà tant com a encapçalament de la secció, com a nom de l'enllaç a la barra de navegació.

En qualsevol secció podeu inserir enllaços per a més informació. Ho feu afegint

&lt;link href="URL"&gt;link name&lt;/link&gt;

A on URL pot ser un enllaç extern com https://rkward.kde.org .
Es permeten diversos URL especials a les pàgines d'ajuda:

&lt;link href="rkward://page/path/page_id"/&gt;

Això enllaça a una pàgina d'ajuda de nivell superior del RKWard (no per a un connector).

&lt;link href="rkward://component/[namespace/]component_id"/&gt;

Això enllaça a la pàgina d'ajuda d'un altre connector. La part [namespace/] es pot ometre
(en aquest cas, s'assumeix el RKWard com a espai de noms estàndard, p. ex.:
&lt;link href="rkward://component/import_spss"/&gt; o
&lt;link href="rkward://component/rkward/import_spss"/&gt; són equivalents).
El «component_id» és el mateix que heu especificat en el <link linkend="pluginmap"
>&pluginmap;</link
>.

&lt;link href="rkward://rhelp/rfunction"/&gt;

Enllaça a la pàgina d'ajuda "rfunction" de l'&R; .

Tingueu en compte que els noms dels enllaços es generaran automàticament per a aquests tipus d'enllaços.
        &lt;/section&gt;

        &lt;settings&gt;
                &lt;caption id="id_of_tab_or_frame"/&gt;
                &lt;setting id="id_of_element"&gt;
Descripció de l'element de la IGU identificat per l'id indicat
                &lt;/setting&gt;
                &lt;setting id="id_of_elementb" title="descripció"&gt;
Normalment el títol de l'element de la IGU s'extraurà a partir de la
<link linkend="mainxml"
>definició &XML; del connector</link
>, automàticament. Tanmateix,
per a alguns elements de la IGU aquesta descripció pot no ser suficient per a identificar-los amb fiabilitat.
En aquest cas podeu afegir un títol explícit usant l'atribut "title".
                &lt;/setting&gt;
                &lt;setting id="id_of_elementc"&gt;
Descripció de l'element de la IGU identificat per "id_of_elementc"
                &lt;/setting&gt;
                [...]
        &lt;/settings&gt;

        &lt;related&gt;
La secció de relacions normalment conté diversos enllaços, com ara:

&lt;ul&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/mean"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://rhelp/median"/&gt;&lt;/li&gt;
        &lt;li&gt;&lt;link href="rkward://component/related_component"/&gt;&lt;/li&gt;
&lt;/ul&gt;
        &lt;/related&gt;

        &lt;technical&gt;
La secció tècnica (opcional, sempre l'última) pot contenir alguns detalls tècnics de la implementació del connector,
que només són d'interès per als desenvolupadors del RKWard. Això és particularment rellevant
per als connectors que estan dissenyats per a ser incrustats en molts altres connectors,
i podria detallar quines opcions estan disponibles per a personalitzar el connector incrustat,
i quines seccions de codi contenen quin codi R.
        &lt;/technical&gt;
&lt;/document&gt;
        </programlisting>
</chapter>


<chapter id="logic">
<title
>Interaccions lògiques entre elements de la &IGU;</title>
<sect1 id="sect_GUI_logic"
><title
>Lògica de la &IGU;</title>
	<para
>Tots els conceptes bàsics de crear un connector per al &rkward; s'han descrit en els capítols anteriors. Aquests conceptes bàsics haurien de ser suficients per a molts casos, si no la majoria. No obstant això, de vegades voleu més control sobre com es comporta la &IGU; del connector. </para>
	<para
>Per exemple, suposem que voleu ampliar l'exemple de la prova t utilitzat en aquesta documentació per a permetre: comparar una variable amb una altra variable (com es mostra), així com comparar una variable amb un valor constant. Ara, una manera de fer-ho seria afegir un control d'opcions que canviï entre els dos modes, i afegir un botó de selecció de valors per a introduir el valor constant amb el qual comparar. Considereu aquest exemple simplificat: </para>
	<programlisting
>&lt;!DOCTYPE rkplugin&gt;
&lt;document&gt;
        &lt;code file="code.js"/&gt;

        &lt;dialog label="T-Test"&gt;
                &lt;row&gt;
                        &lt;varselector id="vars"/&gt;
                        &lt;column&gt;
                                &lt;varslot id="x" types="number" source="vars" required="true" label="compare"/&gt;
                                &lt;radio id="mode" label="Compare against"&gt;
                                        &lt;option value="variable" checked="true" label="another variable (select below)"/&gt;
                                        &lt;option value="constant" label="a constant value (set below)"/&gt;
                                &lt;/radio&gt;
                                &lt;varslot id="y" types="number" source="vars" required="true" label="variable" i18n_context="Noun; a variable"/&gt;
                                &lt;spinbox id="constant" initial="0" label="constant" i18n_context="Noun; a constant"/&gt;
                        &lt;/column&gt;
                &lt;/row&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Fins ara està bé, però hi ha una sèrie de problemes amb aquesta &IGU;. En primer lloc, sempre es mostren tant el «varslot» com el «spinbox», mentre que realment només s'utilitza un dels dos. Pitjor encara, el «varslot» sempre requereix una selecció vàlida, fins i tot si es compara amb una constant. Òbviament, si creem una &IGU; multiús com aquesta, volem més flexibilitat. Introduïu: la secció <command
>&lt;logic&gt;</command
> (inserida al mateix nivell que <command
>&lt;code&gt;</command
>, <command
>&lt;dialog&gt;</command
>, o <command
>&lt;wizard&gt;</command
>). </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;

        &lt;logic&gt;
                &lt;convert id="varmode" mode="equals" sources="mode.string" standard="variable" /&gt;

                &lt;connect client="y.visible" governor="varmode" /&gt;
                &lt;connect client="constant.visible" governor="varmode.not" /&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>La primera línia dins de la secció «logic» és una etiqueta <command
>&lt;convert&gt;</command
>. Bàsicament, això proporciona una propietat booleana nova (activada o desactivada, certa o falsa), que es pot utilitzar més endavant. Aquesta propietat (<replaceable
>"varmode"</replaceable
>) és certa, sempre que se seleccioni el botó d'opció superior, i fals quan se seleccioni el botó d'opció inferior. Com es fa això? </para>
	<para
>En primer lloc, sota <parameter
>sources</parameter
>, s'enumeren les propietats de les fonts («sources») en les quals treballar (en aquest cas només una cadascuna; es podrien llistar com a <parameter
>sources=</parameter
><replaceable
>"mode.string;somethingelse"</replaceable
>, llavors <replaceable
>"varmode"</replaceable
> només seria cert, si tant <replaceable
>"mode.string"</replaceable
> com <replaceable
>"somethingelse"</replaceable
> són iguals a la cadena <replaceable
>"variable"</replaceable
>). Tingueu en compte que en aquest cas no només escrivim <replaceable
>"mode"</replaceable
> (com ho faríem a <function
>getString("mode")</function
>), sinó <replaceable
>"mode.string"</replaceable
>. En realitat, aquesta és la manera interna en què funciona un control d'opcions: té una propietat «string», que té el seu valor de cadena. <function
>getString("mode")</function
> és només una abreviatura, i equival a <function
>getString("mode.string")</function
>. Vegeu la referència per a totes les propietats dels diferents elements de la &IGU;. </para>
	<para
>En segon lloc, hem establert el mode de conversió a <parameter
>mode=</parameter
><replaceable
>"equals"</replaceable
>. Això vol dir que volem comprovar si la/es font/s és/són igual/s que un valor determinat. Finalment «standard» és el valor contra el qual comparar, de manera que amb <parameter
>standard=</parameter
><replaceable
>"variable"</replaceable
>, es comprova si la propietat <replaceable
>"mode.string"</replaceable
> és igual que la cadena <replaceable
>"variable"</replaceable
> (el valor de l'opció del botó superior). Si és igual, llavors la propietat «varmode» és certa, altrament és falsa. </para>
	<para
>Passem a les coses reals: <command
>&lt;connect&gt;</command
> la propietat <replaceable
>"varmode"</replaceable
> a «y.visible», que controla si es mostra o no la gràfica <replaceable
>"y"</replaceable
>. Tingueu en compte que qualsevol element que es fa invisible és implícitament no obligatori. Per tant, si se selecciona l'opció del botó superior, es requereix el «varslot» <replaceable
>"y"</replaceable
>, i és visible. Si no, no és necessari ni ocult. </para>
	<para
>Per al botó de selecció de valors, volem exactament el contrari. Afortunadament, no necessitem un altre <command
>&lt;convert&gt;</command
> per a això: les propietats booleanes es poden negar molt fàcilment afegint el modificador <replaceable
>"no"</replaceable
>, així que <command
>&lt;connect&gt;</command
> <replaceable
>"varmode.not"</replaceable
> a la propietat de visibilitat del botó de selecció de valors. En efecte, es mostra i es requereix el «varslot», <emphasis
>o</emphasis
> es mostra el botó de selecció de valors i es requereix (depenent de quina opció està seleccionada en el control d'opcions). La &IGU; està canviant segons l'opció del botó. Proveu l'exemple, si voleu. </para>
	<para
>Per a obtenir una llista completa de propietats, consulteu la <link linkend="reference"
>referència</link
>. Una propietat més, però, és especial perquè tots els elements de la &IGU; la tenen: «enabled». Això és una mica menys dràstic que «visible». No mostra/oculta l'element de la &IGU;, però només l'activa/desactiva. Els elements desactivats es mostren normalment en gris i no reaccionen a l'entrada de l'usuari. </para>
	<note>
		<para
>A més de <command
>&lt;convert&gt;</command
> i <command
>&lt;connect&gt;</command
>, hi ha diversos elements més per a utilitzar a la secció <command
>&lt;logic&gt;</command
>. Per exemple, les construccions condicionals també es poden implementar utilitzant l'element <command
>&lt;switch&gt;</command
>. Consulteu la <link linkend="logicelements"
>referència sobre elements lògics</link
> per a més detalls.</para>
	</note>
</sect1>
<sect1 id="logic_scripted">
<title
>Lògica de la &IGU; amb scripts</title>
	<para
>Sovint és suficient connectar les propietats tal com es descriu anteriorment, però de vegades és més flexible o més pràctic utilitzar JS per a crear scripts en la lògica de la &IGU;. D'aquesta manera, l'exemple anterior es podria reescriure com: </para>
	<programlisting
>[...]
        &lt;code file="code.js"/&gt;
'
        &lt;logic&gt;
                &lt;script&gt;&lt;![CDATA[
                        // ECMAScript code in this block
                        // the top-level statement is only called once
                        gui.addChangeCommand ("mode.string", "modeChanged ()");

                        // this function is called whenever the "mode" was changed
                        modeChanged = function () {
                                var varmode = (gui.getString ("mode.string") == "variable");
                                gui.setValue ("y.enabled", varmode);
                                gui.setValue ("constant.enabled", !varmode);
                        }
                ]]&gt;&lt;/script&gt;
        &lt;/logic&gt;

        &lt;dialog label="T-Test"&gt;
        [...]
        </programlisting>
	<para
>La primera línia de codi li diu al &rkward; que cridi a la funció <function
>modeChanged()</function
> sempre que canviï el valor del quadre de botons d'opció <parameter
>id=</parameter
><replaceable
>"mode"</replaceable
>. Dins d'aquesta funció, definim una variable d'ajuda <replaceable
>"varmode"</replaceable
> que és certa quan el mode és <replaceable
>"variable"</replaceable
>, falsa quan és <replaceable
>"constant"</replaceable
>. Després utilitzem <function
>gui.setValue()</function
> per a establir les propietats «enabled» de <replaceable
>"y"</replaceable
> i <replaceable
>"constant"</replaceable
>, de la mateixa manera que abans vam fer servir sentències <command
>&lt;connect&gt;</command
>. </para>
	<para
>L'enfocament amb scripts a la lògica de la &IGU; esdevé particularment útil quan voleu canviar l'opció disponible segons el tipus d'objecte que l'usuari ha seleccionat. Vegeu <link linkend="guilogic_functions"
>la referència</link
> per a les funcions disponibles. </para>
	<para
>Tingueu en compte que l'enfocament amb scripts a la lògica de la &IGU; es pot barrejar amb sentències <command
>&lt;connect&gt;</command
> i <command
>&lt;convert&gt;</command
> si voleu. Tingueu en compte també que l'etiqueta <command
>&lt;script&gt;</command
> permet especificar un nom de fitxer de script a més o com a alternativa a la inclusió del codi de script. Normalment la inclusió del codi de script tal com es mostra a dalt és més pràctic. </para>
</sect1>
</chapter>

<chapter id="embedding">
<title
>Incrustar connectors en connectors</title>
<sect1 id="sect_embedding"
><title
>Casos d'ús per a incrustar</title>
	<para
>En escriure connectors, sovint trobareu que esteu creant una sèrie de connectors que només difereixen en alguns aspectes, però tenen molt més en comú. Per exemple, per al traçat, hi ha una sèrie d'opcions &R; genèriques que es poden utilitzar amb la majoria de tipus de diagrames. Hauríeu de crear una &IGU; i una plantilla JS per a aquests una vegada i una altra? </para>
	<para
>Evidentment, això seria una molèstia. Afortunadament, no cal que ho feu. Més aviat creareu la funcionalitat comuna una vegada, i més tard podreu incrustar-la en diversos connectors. De fet, és possible incrustar qualsevol connector en qualsevol altre connector, fins i tot si l'autor original del connector incrustat mai ho va pensar, algú voldria incrustar el seu connector en un altre. </para>
</sect1>
<sect1 id="embedding_dialog">
<title
>Incrustació dins d'un diàleg</title>
	<para
>D'acord, ja hem parlat prou. Com funciona? És senzill: utilitzeu l'etiqueta <command
>&lt;embed&gt;</command
>. Aquest és un exemple retallat: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
                &lt;tab label="Plot Options" i18n_context="Options concerning the plot"&gt;
                        &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;/tab&gt;
                &lt;tab [...]&gt;
                        [...]
                &lt;/tab&gt;
        &lt;/tabbook&gt;
&lt;/dialog&gt;
        </programlisting>
	<para
>El que passa aquí, és que tota la &IGU; o el connector d'opcions del diagrama (excepte per descomptat per als elements estàndard com el botó <guibutton
>Submit</guibutton
>, &etc;) s'incrusta directament en el vostre connector (proveu-ho!). </para>
	<para
>Com podeu veure la sintaxi de l'etiqueta <command
>&lt;embed&gt;</command
> és força senzilla. Pren un <parameter
>id</parameter
> com la majoria d'elements. El component del paràmetre especifica quin connector incrustar, com es defineix al fitxer &pluginmap; (<replaceable
>"rkward::plot_options"</replaceable
> és el resultat de concatenar l'espai de noms «rkward», un separador «::», i el nom del component «plot_options»). </para>
</sect1>
<sect1 id="embedding_code">
<title
>Generació de codi en incrustar</title>
	<para
>Fins ara tot bé, però què passa amb el codi generat? Com es fusiona el codi del connector incrustador i l'incrustat? En el codi JS del connector incrustador escriviu quelcom com això: </para>
	<programlisting
>function printout () {
        // ...
        echo ("myplotfunction ([...]" + getString ("plotoptions.code.printout"); + ")\n");
        // ...
}
        </programlisting>
	<para
>Bàsicament, estem recuperant el codi generat pel connector incrustat igual que estem recuperant qualsevol altra opció de la &IGU;. Aquí la cadena <replaceable
>"plotoptions.code.printout"</replaceable
> es pot desenvolupar com «La secció d'impressió del codi generat de l'element amb plotoptions d'identificador <parameter
>id</parameter
>» («plotoptions» és l'ID que hem donat a l'etiqueta <command
>&lt;embed&gt;</command
> anterior). I sí, si voleu un control avançat, fins i tot podreu recuperar els valors dels elements individuals de la &IGU; dins del connector incrustat (però no a l'inrevés, ja que el connector incrustat no coneix res sobre el seu entorn). </para>
</sect1>
<sect1 id="embedding_wizard">
<title
>Incrustació dins d'un assistent</title>
	<para
>Si el vostre connector proporciona una &IGU; d'assistent, la incrustació funciona bàsicament de la mateixa manera. Generalment utilitzareu: </para>
	<programlisting
>&lt;wizard [...]&gt;
                [...]
                &lt;page id="page12"&gt;
                        [...]
                &lt;/page&gt;
                &lt;embed id="plotoptions" component="rkward::plot_options"/&gt;
                &lt;page id="page13"&gt;
                        [...]
                &lt;/page&gt;
                [...]
        &lt;/wizard&gt;
        </programlisting>
	<para
>Si el connector incrustat proporciona una interfície assistent, les seves pàgines s'inseriran entre <replaceable
>"page12"</replaceable
> i <replaceable
>"page13"</replaceable
> del vostre connector. Si el connector incrustat només proporciona una interfície de diàleg, s'afegirà una única pàgina nova entre les pàgines <replaceable
>"page12"</replaceable
> i <replaceable
>"page13"</replaceable
>. L'usuari no se n'adonarà mai. </para>
</sect1>
<sect1 id="embedding_as_button">
<title
>Incrustació menys incrustada: botó d'opcions addicionals</title>
	<para
>Encara que la incrustació és genial, cal anar amb compte de no excedir-se. Massa funcions dins d'una &IGU; només fa que sigui difícil trobar les opcions rellevants. Per descomptat, a vegades és possible que vulgueu incrustar una gran quantitat d'opcions (com totes les opcions a <function
>plot()</function
>), però com que són realment opcionals, no les voldreu de manera prominent a la &IGU;. </para>
	<para
>Una alternativa és incrustar aquestes opcions «com a un botó»: </para>
	<programlisting
>&lt;dialog&gt;
        &lt;tabbook&gt;
                [...]
                &lt;tab label="Options"&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Specify plotting options"/&gt;
                &lt;/tab&gt;
                [...]
        &lt;/tabbook&gt;
&lt;/dialog&gt;
</programlisting>
	<para
>En aquest cas, s'afegirà un únic botó de prémer al connector, etiquetat <guibutton
>Especifica les opcions de traçat</guibutton
>. Quan premeu aquest botó, apareixerà un diàleg separat, amb totes les opcions del connector incrustat. Fins i tot si aquesta &IGU; incrustada no és visible la majoria de les vegades, podeu obtenir la seva configuració tal com es descriu <link linkend="embedding_code"
>a dalt</link
>. </para>
	<para>
		<caution>
			<para
>Probablement el «botó» d'aproximació només s'hauria d'utilitzar per als connectors que mai poden no ser vàlids (per configuració que manca/no vàlida). En cas contrari, l'usuari no podria enviar el codi, però podria tenir dificultats per a esbrinar-ho, el motiu està amagat darrere d'algun botó. </para
>	
		</caution>
	</para>
</sect1>
<sect1 id="embedding_incomplete">
<title
>Incrustació/definició de connectors incomplets</title>
	<para
>Alguns connectors, i de fet, el «plot_options» utilitzat a l'exemple anterior és un d'ells, no es completen per si sols. Simplement no tenen els elements de la &IGU; per a seleccionar alguns valors importants. Estan destinats només a ser incrustat en altres connectors. </para>
	<para
>Fins a quin punt està incomplet el connector «plot_options»? Bé, per algunes opcions de configuració, necessita conèixer el nom dels objectes/expressions dels eixos x i y (de fet, funcionarà bé si només en té un, però necessita almenys un per a funcionar correctament). No obstant això, no té un mecanisme per a seleccionar aquests objectes, ni introduir-los d'una altra manera. Com sap d'ells? </para>
	<para
>A la secció lògica del connector «plot_options» hi ha dues línies addicionals, encara no explicades: </para>
	<programlisting
>&lt;logic&gt;
                &lt;external id="xvar" /&gt;
                &lt;external id="yvar" /&gt;

                [...]
        &lt;/logic&gt;
        </programlisting>
	<para
>Això defineix dues propietats addicionals al connector «plot_options», l'únic propòsit de les quals és connectar-se a algunes propietats (encara desconegudes) del connector incrustat. Al connector «plot_options» aquestes dues propietats s'utilitzen simplement com qualsevol altra, i per exemple hi ha crides a <function
>getString("xvar")</function
> en la plantilla JS «plot_options». </para>
	<para
>Ara, per al connector incomplet no hi ha manera de saber on s'incrustarà, i quina serà la configuració rellevant en el connector incrustant. Per tant, també cal afegir dues línies addicionals a la secció lògica del connector incrustant: </para>
	<programlisting
>&lt;logic&gt;
                [...]

                &lt;connect client="plotoptions.xvar" governor="xvarslot.available" /&gt;
                &lt;connect client="plotoptions.yvar" governor="yvarslot.available" /&gt;
        &lt;/logic&gt;
        </programlisting>
	<para
>Això no és res nou en principi, hem explicat les sentències <command
>&lt;connect&gt;</command
> en el <link linkend="logic"
>capítol de lògica de la &IGU;</link
>. Simplement connecteu els valors en dos «varlots» (anomenats <replaceable
>"xvarslot"</replaceable
> i <replaceable
>"yvarslot"</replaceable
> en aquest exemple) a les propietats «external» rebudes del connector incrustat. Això és tot. Tota la resta es prepara automàticament. </para>
</sect1>
</chapter>

<chapter id="plugin_series">
<title
>Tractament amb molts connectors similars</title>
<sect1 id="sect_similar_plugins"
><title
>Vista general de diferents enfocaments</title>
	<para
>De vegades, és possible que vulgueu desenvolupar connectors per a una sèrie de funcions similars. Per exemple, considereu els diagrames de distribució. Aquests generen codi força similar, i per descomptat és desitjable fer que les interfícies gràfiques s'assemblin entre si. Finalment, grans seccions dels fitxers d'ajuda poden ser idèntiques. Només uns quants paràmetres són diferents en cada connector. </para>
	<para
>L'enfocament ingenu d'això és desenvolupar un connector, després bàsicament copiar i enganxar tot el contingut dels fitxers <literal role="extension"
>.js</literal
>, <literal role="extension"
>.xml</literal
>, i <literal role="extension"
>.rkh</literal
>, després canviar les poques porcions que són diferents. No obstant això, i si algun temps després trobeu un error ortogràfic que s'ha copiat i enganxat a tots els connectors? I si voleu afegir suport per a una característica nova? Hauríeu de tornar a visitar tots els connectors i canviar-ho a cadascun. Un procés pesat i tediós. </para>
	<para
>Un segon enfocament seria utilitzar <link linkend="embedding"
>incrustacions</link
>. Tanmateix, en alguns casos això no es presta bé al problema que tenim entre mans, principalment perquè els «fragments» que podeu incrustar són de vegades massa grans per a ser útils, i posa algunes restriccions en la disposició. Per a aquests casos, els conceptes <link linkend="include_js"
>incloent fitxers <literal role="extension"
>.js</literal
></link
>, <link linkend="include_xml"
>incloent fitxers <literal role="extension"
>.xml</literal
></link
> i <link linkend="snippets"
>fragments</link
> poden ser molt útils (però vegeu els <link linkend="include_snippets_vs_embedding"
>pensaments sobre quan és preferible utilitzar la incrustació</link
>). </para>
	<para
>Algunes paraules a tenir en compte abans de començar a llegir: aquests conceptes poden ajudar a simplificar la gestió de molts connectors similars, i poden millorar el manteniment i la llegibilitat d'aquests connectors. No obstant això, l'excés pot conduir fàcilment a l'efecte invers. Utilitzeu-ho amb cura. </para>
</sect1>
<sect1 id="include_js">
<title
>Ús de la sentència «include» del JS</title>
	<para
>Podeu incloure fàcilment un fitxer de script en un altre en els connectors del &rkward;. El valor d'això esdevé immediatament obvi si algunes seccions del codi JS són similars entre els connectors. Podeu definir aquestes seccions en un fitxer <literal role="extension"
>.js</literal
> separat, i incloure'l en tots els fitxers <literal role="extension"
>.js</literal
> del connector. Per exemple, com a: </para>
	<programlisting
>// this is a file called "common_functions.js"

function doCommonStuff () {
        // perhaps fetch some options, etc.
        // ...
        comment ("This is R code you want in several different plugins\n");
        // ...
}
        </programlisting>
	<programlisting
>// this is one of your regular plugin <literal role="extension"
>.js</literal
> files

// include the common functions
include ("common_functions.js");

function calculate () {
        // do something
        // ...

        // insert the common code
        doCommonStuff ();
}
        </programlisting>
	<para
>Tingueu en compte que de vegades és encara més útil invertir això, i definir l'«esquelet» de les funcions <function
>preprocess()</function
>, <function
>calculate()</function
>, i <function
>printout()</function
> en un fitxer comú, i fer que aquestes crides tornin per a aquelles parts que són diferents entre els connectors. P. ex.: </para>
	<programlisting
>// this is a file called "common_functions.js"

function calculate () {
        // do some things which are the same in all plugins
        // ...

        // add in something that is different across plugins
        getSpecifics ();

        // ...
}
        </programlisting>
	<programlisting
>// this is one of your regular plugin <literal role="extension"
>.js</literal
> files

// include the common functions
include ("common_functions.js");

// note: no calculate() function is defined in here.
// it in the common_functions.js, instead.

function getSpecifics () {
        // print some R code
}
        </programlisting>
	<para
>Un problema que hauríeu de tenir en compte quan utilitzeu aquesta tècnica és l'àmbit de les variables. Vegeu el manual del JS sobre els àmbits de les variables. </para>
	<para
>Aquesta tècnica s'utilitza molt en els connectors de traçat de distribució i de traçat de TLC, de manera que és possible que vulgueu cercar-hi exemples. </para>
</sect1>

<sect1 id="include_xml">
<title
>Incloure els fitxers <literal role="extension"
>.xml</literal
></title>
	<para
>Bàsicament, la mateixa característica d'incloure fitxers també està disponible per al seu ús en els fitxers <literal role="extension"
>.xml</literal
>, &pluginmap; i <literal role="extension"
>.rkh</literal
>. En qualsevol lloc d'aquests fitxers podeu posar una etiqueta <command
>&lt;include&gt;</command
> com es mostra a continuació. L'efecte és que tot el contingut d'aquest fitxer &XML; (per a ser precisos: tot dins de l'etiqueta <command
>&lt;document&gt;</command
> d'aquest fitxer) s'inclou literalment en aquest punt en el fitxer. Recordeu que només podeu incloure un altre fitxer &XML;. </para>
	<programlisting
>&lt;document&gt;
        [...]
        &lt;include file="another_xml_file.xml"/&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<para
>L'atribut <parameter
>file</parameter
> és el nom del fitxer relatiu al directori on es troba el fitxer actual. </para>
</sect1>

<sect1 id="snippets">
<title
>Ús de &lt;snippets&gt;</title>
	<para
>Si bé incloure fitxers com es mostra a la <link linkend="include_xml"
>secció anterior</link
> és bastant potent, es torna més útil quan s'utilitza en combinació amb <command
>&lt;snippets&gt;</command
>. Els «snippets» (fragments) són seccions més petites que podeu inserir en un altre punt del fitxer. Un exemple il·lustra millor això: </para>
	<programlisting
>&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;frame&gt;
                                &lt;text&gt;
                This will be inserted at two places in the GUI
                                &lt;/text&gt;
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;
        &lt;dialog label="test"&gt;
                &lt;column&gt;
                        &lt;insert snippet="note"/&gt;
                        [...]
                        &lt;insert snippet="note"/&gt;
                &lt;/column&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Per tant, definiu el fragment en un lloc a la part superior del fitxer &XML;, i després feu una inserció amb <command
>&lt;insert&gt;</command
> en qualsevol lloc/s que desitgeu. </para>
	<para
>Si bé aquest exemple no és massa útil en si mateix, penseu a combinar-lo amb un fitxer <command
>&lt;include&gt;</command
> <literal role="extension"
>.xml</literal
>. Tingueu en compte que també podeu col·locar fragments per al fitxer <literal role="extension"
>.rkh</literal
> al mateix fitxer. Simplement hauríeu de fer-hi <command
>&lt;include&gt;</command
> també del fitxer, i <command
>&lt;insert&gt;</command
> el fragment rellevant: </para>
	<programlisting
>&lt;!-- This is a file called "common_snippets.xml" --&gt;
&lt;document&gt;
        &lt;snippet id="common_options"&gt;
                &lt;spinbox id="something" [...]/&gt;
                [...]
        &lt;/snippet&gt;
        &lt;snippet id="common_note"&gt;
                &lt;text&gt;An important note for this type of plugin&lt;/text&gt;
        &lt;/snippet&gt;

        &lt;snippet id="common_help"&gt;
                &lt;setting id="something"&gt;This does something&lt;/setting&gt;
                [...]
        &lt;/snippet&gt;
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- This is the .xml file of the plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;!-- Import the common snippets --&gt;
                &lt;include file="common_snippets.xml"/&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test2"&gt;
                &lt;insert snippet="common_note"/&gt;
                &lt;spinbox id="something_plugin_specific" [...] /&gt;
                &lt;insert snippet="common_options"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Similar a la <link linkend="include_js"
>inclusió en JS</link
>, l'enfocament invers és sovint encara més útil: </para>
	<programlisting
>&lt;!-- This is a file called "common_layout.xml" --&gt;
&lt;document&gt;
        &lt;column&gt;
                &lt;insert snippet="note"&gt;
                [...]
                &lt;insert snippet="plugin_parameters"&gt;
        &lt;/column&gt;
        [...]
&lt;/document&gt;
        </programlisting>
	<programlisting
>&lt;!-- This is the .xml file of the plugin --&gt;
&lt;document&gt;
        &lt;snippets&gt;
                &lt;snippet id="note"&gt;
                        &lt;text&gt;The note used for this specific plugin&lt;/text&gt;
                &lt;/snippet&gt;

                &lt;snippet id="plugin_parameters"&gt;
                        &lt;frame label="Parameters specific to this plugin"&gt;
                                [...]
                        &lt;/frame&gt;
                &lt;/snippet&gt;
        &lt;/snippets&gt;

        &lt;dialog label="test3"&gt;
                &lt;include file="common_layout.xml"/&gt;
        &lt;/dialog&gt;
&lt;/document&gt;
        </programlisting>
	<para
>Finalment, també és possible <command
>&lt;insert&gt;</command
> fragments en altres fragments, sempre que: a) només hi hagi un nivell d'imbricació, i b) la secció <command
>&lt;snippets&gt;</command
> es col·loca a la part superior del fitxer (abans que s'insereixi un fragment niat); això és perquè les sentències <command
>&lt;insert&gt;</command
> es resolen de dalt a baix. </para>
</sect1>

<sect1 id="include_snippets_vs_embedding">
<title
>&lt;include&gt; i &lt;snippets&gt; vs. &lt;embed&gt;</title>
	<para
>A primera vista, <command
>&lt;include&gt;</command
> i <command
>&lt;snippets&gt;</command
> proporcionen una funcionalitat bastant similar a <link linkend="embedding"
>incrustar</link
>: permet reutilitzar algunes porcions de codi entre els connectors. Llavors, quina és la diferència entre aquests enfocaments i quan s'ha d'utilitzar quin? </para>
	<para
>La diferència clau entre aquests conceptes és que els connectors incrustables són paquets més petits. Combinen una &IGU; completa, codi per a generar codi &R; a partir d'això, i una pàgina d'ajuda. Per contra, incloure i inserir permet un control molt més fi de la granularitat, però a costa de menys modularitat. </para>
	<para
>És a dir, un connector que incrusta un altre connector no necessitarà saber gaire sobre els detalls interns del connector incrustat. Un exemple principal és el connector «plot_options». Els connectors que vulguin incrustar això no necessàriament necessiten conèixer totes les opcions proporcionades, o com es proporcionen. Això és una cosa bona, ja que en cas contrari un canvi en el connector «plot_options» podria fer necessari ajustar tots els connectors que incrusten això (molts). Per contra, incloure i inserir realment exposa tots els detalls interns, i els connectors que utilitzen això, per exemple, necessitaran conèixer els ID exactes i potser fins i tot el tipus dels elements utilitzats. </para>
	<para
>Per tant, la regla general és la següent: incloure i inserir són adequats si les opcions rellevants només són necessàries per a un grup clarament limitat de connectors. Els connectors incrustats són millors si el grup de connectors als quals poden ser útils no està clarament definit, i si la funcionalitat es pot fer modular fàcilment. Una altra regla general: si podeu posar les porcions comunes en un sol «fragment», llavors feu-ho i utilitzeu la incrustació. Si necessiteu molts fragments petits per a definir les porcions comunes, llavors utilitzeu <command
>&lt;snippets&gt;</command
>. Una manera final de veure-ho: si tots els connectors proporcionen funcionalitats <emphasis
>molt</emphasis
> similars, les inclusions i les insercions són probablement una bona idea. Si simplement comparteixen un o dos «mòduls», probablement la incrustació és millor. </para>
</sect1>
</chapter>

<chapter id="specialized_plugins">
<title
>Conceptes per a utilitzar en connectors especialitzats</title>
<para
>Aquest capítol conté informació sobre alguns temes que només són útils per a certes classes de connectors. </para>

<sect1 id="specialized_plugins_plots">
	<title
>Connectors que produeixen un diagrama</title>
	<para
>Crear un diagrama des d'un connector és fàcil de fer. No obstant això, hi ha alguns paranys subtils que cal evitar, i també algunes funcionalitats genèriques que cal tenir en compte. Aquesta secció mostra els conceptes bàsics i conclou amb un exemple canònic que haureu de seguir sempre que creeu connectors de diagrama. </para>
	<sect2 id="rk_graph_on">
		<title
>Dibuixar un diagrama a la finestra de sortida</title>
		<para
>Per a dibuixar un diagrama a la finestra de sortida, utilitzeu <function
>rk.graph.on()</function
> directament abans de crear el diagrama, i <function
>rk.graph.off()</function
>, directament després. Això és similar, &pex;, cridar <function
>postscript()</function
> i <function
>dev.off()</function
> en una sessió normal de l'&R;. </para>
		<para
>Tanmateix, és important que <emphasis
>sempre</emphasis
> es cridi <function
>rk.graph.off()</function
> després de cridar <function
>rk.graph.on()</function
>. En cas contrari, el fitxer de sortida es deixarà en un estat trencat. Per a assegurar-vos que <function
>rk.graph.off()</function
> realment sigui cridat, haureu d'ajustar <emphasis
>totes les ordres</emphasis
> &R; entre les dues crides en l'expressió <function
>try()</function
>. Mai ho havíeu escoltat? No us preocupeu, és fàcil. Tot el que heu de fer és seguir el patró mostrat a l'<link linkend="plot_plugin_example"
>exemple</link
> a continuació. </para>
	</sect2>
	<sect2 id="preview_plots">
		<title
>Afegir la funcionalitat de vista prèvia</title>
		<note
><para
>Aquesta secció analitza l'addició de funcionalitats de vista prèvia als connectors que produeixen diagrames. Hi ha seccions separades sobre <link linkend="preview_output"
>previsualitzacions de sortida (&HTML;)</link
>, <link linkend="preview_data"
>previsualitzacions de dades (importades)</link
>, i <link linkend="preview_custom"
>previsualitzacions personalitzades</link
>. No obstant això, es recomana llegir primer aquesta secció, ja que l'enfocament és similar en cada cas.</para
></note>
		<para
>Una característica molt útil per a tots els connectors que generen un diagrama/gràfic és proporcionar una previsualització d'actualització automàtica. Per a fer-ho, necessitareu dues coses: Afegir una casella de selecció <command
>&lt;preview&gt;</command
> a la <link linkend="mainxml"
>definició de la IGU</link
>, i ajustar el <link linkend="jstemplate"
>codi generat</link
> per a la vista prèvia. </para>
		<para
>Afegir una casella de selecció de <command
>&lt;preview&gt;</command
> és senzill. Col·loqueu el següent en algun lloc de la &IGU;. S'encarregarà de tota la màgia entre bastidors de crear un dispositiu de vista prèvia, actualitzar la vista prèvia sempre que la configuració hagi canviat, &etc; Exemple: </para>
		<note
><para
>Des de la versió 0.6.5 del &rkward; els elements de vista prèvia <command
>&lt;preview&gt;</command
> són casos especials en els diàlegs dels connectors (no assistents): es col·locaran a la columna de botons, independentment d'on estiguin exactament definits a la interfície d'usuari. Continua sent una bona idea definir-les en un lloc assenyat de la disposició, per a la compatibilitat cap endarrere. </para
></note>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;dialog [...]&gt;
                        [...]
                        &lt;preview id="preview"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>I això és per la definició de la &IGU;. </para>
		<para
>Ajustar la plantilla JS és només una mica més de feina, aquí haureu d'assegurar-vos que només es genera el diagrama en si, i es mostra en un dispositiu en pantalla, en lloc d'anar dirigit a la sortida. És a dir, sense impressió de capçaleres, <function
>rk.graphics.on()</function
>, o crides similars. Per a ajudar-vos en això, el &rkward; cridarà les funcions <function
>preprocess()</function
>, <function
>calculate()</function
> i <function
>printout()</function
> amb un paràmetre addicional que s'estableix a <parameter
>true</parameter
> en generar codi per a una vista prèvia. (El paràmetre s'omet en generar el codi final. En el javascript això avaluarà <parameter
>false</parameter
> quan s'utilitzi dins d'una sentència <function
>if</function
>.) Vegeu l'<link linkend="plot_plugin_example"
>exemple</link
> a continuació per al patró típic que utilitzareu. </para>
		<para
>Alternativament, si necessiteu més control que aquest, podeu afegir una funció nova anomenada <function
>preview()</function
> a la plantilla JS, i generar el codi requerit per a una vista prèvia, allà (probablement, almenys en part, de nou cridant <function
>calculate()</function
>, etc.). </para>
	</sect2>
	<sect2 id="plot_options">
		<title
>Opcions genèriques de diagrama</title>
		<para
>Us haureu adonat que la majoria dels connectors de traçat al &rkward; proporcionen una àmplia varietat d'opcions genèriques, &pex;, per a personalitzar els títols dels eixos o els marges de les xifres. Afegir aquestes opcions al vostre connector és fàcil. Són proporcionats per un connector <link linkend="embedding"
>incrustable</link
> anomenat <command
>rkward::plot_options</command
>. Incrusteu això a la interfície d'usuari del connector com aquí: </para>
		<programlisting
>&lt;document&gt;
                [...]
                &lt;logic [...]&gt;
                        &lt;connect client="plotoptions.xvar" governor="x.available"/&gt;
                        &lt;set id="plotoptions.allow_type" to="true"/&gt;
                        &lt;set id="plotoptions.allow_ylim" to="true"/&gt;
                        &lt;set id="plotoptions.allow_xlim" to="false"/&gt;
                        &lt;set id="plotoptions.allow_log" to="false"/&gt;
                        &lt;set id="plotoptions.allow_grid" to="true"/&gt;
                &lt;/logic&gt;
                &lt;dialog [...]&gt;
                        [...]
                        &lt;embed id="plotoptions" component="rkward::plot_options" as_button="true" label="Plot Options"/&gt;
                        [...]
                &lt;/dialog&gt;
                [...]
        &lt;/document&gt;
                </programlisting>
		<para
>Això afegirà un botó a la interfície d'usuari per a obrir una finestra amb les opcions del diagrama. La secció lògica és només un exemple. Permet un cert control sobre el connector d'opcions del diagrama. Llegiu-ne més a la pàgina d'ajuda del connector «plot_options» (enllaçada des de la pàgina d'ajuda de qualsevol connector que proporcioni les opcions genèriques). </para>
		<para
>A continuació, haureu d'assegurar-vos que el codi corresponent a les opcions del diagrama s'afegeix al codi generat per al diagrama. Per a fer-ho, obteniu les propietats <command
>code.preprocess</command
>, <command
>code.printout</command
>, i <command
>code.calculate</command
> des del connector incrustat d'opcions del diagrama i inseriu-les al codi tal com es mostra a l'<link linkend="plot_plugin_example"
>exemple</link
> a continuació. </para>
	</sect2>
	<sect2 id="plot_plugin_example">
		<title
>Un exemple canònic</title>
		<para
>Aquest és un exemple de fitxer .JS que hauríeu d'utilitzar com a plantilla, sempre que creeu un connector de traçat: </para>
		<programlisting
>function preprocess () {
    // the "somepackage" is needed to create the plot
    echo ("require (somepackage)\n");
  }
  
  function printout (is_preview) {
    // If "is_preview" is set to false/undefined, it generates the full code, including headers.
    // If "is_preview" is set to true, only the essentials will be generated.

    if (!is_preview) {
      echo ('rk.header (' + i18n ("An example plot") + ')\n\n');
      echo ('rk.graph.on ()\n');
    }
    // only the following section will be generated for is_preview==true

    // remember: everything between rk.graph.on() and rk.graph.off() should be wrapped inside a try() statement:
    echo ('try ({\n');
    // insert any option-setting code that should be run before the actual plotting commands.
    // The code itself is provided by the embedded plot options plugin. printIndentedUnlessEmpty() takes care of pretty formatting.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.preprocess"), '', '\n');

    // create the actual plot. plotoptions.code.printout provides the part of the generic plot options
    // that have to be added to the plotting call, itself.
    echo ('plot (5, 5' + getString ("plotoptions.code.printout") + ')\n');

    // insert any option-setting code that should be run after the actual plot.
    printIndentedUnlessEmpty ('\t', getString ("plotoptions.code.calculate"), '\n');
    echo ('})'\n);  // the closure of the try() statement

    if (!is_preview) {
      echo ('rk.graph.off ()\n');
    }
  }
                </programlisting>
	</sect2>
</sect1>
<sect1>
	<title
>Vistes prèvies de dades, sortida i altres resultats</title>
	<sect2 id="preview_output">
		<title
>Vistes prèvies de sortida (HTML)</title>
		<note
><para
>Aquesta secció tracta d'afegir funcionalitats de vista prèvia als connectors que creen impressions de sortida/HTML. Es recomana que llegiu la secció separada de les <link linkend="preview_plots"
>previsualitzacions de diagrama</link
> abans d'aquesta secció.</para
></note>
		<para
>Crear una vista prèvia de la sortida HTML és gairebé el mateix procediment que crear una vista prèvia del gràfic. En aquest cas, simplement assegureu-vos que <command
>preview()</command
> genera les ordres <command
>rk.print()/rk.results()</command
> pertinents. No obstant això, en general és una bona idea ometre les sentències de capçalera en la previsualització. Aquí hi ha un exemple reduït: </para>
		<programlisting
>&lt;!-- In the plugin's XML file --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" mode="output"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Tingueu en compte l'especificació del <parameter
>mode="output"</parameter
> en l'element <command
>&lt;preview&gt;</command
>. </para>
		<programlisting
>// In the plugin's JS file
        function preview () {
                // generates the code used for preview
                printout (true);
        }

        function printout (is_preview) {
                // only generates a header if is_preview==false
                if (!is_preview) {
                        new Header ("This is a caption").print ();
                }
                echo ('rk.print (result)');
        }
                </programlisting>
	</sect2>
	<sect2 id="preview_data">
		<title
>Vistes prèvies de dades (importades)</title>
		<note
><para
>Aquesta secció analitza l'addició de funcionalitats de vista prèvia als connectors que creen (importen) dades. Es recomana que llegiu la secció separada a les <link linkend="preview_plots"
>previsualitzacions de diagrama</link
>, abans d'aquesta secció.</para
></note>
		<para
>Crear una vista prèvia de les dades importades (qualsevol tipus de dades que <command
>rk.edit()</command
> pot gestionar), és molt similar a crear una <link linkend="preview_plots"
>vista prèvia de diagrama</link
>. L'exemple reduït següent hauria d'ajudar a il·lustrar com crear una vista prèvia de dades: </para>
		<programlisting
>&lt;!-- In the plugin's XML file --&gt;>
        &lt;dialog label="Import CSV data" &gt;
                &lt;browser id="file" type="file" label="File name"/&gt;
                &lt;!-- [...] --&gt;>
                &lt;preview id="preview" active="true" mode="data"/&gt;
        &lt;/dialog&gt;
>
                </programlisting>
		<para
>Tingueu en compte que l'element <command
>&lt;preview&gt;</command
> especifica <parameter
>mode="data"</parameter
> aquesta vegada. <parameter
>active="true"</parameter
> simplement activa la vista prèvia predeterminada. </para>
		<programlisting
>// In the plugin's JS file
        function preview () {
                // generates the code used for preview
                calculate (true);
        }

        function calculate (is_preview) {
                echo ('imported &lt;- read.csv (file="' + getString ("file") /* [+ options] */);
                if (is_preview) {
                        echo ('preview_data &lt;- imported\n');
                } else {
                        echo ('.GlobalEnv$' + getString ("name") + ' &gt;- imported\n');
                }
        }

        function printout () {
                // [...]
        }
                </programlisting>
		<para
>De nou, la funció <command
>preview()</command
> genera gairebé el mateix codi &R; que la funció <command
>calculate()</command
>, de manera que creem una funció auxiliar <command
>doCalcuate()</command
> per a factoritzar les parts comunes. El més important a tenir en compte és que haureu d'assignar les dades importades a un objecte anomenat <parameter
>preview_data</parameter
> (dins de l'entorn actual: local). <emphasis
>Tota la resta passarà automàticament</emphasis
> (aproximadament, el &rkward; cridarà <command
>rk.edit(preview_data)</command
>, embolcallat dins d'una crida a <command
>.rk.with.window.hints()</command
>). </para>
		<note
><para
>Mentre que les vistes prèvies són una característica bona, consumeixen recursos. En el cas de les previsualitzacions de dades pot haver-hi casos on les previsualitzacions poden causar problemes de rendiment significatius. Això podria ser per a la importació de conjunts de dades enormes (que són massa grans per a ser oberts per a l'edició a la finestra de l'editor del &rkward;), però també es podrien importar conjunts de dades "normals", creant un gran nombre de files o columnes. <emphasis
>És molt recomanable que limiteu les <parameter
>preview_data</parameter
></emphasis
> a una dimensió que proporciona una vista prèvia útil, sense el perill de crear problemes de rendiment notables (&pex;, 50 files per 50 columnes haurien de ser més que suficients en la majoria dels casos). </para
></note>
	</sect2>
	<sect2 id="preview_custom">
		<title
>Vistes prèvies personalitzades</title>
		<para
>L'element <command
>&lt;preview&gt;</command
> es pot utilitzar per a crear vistes prèvies per a qualsevol tipus de finestra de "document" que es pot adjuntar al lloc de treball del &rkward;. A més de <link linkend="preview_plots"
>diagrames</link
> i <link linkend="preview_data"
>finestres de dades</link
>, això inclou fitxers HTML, scripts &R; i finestres de resum d'objectes. Per a aquests últims, haureu d'utilitzar <command
>&lt;preview mode="custom"&gt;</command
>. </para>
		<para
>Si heu llegit les seccions que descriuen la vista prèvia del diagrama i les vistes prèvies de les dades, hauríeu de tenir una idea general sobre el procediment, però les vistes prèvies «personalitzades» requereixen una mica més de treball manual entre bastidors. La funció &R; més important que cal mirar és <command
>rk.assign.preview.data()</command
>, aquí. El llistat curt següent mostra com podria ser el codi &R; generat (previsualització) per a un connector que creï una sortida de fitxer de text: </para>
		<programlisting
>## Per a ser generat en la secció de codi preview() d'un connector
        pdata &lt;- rk.get.preview.data("SOMEID")
        if (is.null (pdata)) {
                outfile &lt;- rk.get.tempfile.name(prefix="preview", extension=".txt")
                pdata &lt;- list(filename=outfile, on.delete=function (id) {
                        unlink(rk.get.preview.data(id)$filename)
                })
                rk.assign.preview.data("SOMEID", pdata)
        }
        try ({
                cat ("This is a test", pdata$filename)
                rk.edit.files(file=pdata$filename)
        })
                </programlisting>
		<para
>Aquí hauríeu d'obtenir el valor <parameter
>SOMEID</parameter
> a partir de la propietat <parameter
>id</parameter
> de l'element <command
>&lt;preview&gt;</command
>. P. ex., s'utilitza <command
>getString ("preview.id")</command
> al fitxer .js del connector. </para>
	</sect2>
</sect1>

<sect1 id="contextualized_plugins">
	<title
>Connectors dependents de context</title>
	<para
>Fins ara hem assumit que tots els connectors sempre tenen sentit, i tots es col·loquen al menú principal. No obstant això, alguns connectors només tenen sentit (o addicionalment) en un context determinat. P. ex., un connector per a exportar el contingut d'un dispositiu gràfic X11 de l'&R; és òbviament el més útil quan es col·loca en el menú d'un dispositiu X11, no a la barra de menús principal. A més, aquest connector hauria de conèixer el número de dispositiu en què hauria d'operar, sense haver de preguntar-ho a l'usuari. </para>
	<para
>Anomenem aquests connectors dependents del context. Per tant, en el fitxer <link linkend="pluginmap"
>&pluginmap;</link
> no es col·loquen (o no només) en el <command
>&lt;hierarchy&gt;</command
> principal, sinó en un element <command
>&lt;context&gt;</command
>. Fins ara només s'admeten dos contextos diferents (després en vindran més): x11 i importació de fitxers. Ens ocuparem d'ells. Fins i tot si només esteu interessat en el context d'importació, llegiu també la secció sobre el context x11, ja que aquest és una mica més elaborat. </para>

	<sect2 id="context_x11">
		<title
>Context de dispositiu X11</title>
		<para
>Per a utilitzar un connector en el context d'un dispositiu x11, que se situï a la barra de menús de la finestra que obteniu quan crideu <function
>x11()</function
> a la consola, primer declareu-lo com de costum al fitxer <link linkend="pluginmap"
>&pluginmap;</link
>: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_x11_plugin" file="my_x11_plugin.xml" label="An X11 context plugin"/&gt;
                [...]
        &lt;/components&gt;
                </programlisting>
		<para
>No obstant això, no cal que el definiu a la jerarquia (podeu, si també té sentit com a connector de nivell superior): </para>
		<programlisting
>&lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
                </programlisting>
		<para
>En lloc d'això, afegiu una definició del context «x11», i afegiu-la als menús: </para>
		<programlisting
>&lt;context id="x11"&gt;
                [...]
                &lt;menu id="edit"&gt;
                        [...]
                        &lt;entry id="my_x11_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
&lt;/document&gt;
                </programlisting>
		<para
>A la <link linkend="logic"
>secció lògica de l'XML del connector</link
>, ara podeu declarar dues propietats <command
>&lt;external&gt;</command
>: <parameter
>devnum</parameter
> i <parameter
>context</parameter
>. El <parameter
>context</parameter
> (si es declara) s'establirà a <replaceable
>"x11"</replaceable
> quan s'invoqui el connector en aquest context. <parameter
>devnum</parameter
> s'establirà al número del dispositiu gràfic on operar. I això és tot. </para>
	</sect2>

	<sect2 id="context_import">
		<title
>Importar el context de les dades</title>
		<para
>Abans de llegir aquesta secció, assegureu-vos de llegir la secció <link linkend="context_x11"
>context del dispositiu X11</link
>, ja que explica els conceptes bàsics. </para>
		<para
>El context <replaceable
>"import"</replaceable
> s'utilitza per a declarar els connectors del filtre de fitxers d'importació. Simplement col·loqueu-los en un context amb <parameter
>id=</parameter
><replaceable
>"import"</replaceable
> al fitxer &pluginmap;. No obstant això, hi ha un aspecte addicional en declarar aquests connectors: per tal d'oferir un diàleg de selecció de fitxers unificat per a tots els tipus de fitxers admesos, cal declarar un bit addicional d'informació sobre el component: </para>
		<programlisting
>&lt;document [...]&gt;
        &lt;components&gt;
                [...]
                &lt;component id="my_xyz_import_plugin" file="my_xyz_import_plugin.xml" label="Import XYZ files"&gt;
                        &lt;attribute id="format" value="*.xyz *.zyx" label="XYZ data files"/&gt;
                &lt;/component&gt;
                [...]
        &lt;/components&gt;
        &lt;hierarchy&gt;
                [...]
        &lt;/hierarchy&gt;
        &lt;context id="import"&gt;
                [...]
                &lt;menu id="import"&gt;
                        [...]
                        &lt;entry id="my_xyz_import_plugin"/&gt;
                &lt;/menu&gt;
        &lt;/context&gt;
        [...]
&lt;/document&gt;
                </programlisting>
		<para
>La línia d'atribut simplement diu que les extensions associades del nom de fitxer per als fitxers XYZ són <literal role="extension"
>*.xyz</literal
> o <literal role="extension"
>*.zyx</literal
>, i que el filtre s'ha d'etiquetar amb «fitxers de dades XYZ» en el diàleg de selecció de fitxers. </para>
		<para
>Podeu declarar dues propietats <command
>&lt;external&gt;</command
> al connector. <parameter
>filename</parameter
> establirà al nom de fitxer seleccionat, i <parameter
>context</parameter
> s'establirà com <replaceable
>"import"</replaceable
>. </para>
	</sect2>
</sect1>

<sect1 id="querying_r_for_info">
<title
>Consultar l'&R; per a obtenir informació</title>
	<para
>En alguns casos, és possible que vulgueu obtenir més informació de l'&R;, que es presentarà a la interfície d'usuari del vostre connector. Per exemple, podeu oferir una selecció dels nivells d'un factor que l'usuari ha seleccionat per a l'anàlisi. Des de la versió 0.6.2 del &rkward; és possible fer-ho. Abans de començar, és important que tingueu present algunes advertències:</para>
	<para
>El codi R que s'executa des de dins de la lògica de la interfície d'usuari del connector s'avalua en el bucle d'esdeveniments de l'R, el que significa que es poden executar <emphasis
>mentre</emphasis
> s'estan executant altres càlculs. Això és per a assegurar-vos que la interfície d'usuari del vostre connector es pugui utilitzar, fins i tot mentre l'&R; estigui ocupat fent altres coses. Tanmateix, això fa que sigui molt important que el seu codi no tingui efectes secundaris. En particular:</para>
	<itemizedlist>
		<listitem
><para
><emphasis
>No</emphasis
> fa cap assignació a «.GlobalEnv» o qualsevol altre entorn no local.</para
></listitem>
		<listitem
><para
><emphasis
>No</emphasis
> imprimeix res al fitxer de sortida.</para
></listitem>
		<listitem
><para
><emphasis
>No</emphasis
> traça res en la pantalla.</para
></listitem>
		<listitem
><para
>En general, <emphasis
>no</emphasis
> faci res que tingui efectes secundaris. El vostre codi pot <emphasis
>llegir informació</emphasis
>, no «<emphasis
>fer</emphasis
>» altres coses.</para
></listitem>
	</itemizedlist>
	<para
>Amb això en ment, aquí està el patró general. Ho utilitzareu dins d'una secció <link linkend="logic_scripted"
>lògica IU amb scripts</link
>:</para>
	<programlisting
>&lt;script&gt;&lt;![CDATA[
                                last_command_id = -1;
                                gui.addChangeCommand ("variable", "update ()");
                                update = function () {
                                        gui.setValue ("selector.enabled", 0);
                                        variable = gui.getValue ("variable");
                                        if (variable == "") return;

                                        last_command_id = doRCommand ('levels (' + variable + ')', "commandFinished");
                                }

                                commandFinished = function (result, id) {
                                        if (id != last_command_id) return;  // another result is about to arrive
                                        if (typeof (result) == "undefined") {
                                                gui.setListValue ("selector.available", Array ("ERROR"));
                                                return;
                                        }
                                        gui.setValue ("selector.enabled", 1);
                                        gui.setListValue ("selector.available", result);
                                }
                ]]&gt;&lt;/script&gt;
        </programlisting>
	<para
>Aquí, <parameter
>variable</parameter
> és una propietat que conté un nom d'objecte (&pex;, dins d'un <command
>&lt;varslot&gt;</command
>). Sempre que això canviï, voldreu actualitzar la visualització dels nivells dins del <command
>&lt;valueselector&gt;</command
>, anomenat <parameter
>selector</parameter
>. La funció clau aquí és <command
>doRCommand()</command
>, que pren com a primer paràmetre la cadena d'ordre a executar, i com a segon paràmetre el nom d'una funció a cridar, quan l'ordre hagi finalitzat. Tingueu en compte que l'ordre s'està executant asíncronament, i això fa les coses una mica més complexes. Per a una cosa que voleu estar segur, el <command
>&lt;valueselector&gt;</command
> roman desactivat, mentre que no contingui informació actualitzada. Una altra cosa és que podríeu haver posat a la cua més d'una ordre, abans d'obtenir els primers resultats. Aquesta és la raó per la qual cada ordre té una "id", i la guardem en <parameter
>last_command_id</parameter
> per a una referència posterior.</para>
	  <para
>Quan es fa l'ordre, es crida la crida de retorn especificada (<parameter
>commandFinished</parameter
>, en aquest cas) amb dos paràmetres: el resultat en si, i l'identificador de l'ordre corresponent. El resultat serà d'un tipus similar a la representació en &R;, &ead;, una matriu numèrica, si el resultat és numèric, &etc; Fins i tot pot ser una <command
>list()</command
> de l'&R;, però en aquest cas es representarà com un <command
>Array()</command
> JS sense noms.</para>
	  <para
>Cal tenir en compte que fins i tot aquest exemple és una mica simplificat. En realitat, haureu de prendre precaucions addicionals, &pex;, per a evitar posar una quantitat extrema de nivells al selector. La bona notícia és que probablement no cal fer tot això vós mateix. L'exemple anterior es pren del connector <command
>rkward::level_select</command
>, per exemple, que simplement podeu <link linkend="embedding"
>incrustar</link
> en el vostre propi connector. Fins i tot us permet especificar una expressió diferent per a executar en lloc de <command
>levels()</command
>.</para>
</sect1>

<sect1 id="current_object">
<title
>Referenciar l'objecte actual o el fitxer actual</title>
	<para
>Per a molts connectors és desitjable treballar en l'objecte «actual». Per exemple, un connector «d'ordenació» podria preseleccionar el «data.frame» que s'està editant actualment per a l'ordenació. El nom de l'objecte actual està disponible per als connectors com una propietat predefinida anomenada <parameter
>current_object</parameter
>. Podeu connectar-vos a aquesta propietat de la manera habitual. Si no hi ha cap objecte actual, la propietat equival a una cadena buida. De la mateixa manera, l'&URL; del fitxer de script actual és accessible com una propietat predefinida anomenada <parameter
>current_filename</parameter
>. Aquesta propietat està buida si no s'està editant cap fitxer de script, o el fitxer de script encara no s'ha desat. </para>
	<para
>Actualment, el <parameter
>current_object</parameter
> només pot ser de classe <function
>data.frame</function
>, però no confieu en això, ja que això s'ampliarà a altres tipus de dades en el futur. Si només teniu interès en els objectes <function
>data.frame</function
>, connecteu amb la propietat <parameter
>current_dataframe</parameter
> en el seu lloc. Alternativament, podeu forçar els requisits de tipus utilitzant restriccions apropiades a <command
>&lt;varslot&gt;</command
>, o utilitzant la <link linkend="logic_scripted"
>creació de scripts lògics d'&IGU;</link
>. </para>
</sect1>

<sect1 id="optionset">
	<title
>Repetir (un conjunt d') opcions</title>
	<para
>A vegades voleu repetir un conjunt d'opcions per a un nombre arbitrari d'elements. Per exemple, suposeu que voleu implementar un connector per a ordenar un «data.frame». És possible que vulgueu permetre l'ordenació per un nombre arbitrari de columnes (en cas d'enllaços entre les primeres columnes). Això es podria realitzar simplement permetent a l'usuari seleccionar diverses variables en un <command
>&lt;varslot&gt;</command
> amb <parameter
>multi="true"</parameter
>. Però si voleu ampliar-ho, &pex;, permetent a l'usuari especificar per a cada variable si s'ha de convertir a caràcter/numèric, o si l'ordenació ha de ser ascendent o descendent, necessitareu més flexibilitat. Altres exemples serien dibuixar diverses línies en un diagrama (permetent seleccionar objecte, estil de línia, color de línia, &etc; per a cada línia), o especificar un mapatge per a la recodificació des d'un conjunt de valors antics a valors nous. </para>
	<para
>Introduïu l'<command
>&lt;optionset&gt;</command
>. Mirem un exemple senzill, primer: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        &lt;row&gt;
                                &lt;input id="firstname" label="Given name(s)" size="small"&gt;
                                &lt;input id="lastname" label="Family name" size="small"&gt;
                                &lt;radio id="gender" label="Gender"&gt;
                                        &lt;optioncolumn label="Male" value="m"/&gt;
                                        &lt;optioncolumn label="Female" value="f"/&gt;
                                &lt;/radio&gt;
                        &lt;/row&gt;
                &lt;/content&gt;

                &lt;optioncolumn id="firstnames" label="Given name(s)" connect="firstname.text"&gt;
                &lt;optioncolumn id="lastnames" label="Family name" connect="lastname.text"&gt;
                &lt;optioncolumn id="gender" connect="gender.string"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Aquí, hem creat una interfície d'usuari per a especificar un nombre de persones (&pex;, autors). La interfície d'usuari requereix almenys una entrada (<parameter
>min_rows="1"</parameter
>). Dins de l'element <command
>&lt;optionset&gt;</command
>, comencem especificant el <command
>&lt;content&gt;</command
>, &ead;, els elements que pertanyen al conjunt d'opcions. Estareu familiaritzat amb la majoria d'elements dins del <command
>&lt;content&gt;</command
>. </para
><para
>A continuació, especifiqueu les variables d'interès que voldrem llegir des de l'opció establerta al nostre fitxer JS. Com que ens ocuparem d'un nombre arbitrari d'articles, no podem llegir només <function
>getString ("firstname")</function
> en JS. Més aviat, per a cada valor d'interès, especifiqueu un <command
>&lt;optioncolumn&gt;</command
>. Per a la primera «optioncolumn» a l'exemple, <command
>&lt;connect="firstname.text"&gt;</command
> significa que el contingut de l'element <command
>&lt;input&gt;</command
> "firstname" es llegeix per a cada element. Les <command
>&lt;optioncolumn&gt;</command
> per a la qual es proporciona una <parameter
>label</parameter
>, es mostrarà a la pantalla, en una columna amb aquesta etiqueta. Al JS, ara podem obtenir els noms de tots els autors utilitzant <function
>getList("set.firstname")</function
>, <function
>getList("set.lastnames")</function
> pels cognoms, i <function
>getList("set.gender")</function
> per a una matriu de cadenes "m"/"f". </para>
	<para
>Tingueu en compte que no hi ha restriccions sobre el que podeu col·locar dins d'un <command
>&lt;optionset&gt;</command
>. Fins i tot podeu utilitzar components <link linkend="embedding"
>incrustats</link
>. Igual que amb qualsevol altre element, tot el que heu de fer és recollir les variables de sortida d'interès en una especificació <command
>&lt;optioncolumn&gt;</command
>. En el cas dels connectors incrustats, aquesta és sovint una secció de la propietat "code". P. ex.: </para>
		<programlisting
>&lt;dialog [...]&gt;
        [...]
        &lt;optionset id="set" min_rows="1"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
	<para
>Per descomptat, també podeu utilitzar la lògica <link linkend="logic"
>UI</link
> dins d'un «optionset». Hi ha dues opcions per a fer això: podeu fer-ho fent la connexió (o creació de scripts) a la secció principal <command
>&lt;logic&gt;</command
> del connector, com és habitual. No obstant això, accedireu als elements de la IU a la regió de continguts com (&pex;) «set.contents.firstname.XYZ». Tingueu en compte el prefix "set" (l'<parameter
>id</parameter
> que heu assignat al conjunt i "contents"). Alternativament, podeu afegir una secció <command
>&lt;logic&gt;</command
> separada com a element fill de l'<command
>&lt;optionset&gt;</command
>. En aquest cas, els <parameter
>id</parameter
> s'adreçaran en relació amb la regió de continguts, &pex;, "firstname.XYZ". Només l'element <command
>&lt;script&gt;</command
> no està permès a la secció lògica d'un «optionset». Si voleu utilitzar la creació de scripts, haureu d'utilitzar la secció principal <command
>&lt;logic&gt;</command
> del connector. </para>
	<note>
		<para
>Quan la lògica de creació de scripts en un «optionset», tot el que podeu fer és accedir a la regió de contingut <emphasis
>actual</emphasis
>. Per tant, normalment, només té sentit connectar elements dins de la regió de contingut entre ells. Connectar una propietat fora de l'<command
>&lt;optionset&gt;</command
> a una propietat dins de la regió de contingut, pot ser útil per a la inicialització. No obstant això, modificar la regió de contingut després de la inicialització <emphasis
>no</emphasis
> s'aplicarà als elements que l'usuari ja ha definit. Només a l'element seleccionat actualment en el conjunt. </para>
	</note>
	<sect2 id="optionset_driven">
		<title
>«Driven» «optionsets»</title>
		<para
>Fins ara hem considerat un <command
>&lt;optionset&gt;</command
> que proporciona botons per a afegir/eliminar elements. No obstant això, en alguns casos, és molt més natural seleccionar elements fora de l'<command
>&lt;optionset&gt;</command
>, i proporcionar només opcions per a personalitzar alguns aspectes de cada element en un <command
>&lt;optionset&gt;</command
>. Per exemple, suposeu que voleu permetre a l'usuari traçar diversos objectes dins d'un diagrama. Per a cada objecte, l'usuari hauria de poder especificar el color de la línia. <emphasis
>Podeu</emphasis
> resoldre-ho col·locant un <command
>&lt;varselector&gt;</command
> i <command
>&lt;varslot&gt;</command
> dins de l'àrea <command
>&lt;content&gt;</command
>, permetent a l'usuari seleccionar un element alhora. Tanmateix, significarà menys clics per a l'usuari, si en el seu lloc utilitzeu un <command
>&lt;varslot multi="true"&gt;</command
> <emphasis
>fora</emphasis
> de l'<command
>&lt;optionset&gt;</command
>. A continuació, connectareu aquesta selecció d'objectes a un «optionset» anomenat «driven». Així és com es fa: </para>
		<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;connect client="set.vars" governor="vars.available"/&gt;
                &lt;connect client="set.varnames" governor="vars.available.shortname"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;varselector id="varsel"/&gt;
        &lt;varslot id="vars" label="Objects to plot"/&gt;
        &lt;optionset id="set" keycolumn="var"&gt;
                &lt;content&gt;
                        [...]
                        &lt;embed id="color" component="rkward::color_chooser" label="Line color"/&gt;
                &lt;/content&gt;

                [...]
                &lt;optioncolumn id="vars" external="true"&gt;
                &lt;optioncolumn id="varnames" external="true" label="Variable"&gt;
                &lt;optioncolumn id="color_params" connect="color.code.printout"&gt;
        &lt;/optionset&gt;
        [...]
&lt;/dialog&gt;
                </programlisting>
		<para
>Començarem a veure l'exemple a la part inferior. Tindreu en compte que dues especificacions de <command
>&lt;optioncolumn&gt;</command
> tenen <parameter
>external="true"</parameter
>. Això li indica al &rkward; que estan controlats des de fora de l'<command
>&lt;optionset&gt;</command
>. Aquí, l'únic motiu de l'opció «optioncolumn» «varnames» és proporcionar etiquetes fàcils de llegir a la pantalla de l'«optionset» (està connectat al modificador «shortname» de la propietat que conté els objectes seleccionats). El motiu de «optioncolumn» «vars» és servir com a columna «key», tal com especifica <command
>&lt;optionset keycolumn="vars"...&gt;</command
>. Això vol dir que per a cada entrada en aquesta llista, el conjunt oferirà un conjunt d'opcions, i les opcions estan lligades lògicament a aquestes entrades. Aquesta columna està connectada a la propietat que conté els objectes seleccionats a <command
>&lt;varslot&gt;</command
>. Això és per a cada objecte que hi ha seleccionat, l'<command
>&lt;optionset&gt;</command
> permetrà especificar el color de la línia. </para>
		<note>
			<para
>La columna externa també pot ser connectada amb <parameter
>connect</parameter
> a les propietats dins de la regió <command
>&lt;content&gt;</command
>. No obstant això, és important tenir en compte que les «optioncolumn» declarades <parameter
>external="true"</parameter
> mai no s'han de modificar des de dins de l'<command
>&lt;optionset&gt;</command
>, i les «optioncolumn» declarades <parameter
>external="false"</parameter
> (predeterminat) mai no s'han de modificar des de fora de l'<command
>&lt;optionset&gt;</command
>. </para>
		</note>
	</sect2>
	<sect2 id="optionset_alternatives">
		<title
>Alternatives: quan no s'usen els «optionsets»</title>
		<para
>Els «optionset» són una eina potent, però de vegades poden fer més mal que bé, ja que afegeixen una complexitat considerable, tant des de la perspectiva d'un desenvolupador de connectors, com des de la perspectiva d'un usuari. Per tant, penseu dues vegades, quan les utilitzeu. Aquí teniu un consell: </para>
		<itemizedlist>
			<listitem
><para
>Per alguns casos simples, l'element <command
>&lt;matrix&gt;</command
> pot proporcionar una alternativa útil més senzilla.</para
></listitem>
			<listitem
><para
>No feu que la vostra extensió faci massa. Hem donat l'exemple d'utilitzar un «optionset» per a un connector per a dibuixar diverses línies dins d'un diagrama. Però en general no és una bona idea crear un connector que produeixi diagrames individuals per a cada element en un «optionset». Més aviat, feu que el connector produeixi un diagrama, i l'usuari el pot cridar diverses vegades. </para
></listitem>
			<listitem
><para
>Si no espereu més de dos o tres elements en un conjunt, considereu repetir les opcions manualment.</para
></listitem>
		</itemizedlist>
	</sect2>
</sect1>

</chapter>

<chapter id="chapter_dependencies">
<title
>Gestió de dependències i problemes de compatibilitat</title>
<sect1 id="sect_dependencies_rkward_version"
><title
>Compatibilitat de la versió del &rkward;</title>
	<para
>Fem tot el possible per a assegurar-nos que els connectors desenvolupats per a una versió antiga del &rkward; romandran funcionals en versions posteriors del &rkward;. No obstant això, el contrari no sempre és cert, ja que s'han afegit característiques noves. Com que no tots els usuaris estan executant l'última versió del &rkward;, això vol dir que el vostre connector podria no funcionar per a tothom.</para>
	<para
>Quan tingueu coneixement d'aquests problemes de compatibilitat, haureu d'assegurar-vos de documentar aquest fet en el fitxer &pluginmap;, utilitzant l'element <command
>&lt;dependencies&gt;</command
>. Les <command
>&lt;dependencies&gt;</command
> es poden especificar com un fill directe de l'element &lt;document&gt; del &pluginmap;, o com a element fill de definicions de <command
>&lt;component&gt;</command
> individual. En el primer cas, les dependències s'apliquen a <emphasis
>tots els connectors</emphasis
> del mapa. En l'últim cas només per al <command
>&lt;component&gt;</command
> individual. També podeu barrejar dependències "global" i "specific". En aquest cas, les dependències "globals" s'afegeixen a les del component individual.</para>
	<para
>Mirem un petit exemple:</para>
	<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c" /&gt;
        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
        </programlisting>
	<para
>En aquest exemple, se sap que tots els connectors requereixen almenys la versió 0.5.0c del &rkward;. Un connector, amb <replaceable
>id="myplugin"</replaceable
> es proporciona en dues variants alternatives. La primera versió, reduïda, s'utilitzarà per a les versions del &rkward; abans de la 0.6.1. L'últim utilitza característiques que són noves en el &rkward; 0.6.1, i només s'utilitzaran a partir del &rkward; 0.6.1 i posteriors.</para>
	<para
>Proporcionar variants alternatives com aquesta és una manera molt fàcil d'usar per a fer ús de característiques noves, tot i que encara manté el suport per a versions anteriors del &rkward;. Les versions alternatives haurien de compartir el mateix <parameter
>id</parameter
> (en cas contrari es produiran avisos), i només es poden definir <emphasis
>dins del mateix fitxer</emphasis
> &pluginmap;.</para>
	<para
>El connector que no és compatible amb la versió en execució del &rkward;, i que no ve amb una versió alternativa s'ignorarà amb un avís.</para>
	<note
><para
>En realitat, el &rkward; 0.6.1 és la primera versió per a interpretar les dependències i per a informar dels errors de dependències. Per tant, contràriament al que l'exemple pot suggerir, especificar versions anteriors en les dependències no tindrà cap efecte directe (però pot ser una bona idea per a propòsits de documentació).</para
></note>
	<para
><emphasis
>De vegades</emphasis
> fins i tot serà possible gestionar els problemes d'incompatibilitat de versions <emphasis
>dins</emphasis
> d'un únic fitxer &pluginmap;, utilitzant l'element <command
>&lt;dependency_check&gt;</command
>, descrit a la secció següent.</para>
</sect1>
<sect1 id="sect_dependencies_r_version"
><title
>Compatibilitat de la versió de l'&R;</title>
	<para
>Similar a <parameter
>rkward_min_version</parameter
> i <parameter
>rkward_max_version</parameter
>, l'element <command
>&lt;dependencies&gt;</command
> permet l'especificació dels atributs <parameter
>R_min_version</parameter
> i <parameter
>R_max_version</parameter
>. No obstant això, hi ha les diferències següents:</para>
	<itemizedlist>
		<listitem
><para
>Els connectors que no compleixen el requisit de la versió de l'&R; <emphasis
>no</emphasis
> s'ometen actualment en llegir un fitxer &pluginmap;. L'usuari encara pot cridar al connector, i no veurà cap avís immediat (en versions futures, probablement es mostrarà un missatge d'avís)</para
></listitem>
		<listitem
><para
>En conseqüència, <emphasis
>no</emphasis
> és possible definir versions alternatives d'un connector depenent de la versió en execució de l'&R;.</para
></listitem>
		<listitem
><para
>No obstant això, sovint és fàcil aconseguir compatibilitat cap enrere com es mostra a continuació. Si esteu al corrent dels problemes de compatibilitat de l'&R;, considereu utilitzar aquest mètode, en lloc de definir una dependència d'una versió particular de l'&R;.</para
></listitem>
	</itemizedlist>
	<para
>En molts casos, és possible proporcionar fàcilment una funcionalitat reduïda, si una característica determinada no està disponible en la versió en execució de l'&R;. Considereu l'exemple curt següent d'un fitxer <literal role="extension"
>.xml</literal
>:</para>
	<programlisting
>&lt;dialog [...]&gt;
        &lt;logic&gt;
                &lt;dependency_check id="ris210" R_min_version="2.10.0"/&gt;
                &lt;connect client="compression.xz.enabled" governor="ris210"/&gt;
        &lt;/logic&gt;
        [...]
        &lt;radio id="compression" label="Compression method"&gt;
                &lt;option label="None" value=""&gt;
                &lt;option label="gzip" value="gzip"&gt;
                &lt;option id="xz" label="xz" value="xz"&gt;
        &lt;/radio&gt;
        [...]
&lt;/dialog&gt;
        </programlisting>
	<para
>En aquest exemple, l'opció de compressió "xz" simplement es desactivarà quan la versió &R; en temps d'execució sigui anterior a 2.10.0 (que no admet la compressió «xz»). L'element <command
>&lt;dependency_check&gt;</command
> admet els mateixos atributs que l'element <command
>&lt;dependencies&gt;</command
> en fitxers &pluginmap;. Crea una propietat booleana, el qual és cert, si es compleixen les dependències especificades, fals en cas contrari.</para>
</sect1>
<sect1 id="sect_dependencies_r_packages"
><title
>Dependències de paquets de l'&R;</title>
<para
>Es poden definir dependències en paquets específics de l'&R;, però a partir del &rkward; 0.6.1, aquestes dependències no es marquen, ni s'instal·len/es carreguen automàticament. No obstant això, es mostren en els fitxers d'ajuda del connector. Aquesta és una definició d'exemple:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<note
><para
>Assegureu-vos sempre d'afegir les crides <function
>require()</function
> apropiades, si el connector necessita que es carreguin determinats paquets.</para
></note>
<note
><para
>Si <link linkend="external_plugins"
>distribuïu el vostre &pluginmap; com un paquet &R;</link
>, i tots els connectors depenen d'un paquet en particular, aleshores hauríeu de definir aquesta dependència a nivell del paquet &R;. Definir les dependències als paquets de l'&R; a nivell del mapa de connectors del &rkward; és molt útil, si només alguns dels vostres connectors necessiten la dependència, la dependència no està disponible al CRAN, o el vostre &pluginmap; no es distribueix com un paquet de l'&R;.</para
></note>
</sect1>
<sect1 id="sect_dependencies_other_pluginmaps"
><title
>Dependències d'altres &rkward; &pluginmap;s</title>
	<para
>Si els vostres connectors depenen dels connectors definits en un altre &pluginmap; (és a dir, <emphasis
>no</emphasis
> són part del paquet) podreu definir aquesta dependència així:</para>
<programlisting
>&lt;dependencies&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;/dependencies&gt;
</programlisting>
<para
>Actualment, no carregarà, ni instal·larà, ni tan sols avisarà sobre els &pluginmap; que manquen, però almenys es mostrarà informació sobre les dependències (i on obtenir-les) a la pàgina d'ajuda del connector. No cal (i no hauríeu de) declarar dependències en els &pluginmap; que es distribueixen amb la distribució oficial del &rkward;, o en els &pluginmap; que es troben dins del vostre propi paquet. A més, si el &pluginmap; requerit és <link linkend="external_plugins"
>distribuït com un paquet &R;</link
>, declareu una dependència del paquet (com es mostra a la secció anterior), en lloc del mapa.</para>
	<para
>Per a assegurar-vos que els connectors requerits es carreguen realment, utilitzeu l'etiqueta <command
>&lt;require&gt;</command
> (vegeu la <link linkend="pluginmapelements"
>referència</link
> per a més detalls).</para>
</sect1>
<sect1 id="sect_dependencies_example"
><title
>Un exemple</title>
	<para
>Per a aclarir com es poden barrejar les definicions de dependències, aquí hi ha un exemple combinat:</para>
<programlisting
>&lt;document ...&gt;
        &lt;dependencies rkward_min_version="0.5.0c"&gt;
                &lt;package 
                        name="heisenberg"
                        min_version="0.11-2"
                        repository="http://rforge.r-project.org"
                /&gt;
                &lt;package 
                        name="DreamsOfPi"
                        min_version="0.2"
                /&gt;
                &lt;pluginmap 
                        name="heisenberg_plugins"
                        url="http://eternalwondermaths.example.org/hsb"
                /&gt;
        &lt;dependencies&gt;

        &lt;require map="heisenberg::heisenberg_plugins"/&gt;

        &lt;components ...&gt;
                &lt;component id="myplugin" file="reduced_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_max_version="0.6.0z" /&gt;
                &lt;/component&gt;
                &lt;component id="myplugin" file="fancy_version_of_myplugin.xml" ...&gt;
                        &lt;dependencies rkward_min_version="0.6.1" /&gt;
                &lt;/component&gt;
                ...
x        &lt;/components ...&gt;
&lt;/document&gt;
</programlisting>
</sect1>
</chapter>

<chapter id="i18n">
	<title
>Traduccions d'un connector</title>
	<para
>Fins ara hem utilitzat alguns conceptes relatius a les traduccions o «i18n» (abreviatura d'«internacionalització», que té 18 caràcters entre la i i la n) de passada. En aquest capítol donarem una explicació més en profunditat del funcionalment de l'«i18n» per als connectors del &rkward;. Per a la majoria, <emphasis
>no</emphasis
> necessitareu tot això als connectors. No obstant això, pot ser una bona idea llegir aquest capítol íntegrament, ja que entendre aquests conceptes hauria d'ajudar-vos a crear connectors que siguin completament traduïbles, i que permetin una alta qualitat de les traduccions. </para>
	<sect1 id="i18n_general"
><title
>Consideracions generals</title>
		<para
>Un punt important per a entendre les traduccions de programari, en contrast amb les traduccions d'altres materials de text, és que els traductors sovint tindran un temps força llarg per a fer-se una imatge completa de <emphasis
>què</emphasis
> estan traduint. Les traduccions de programari es basen necessàriament en fragments de text força curts: cada etiqueta que doneu a una <command
>&lt;option&gt;</command
> en un <command
>&lt;radio&gt;</command
>, cada cadena que marqueu per a la traducció en una crida de funció <command
>i18n()</command
>, formarà una «unitat de traducció» separada. En essència, cada fragment es presentarà al traductor de forma aïllada. Bé, no un aïllament complet, ja que intentem proporcionar al traductor tant context significatiu com es pugui extreure automàticament. Però en alguns punts els traductors necessitaran un context addicional per a donar sentit a una cadena, especialment quan les cadenes siguin curtes. </para>
	</sect1>
	<sect1 id="i18n_xml"
><title
>«i18n» als fitxers «xml» del &rkward;</title>
		<para
>L'«i18n» funcionarà per als fitxers &XML; del &rkward;. Si esteu escrivint el vostre propi <command
>.pluginmap</command
> (&pex;, per a un <link linkend="external_plugins"
>connector extern</link
>), haureu d'especificar un <replaceable
>po_id</replaceable
> al costat del <replaceable
>id</replaceable
> del «pluginmap». Això defineix el "catàleg de missatges" a utilitzar. En general, això s'ha d'establir igual que el <replaceable
>id</replaceable
> del vostre <command
>.pluginmap</command
>, però si proporcioneu diversos <command
>.pluginmap</command
> relacionats en un sol paquet, probablement voldreu especificar un <replaceable
>po_id</replaceable
> comú als vostres mapes. El fitxer <replaceable
>po_id</replaceable
> d'un fitxer <command
>.pluginmap</command
> és heretat per tots els connectors declarats en ell, llevat que això declari un altre <replaceable
>po_id</replaceable
>. </para>
		<para
>Per a connectors i pàgines d'ajuda, no cal que li indiqueu al &rkward; quines cadenes s'han de traduir, perquè generalment això és evident a partir del seu ús. No obstant això, tal com s'ha explicat anteriorment, cal tenir en compte les cadenes que poden ser ambigües o necessiten alguna explicació per a ser traduïdes correctament. Per a les cadenes que poden tenir significats diferents, proporcioneu un <replaceable
>i18n_context</replaceable
> com aquest: </para>
		<programlisting
>&lt;checkbox id="scale" label="Scale" i18n_context="Show the scale"/&gt;
&lt;checkbox id="scale" label="Scale" i18n_context="Scale the plot"/&gt;
                </programlisting>
		<para
>Proporcionar un <replaceable
>i18n_context</replaceable
> farà que les dues cadenes es tradueixin per separat. En cas contrari, compartirien una única traducció. A més, el context es mostra al traductor. L'atribut <replaceable
>i18n_context</replaceable
> és compatible amb tots els elements que poden tenir cadenes traduïbles, en algun lloc, inclosos els elements que contenen text dins d'ells (&pex; els elements <command
>&lt;text&gt;</command
>). </para>
		<para
>En altres casos, la cadena a traduir té un significat únic no-ambigu, però encara pot necessitar alguna explicació. En aquest cas podeu afegir un comentari que es mostrarà als traductors. Alguns exemples poden incloure: </para>
		<programlisting
>&lt;!-- i18n: No, this is not a typo for screen plot! --&gt;
&lt;component id="scree_plot" label="Scree plot"/&gt;

&lt;!-- i18n: If you can, please make this string short. Having more than some 15 chars
looks really ugly at this point, and the meaning should be mostly self-evident to the
user (selection from a list of values shown next to this element) --&gt;
&lt;valueslot id="selected" label="Pick one"/&gt;
                </programlisting>
		<para
>Tingueu en compte que aquests comentaris han de precedir l'element al qual s'apliquen, i han de començar amb "i18n:" o "TRANSLATORS:". </para>
		<para
>Finalment, en casos rars, és possible que vulgueu excloure determinades cadenes de la traducció. Això pot tenir sentit, per exemple, si oferiu una elecció entre diversos noms de funcions &R; en un control <command
>&lt;radio&gt;</command
>. Llavors no voleu que es tradueixin, però depenent del context, hauríeu de considerar donar una etiqueta descriptiva, en el seu lloc: </para>
		<programlisting
>&lt;radio id="transformation" label="R function to apply"&gt;
  &lt;option id="as.list" noi18n_label="as.list()"/&gt;
  &lt;option id="as.vector" noi18n_label="as.vector()"/&gt;
  [...]
&lt;/radio&gt;
                </programlisting>
		<para
>Tingueu en compte que ometreu l'atribut <replaceable
>label</replaceable
>, llavors, i especifiqueu <replaceable
>noi18n_label</replaceable
>, en el seu lloc. A més, cal tenir en compte que en contrast amb <replaceable
>i18n_context</replaceable
> i els comentaris, utilitzant <replaceable
>noi18n_label</replaceable
> el vostre connector serà incompatible amb les versions del &rkward; anteriors a la 0.6.3. </para>
	</sect1>
	<sect1 id="i18n_js"
><title
>«i18n» als fitxers i seccions dels fitxers «js» del &rkward;</title>
		<para
>A diferència dels fitxers <literal role="extension"
>.xml</literal
>, fer que els fitxers <literal role="extension"
>.js</literal
> d'un connector siguin traduïbles requereix més feina personalitzada. La diferència clau, aquí, és que no hi ha cap manera decent automàtica de saber, si una cadena està pensada per a ser mostrada com una cadena llegible per humans, o un tros de codi. Així que heu de marcar-ho vós mateix. Ja hem donat exemples d'això, tot el temps. Aquí hi ha una descripció més completa de les funcions «i18n» disponibles en el codi js, i alguns consells per a casos més complexos: </para>
<variablelist>
<varlistentry>
	<term
><command
>i18n (msgid, [...])</command
></term>
	<listitem
><para
>La funció més important. Marca la cadena a traduir. La cadena (traduïda o no) es retorna entre cometes amb cometes dobles («»). Es pot utilitzar un nombre arbitrari de variables de substitució a la cadena com es mostra a continuació. L'ús d'aquestes variables de substitució en lloc de concatenar petites subcadenes és molt més fàcil per als traductors:</para>
		<programlisting
>i18n ("Compare objects %1 and %2", getString ('x'), getString ('y'));
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18nc (msgctxt, msgid, [...])</command
></term>
	<listitem
><para
>Igual que <command
>i18n()</command
>, però a més proporciona un context de missatge:</para>
		<programlisting
>i18nc ("proper name, not state of mind", "Mood test");
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18np (msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
>Igual que <command
>i18n()</command
>, però per a missatges que poden ser diferents en forma singular o plural (i alguns idiomes tenen encara més formes numèriques diferenciades). Tingueu en compte que igual que amb <command
>i18n()</command
>, podeu utilitzar un nombre arbitrari de reemplaçaments, però es requereix el primer («%1»), i ha de ser un enter.</para>
		<programlisting
>i18np ("Comparing a single pair", "Comparing %1 distinct pairs", n_pairs);
                </programlisting
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>i18ncp (msgctxt, msgid_singular, msgid_plural, n, [...])</command
></term>
	<listitem
><para
><command
>i18np()</command
> amb context de missatge afegit.</para
></listitem>
</varlistentry>
<varlistentry>
	<term
><command
>comment (comentari, [sagnat])</command
></term>
	<listitem
><para
>Fa un comentari de codi, marcat per a la traducció. A diferència de les altres funcions i18n(), això no està entre cometes, però s'afegeix un «#» a cada línia del comentari.</para>
		<programlisting
>comment ("Transpose the matrix");
                        echo ('x &lt;- t (x)\n');
                </programlisting
></listitem>
</varlistentry>
</variablelist>
	<para
>Per a afegir comentaris als traductors (vegeu <link linkend="i18n_xml"
>a dalt</link
> un debat de les diferències entre el comentari i el context), afegeix un comentari que comenci per "i18n:" o "translators:" directament per sobre de la crida <command
>i18n()</command
> a comentar. P. ex.: </para>
	<programlisting
>// i18n: Spelling is correct: Scree plot.
                echo ('rk.header (' + i18n ("Scree plot") + ')\n');
        </programlisting>

		<sect2 id="i18n_js_quoting"
><title
>«i18n» i cometes</title>
			<para
>En gran part, no us haureu de preocupar pel comportament de l'i18n() respecte a les cometes. Com que, normalment, les cadenes traduïbles són literals de cadenes, citar-les és el correcte i estalvia una mica d'escriptura. A més, en funcions com <command
>makeHeaderCode()/Header()</command
> que solen citar els seus arguments, les cadenes i18n() estan protegides de cites duplicades. Essencialment, això funciona, enviant primer la cadena traduïda a través de <command
>quote()</command
> (per a fer-la citada), després a través de <command
>noquote()</command
> (per a protegir-la de les cites addicionals). Si necessiteu una cadena traduïble que no estigui entre cometes, utilitzeu <command
>i18n(noquote ("El meu missatge"))</command
>. Si necessiteu una cadena traduïble per a ser citada, una segona vegada, envieu-la a través de <command
>quote()</command
>, <emphasis
>dues vegades</emphasis
>. </para>
			<para
>Dit això, generalment no és una bona idea fer parts com els noms de funcions o els noms de variables siguin traduïbles. Per una cosa, &R;, el llenguatge de programació, és inherent en anglès, i no hi ha internacionalització del llenguatge en si. Els comentaris de codi són un tema diferent, però hauríeu d'utilitzar la funció <command
>comment()</command
> per a aquests. En segon lloc, fer que les parts sintàcticament rellevants del codi generat siguin traduïbles significa que les traduccions podrien trencar el vostre connector. Per exemple, si un traductor confiat tradueix una cadena que vol dir un nom de variable en dues paraules diferents amb un espai entremig. </para>
		</sect2>
	</sect1>
	<sect1 id="i18n_workflow"
><title
>Manteniment d'una traducció</title>
		<para
>Ara que heu fet que el vostre connector sigui traduïble, com la traduïu realment? En general, només us heu de preocupar d'això quan desenvolupeu un <link linkend="external_plugins"
>connector extern</link
>. Per als connectors en el repositori principal del &rkward;, es fa tota la màgia. Aquest és el flux de treball bàsic per a connectors externs. Tingueu en compte que necessiteu les eines «gettext» instal·lades: </para>
		<itemizedlist>
			<listitem
><para
>Marqueu totes les cadenes, proporcionant el context i els comentaris segons sigui necessari</para
></listitem>
			<listitem
><para
>Executeu <command
>python3 scripts/update_plugin_messages.py --extract-only /path/to/my.pluginmap</command
>. scripts/update_plugin_messages.py actualment no forma part de les versions de codi font, però es pot trobar en una extracció del repositori de codi font.</para
></listitem>
			<listitem
><para
>Distribuïu el fitxer <command
>rkward__<replaceable
>POID</replaceable
>.pot</command
> als vostres traductors. Per a connectors externs, es recomana col·locar-lo en una subcarpeta "po" a inst/rkward.</para
></listitem>
			<listitem
><para
>El traductor obre el fitxer en una eina de traducció com el <command
>lokalize</command
>. En realitat, encara que no prepareu cap traducció, cal provar aquest pas per vós mateix. Navegueu per les cadenes extretes buscant problemes/ambigüitats.</para
></listitem>
			<listitem
><para
>El traductor desa la traducció com a <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> (on <replaceable
>xx</replaceable
> és el codi de llengua), i us l'envia de retorn.</para
></listitem>
			<listitem
><para
>Copieu <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
> al vostre codi font, al costat de <command
>rkward__<replaceable
>POID</replaceable
>.pot</command
>. Executeu <command
>python3 scripts/update_plugin_messages.py /path/to/my.pluginmap</command
> (Nota: aquesta vegada sense <replaceable
>--extract-only</replaceable
>). Això fusionarà la traducció amb qualsevol canvi de cadena provisional, compilarà la traducció i l'instal·larà a <command
><replaceable
>DIR_OF_PLUGINMAP</replaceable
>/po/<replaceable
>xx</replaceable
>/LC_MESSAGES/rkward__<replaceable
>POID</replaceable
>.mo</command
> (on <replaceable
>xx</replaceable
> és el codi de llengua, de nou).</para
></listitem>
			<listitem
><para
>També hauríeu d'incloure la traducció no compilada (&ead;, <command
>rkward__<replaceable
>POID</replaceable
>.<replaceable
>xx</replaceable
>.po</command
>) a la vostra distribució, al subdirectori «po».</para
></listitem>
			<listitem
><para
>Per a qualsevol actualització del connector, executeu <command
>python3 scripts/update_plugin_messages.py /path/to/my.pluginmap</command
> per a actualitzar el fitxer .pot, però també els fitxers .po existents i els catàlegs de missatges compilats.</para
></listitem>
		</itemizedlist>
	</sect1>
	<sect1 id="i18n_translators"
><title
>Escriure traduccions d'un connector</title>
		<para
>Suposem que coneixeu el vostre ofici com a traductor, o que esteu disposat a estudiar-lo en altres llocs. Unes poques paraules específicament sobre les traduccions dels connectors del &rkward;, però: </para>
		<itemizedlist>
			<listitem
><para
>Els connectors del &rkward; no es poden traduir fins a la versió 0.6.3, i abans no s'havien escrit pensant en l'«i18n». Per tant, trobareu cadenes força ambigües i altres problemes d'«i18n» respecte a altres projectes madurs. No treballeu en silenci per a solucionar-ho, però feu-nos-ho saber (o als mantenidors dels connectors), de manera que puguem solucionar aquests problemes.</para
></listitem>
			<listitem
><para
>Molts connectors del &rkward; es refereixen a termes molt especialitzats, des de la gestió de dades i estadístiques, però també d'altres camps de la ciència. En molts casos, una bona traducció requerirà almenys un coneixement bàsic d'aquests camps. En alguns casos, no <emphasis
>hi ha</emphasis
> una traducció bona per a un terme tècnic, i la millor opció pot ser deixar el terme sense traduir, o incloure el terme anglès entre parèntesis. No us centreu massa a arribar al 100% de les cadenes traduïdes, centreu-vos a proporcionar una bona traducció, fins i tot si això significa ometre algunes cadenes (o fins i tot ometre alguns catàlegs de missatges en el seu conjunt). Altres usuaris poden omplir qualsevol buit en els termes tècnics.</para
></listitem>
		</itemizedlist>
	</sect1>
</chapter>

<chapter id="chapter_about_information">
<title
>Autor, llicència i informació de la versió</title>
<para
>Així que heu escrit un conjunt de connectors, i us esteu preparant per a <link linkend="external_plugins"
>compartir el vostre treball</link
>. Per a assegurar-vos que els usuaris sàpiguen de què tracta el vostre treball, amb quins termes poden utilitzar-lo i distribuir-lo, i a qui han de contactar sobre problemes o idees, heu d'afegir informació <emphasis
>sobre</emphasis
> els vostres connectors. Això es pot fer utilitzant l'element <command
>&lt;about&gt;</command
>. Es pot utilitzar en el &pluginmap; o en els fitxers <literal role="extension"
>.xml</literal
> d'un connector individual (en ambdós casos com a fill directe de l'etiqueta «document»). Quan s'especifica en el &pluginmap; s'aplicarà a tots els connectors. Si s'especifica <command
>&lt;about&gt;</command
> en ambdós llocs, la informació <command
>&lt;about&gt;</command
> del fitxer <literal role="extension"
>.xml</literal
> del connector substituirà la del fitxer &pluginmap;. També podeu afegir un element <command
>&lt;about&gt;</command
> a les pàgines .rkh, que no estan connectades a cap connector, si cal.</para>
<para
>Aquest és un exemple del fitxer &pluginmap; amb només algunes explicacions, a continuació. En cas de dubte, es pot disposar de més informació a la referència.</para>
<programlisting
>&lt;document 
        namespace="rkward"
        id="SquaretheCircle_rkward"
&gt;
        &lt;about 
                name="Square the Circle"
                shortinfo="Squares the circle using Heisenberg compensation."
                version="0.1-3"
                releasedate="2011-09-19"
                url="http://eternalwondermaths.example.org/23/stc.html"
                license="GPL"
                category="Geometry"
        &gt;
                &lt;author 
                        given="E.A."
                        family="Dölle"
                        email="doelle@eternalwondermaths.example.org"
                        role="aut"
                 /&gt;
                &lt;author 
                        given="A."
                        family="Assistant"
                        email="alterego@eternalwondermaths.example.org"
                        role="cre, ctb"
                 /&gt;
        &lt;/about&gt;
        &lt;dependencies&gt;
                ...
        &lt;/dependencies&gt;
        &lt;components&gt;
                ...
        &lt;/components&gt;
        &lt;hierarchy&gt;
                ...
        &lt;/hierarchy&gt;
&lt;/document&gt;
</programlisting>
<para
>La majoria d'això s'explica per si mateix, de manera que no debatrem cada element de l'etiqueta. Però mirem alguns detalls que probablement necessiten un comentari per a una comprensió més fàcil. </para>
<para
>L'element <parameter
>category</parameter
> a <command
>&lt;about&gt;</command
> es pot definir de forma bastant lliure, però hauria de ser significatiu, ja que es creu que s'utilitza per a ordenar connectors en grups. Tots els altres atributs d'aquesta etiqueta d'obertura són obligatoris i s'han d'omplir amb contingut raonable. </para>
<para
>També s'ha d'indicar almenys un <command
>&lt;author&gt;</command
> amb una adreça de correu electrònic vàlida i també s'ha de donar el rol «aut» («author»). En cas que el vostre connector causi problemes o algú vulgui compartir la seva gratitud amb vosaltres, hauria de ser fàcil contactar algú que hi estigui implicat. Per a més informació sobre altres rols vàlids, com «ctb» per als col·laboradors de codi o «cre» per al manteniment de paquets, consulteu la <ulink url="http://stat.ethz.ch/R-manual/R-patched/library/utils/html/person.html"
>documentació de l'R sobre <function
>person()</function
></ulink
>. </para>
<note
><para
>Recordeu que podeu utilitzar <command
>&lt;include&gt;</command
> i <command
>&lt;insert&gt;</command
> per a repetir informació a través de diversos fitxers <literal role="extension"
>.xml</literal
> (&pex;, informació sobre un autor que estava implicat en diversos connectors). <link linkend="sect_similar_plugins"
>Més informació</link
>.</para
></note>
<tip
><para
>No heu d'escriure aquest codi &XML; a mà. Si utilitzeu la funció <function
>rk.plugin.skeleton()</function
> des del <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
> i proporcioneu tota la informació necessària a través de l'opció <parameter
>about</parameter
>, es crearà automàticament un fitxer &pluginmap; amb una secció &lt;about&gt; funcional.</para
></tip>
</chapter>

<chapter id="external_plugins">
<title
>Compartiu el vostre treball amb altres persones</title>
<sect1 id="sect_external_plugins"
><title
>Connectors externs</title>
	<para
>A partir de la versió 0.5.5, el &rkward; proporciona una manera còmoda d'instal·lar connectors addicionals de tercers que no pertanyen al paquet principal. Anomenem aquests «connectors externs». Venen en forma d'un paquet &R; i es poden gestionar directament a través de les característiques habituals de gestió de paquets de l'&R; o el &rkward;. </para>
	<para
>Aquesta secció de la documentació descriu com s'han d'empaquetar els connectors externs de manera que el &rkward; els pugui utilitzar. La creació del connector en si és idèntica a les seccions anteriors. És a dir, probablement hauríeu d'escriure primer un connector funcional i després tornar aquí per a aprendre a distribuir-lo. </para>
	<para
>Com que els connectors externs són una característica relativament jove, els detalls d'això probablement canviaran en futures versions. Us convidem a contribuir amb les vostres idees per a millorar el procés. </para>
	<tip>
		<para
>Aquests documents expliquen els detalls dels connectors externs perquè pugueu aprendre com funcionen. A més a més d'això, cal mirar el <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>, dissenyat per a automatitzar gran part del procés d'escriptura. </para>
	</tip>
</sect1>
<sect1 id="why_external_plugins">
<title
>Per què connectors externs?</title>
	<para
>El nombre de paquets per a ampliar la funcionalitat de l'&R; ja és immens, i està pujant. D'una banda, volem animar-vos a escriure connectors fins i tot per a les tasques més especialitzades que necessiteu resoldre. D'altra banda, l'usuari mitjà no hauria de perdre's en grans arbres de menús plens de termes estadístics desconeguts. Per tant, també semblava raonable mantenir la gestió dels connectors en el &rkward; bastant modular. L'equip del &rkward; manté el seu repositori propi de paquets públics a <ulink url="https://files.kde.org/rkward/R/"
>https://files.kde.org/rkward/R/</ulink
>, designat per a allotjar els vostres connectors externs. </para>
	<para
>Com a regla general, els connectors que semblen servir a un propòsit àmpliament utilitzat (&pex;, t-Tests) haurien de formar part del paquet central, mentre que els que serveixen a un grup bastant limitat de persones amb interessos especials haurien de proporcionar-se com un paquet opcional. Per a vós, com a autor d'un connector, la millor pràctica és començar amb un connector extern. </para>
</sect1>
  
<sect1 id="structure_of_a_plugin_package">
<title
>Estructura d'un paquet de connector</title>
	<para
>Perquè els connectors externs s'instal·lin i funcionin correctament han de seguir algunes directrius estructurals pel que fa a la seva jerarquia de fitxers. </para>
    
	<sect2 id="file_hierarchy"
><title
>Jerarquia de fitxers</title>
		<para
>Donem un cop d'ull a la jerarquia de fitxers prototípica d'un arxiu de connectors elaborat. No heu d'incloure tots aquests directoris i/o fitxers perquè funcioni un connector (llegiu per a saber què és absolutament necessari), considereu això un exemple de «millor pràctica»: </para>
		<programlisting
>plugin_name/
                inst/
                        rkward/
                                plugins/
                                        plugin_name.xml
                                        plugin_name.js
                                        plugin_name.rkh
                                        ...
                                po/
                                        ll/
                                                LC_MESSAGES/
                                                        rkward__plugin_name_rkward.mo
                                        rkward__plugin_name_rkward.ll.po
                                        rkward__plugin_name_rkward.pot
                                tests/
                                        testsuite_name/
                                                RKTestStandards.sometest_name.rkcommands.R
                                                RKTestStandards.sometest_name.rkout
                                                ...
                                        testsuite.R
                                plugin_name.pluginmap
                                ...
        ChangeLog
        README
        AUTHORS
        LICENSE
        DESCRIPTION
                </programlisting>
		<note>
			<para
>En aquest exemple, tots els casos de <token
>plugin_name</token
>, <token
>testsuite_name</token
> i <token
>sometest_name</token
> s'han de substituir pels seus noms correctes, d'acord amb això. A més, <token
>ll</token
> és un marcador de posició per a una abreviatura de l'idioma (&pex;, «de», «en» o «es»). </para>
		</note>
		<tip>
			<para
>No heu de crear aquesta jerarquia de fitxers a mà. Si utilitzeu la funció <function
>rk.plugin.skeleton()</function
> del <link linkend="rkwarddev"
> paquet <application
>rkwarddev</application
></link
>, es crearan automàticament tots els fitxers i directoris necessaris, excepte el directori <filename
>po</filename
> que es crea i gestiona amb l'<link linkend="i18n_workflow"
>script de traducció</link
>. </para>
		</tip>
		<sect3 id="basic_plugin_components">
		<title
>Components bàsics del connector</title>
			<para
>És obligatori incloure almenys tres fitxers: un <link linkend="pluginmap"
>&pluginmap;</link
>, una descripció <link linkend="mainxml"
>.xml</link
> del connector i un fitxer <link linkend="jstemplate"
>.js</link
> del connector. És a dir, fins i tot el directori "plugins" és opcional. Pot ajudar a donar una mica d'ordre als vostres fitxers, especialment si incloeu més d'un connector/diàleg a l'arxiu, que no és cap problema per descomptat. Podeu tenir tants directoris per als fitxers de connectors reals com creieu oportú, només s'han d'assemblar al <link linkend="pluginmap"
>&pluginmap;</link
>, respectivament. També és possible incloure diversos fitxers &pluginmap;, si s'adapta a les vostres necessitats, però llavors hauríeu d'incloure'ls tots a «plugin_name.pluginmap». </para>
			<para
>Cada paquet &R; ha de tenir un fitxer <filename
>DESCRIPTION</filename
> vàlid, el qual també és crucial per al &rkward; reconeixent-lo com a proveïdor de connectors. La major part de la informació que porta també és necessària en el connector <link linkend="chapter_about_information"
>Meta-information</link
> i possiblement <link linkend="chapter_dependencies"
>dependencies</link
>, però en un format diferent (la documentació de l'&R; explica <ulink url="http://cran.r-project.org/doc/manuals/R-exts.html#The-DESCRIPTION-file"
>el fitxer <filename
>DESCRIPTION</filename
> en detall</ulink
>). </para>
			<para
>A més del contingut general d'un fitxer <filename
>DESCRIPTION</filename
>, assegureu-vos també d'incloure la línia «Enhances: rkward». Això farà que el &rkward; escanegi automàticament el paquet cercant connectors si està instal·lat. Un exemple de fitxer <filename
>DESCRIPTION</filename
> té aquest aspecte: </para>
			<programlisting
>Package: SquaretheCircle
        Type: Package
        Title: Square the circle
        Version: 0.1-3
        Date: 2011-09-19
        Author: E.A. Dölle &lt;doelle@eternalwondermaths.example.org&gt;
        Maintainer: A. Assistant &lt;alterego@eternalwondermaths.example.org&gt;
        Enhances: rkward
        Description: Squares the circle using Heisenberg compensation.
        License: GPL
        LazyLoad: yes
        URL: http://eternalwondermaths.example.org/23/stc.html
        Authors@R: c(person(given="E.A.", family="Dölle", role="aut",
                        email="doelle@eternalwondermaths.example.org"),
                        person(given="A.", family="Assistant", role=c("cre",
                        "ctb"), email="alterego@eternalwondermaths.example.org"))
                        </programlisting>
			<tip>
				<para
>No heu d'escriure aquest fitxer a mà. Si utilitzeu la funció <function
>rk.plugin.skeleton()</function
> del <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
> i proporcioneu tota la informació necessària a través de l'opció «about», es crearà automàticament un fitxer <filename
>DESCRIPTION</filename
> que funciona. </para>
			</tip>
		</sect3>
		<sect3 id="additional_information">
		<title
>Informació addicional (opcional)</title>
			<para
><filename
>ChangeLog</filename
>, <filename
>README</filename
>, <filename
>AUTHORS</filename
>, <filename
>LICENSE</filename
> haurien de ser autoexplicatius i són totalment opcionals. En realitat, no seran interpretats pel &rkward;, de manera que estan més aviat destinats a portar informació addicional que podria ser rellevant, &pex;, per als distribuïdors. La majoria del seu contingut rellevant (crèdits d'autor, termes de llicència, &etc;) s'inclourà de totes maneres en els fitxers dels connectors reals (vegeu la secció <link linkend="chapter_about_information"
>sobre metainformació</link
>). Tingueu en compte que tots aquests fitxers també es poden col·locar en algun lloc del directori "inst", si voleu que no només estiguin presents a l'arxiu d'origen, sinó també al paquet instal·lat. </para>
		</sect3>
		<sect3 id="automated_plugin_testing">
		<title
>Proves automatitzades de connectors (opcional)</title>
			<para
>Un altre directori opcional és "tests", que està destinat a proporcionar els fitxers necessaris per a <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>proves automatitzades de connectors</ulink
>. Aquestes proves són útils per a comprovar ràpidament si els connectors encara funcionen amb versions noves de l'&R; o del &rkward;. Si voleu incloure proves, realment hauríeu de restringir-vos a l'esquema de noms i jerarquia que es mostra aquí. És a dir, les proves han de residir en un directori anomenat <filename
>tests</filename
>, que inclou un fitxer <filename
>testsuite.R</filename
> i una carpeta amb estàndards de proves anomenats després del conjunt de proves apropiat. No obstant això, podeu proporcionar més d'un conjunt de proves; en aquest cas, si no voleu afegir-les totes en el conjunt de proves <filename
>testsuite.R</filename
>, podeu dividir-los, &pex;, un fitxer per a cada paquet de proves i crear un <filename
>testsuite.R</filename
> amb crides <function
>source()</function
> a cada fitxer de la suite. En qualsevol cas, creeu subdirectoris separats amb estàndards de prova per a cada suite definida. </para>
			<para
>Els avantatges de mantenir aquesta estructura és que les proves dels connectors es poden executar simplement cridant <function
>rktests.makplugintests()</function
> del paquet <ulink url="rkward://rhelp/rkwardtests"
>rkwardtests</ulink
> sense arguments addicionals. Consulteu la documentació en línia de <ulink url="http://sourceforge.net/apps/mediawiki/rkward/index.php?title=Automated_Plugin_Testing"
>Proves de connectors automatitzades</ulink
> per a més detalls. </para>
		</sect3>
	</sect2>
</sect1>
  
	<sect1 id="building_the_plugin_package">
		<title
>Construcció del paquet del connector</title>
		<para
>Com s'ha explicat anteriorment, els connectors externs del &rkward; són, en efecte, paquets &R; i, per tant, el procés d'empaquetatge és idèntic. En contrast amb els paquets &R; «reals», un paquet de connector pur no porta cap codi &R; addicional (tot i que per descomptat podeu afegir connectors del &rkward; als paquets &R; habituals, utilitzant els mateixos mètodes que s'expliquen aquí). Això hauria de fer encara més fàcil crear un paquet operatiu, sempre que tingueu un fitxer <filename
>DESCRIPTION</filename
> vàlid i s'adhereixi a la jerarquia de fitxers explicada en les <link linkend="structure_of_a_plugin_package"
>seccions anteriors</link
>.</para>
		<para
>La manera més fàcil de construir i provar el vostre connector és utilitzar l'ordre <application
>R</application
> a la línia d'ordres, per exemple:</para>
		<para
><userinput
><command
>R</command
> <option
>CMD build</option
> <parameter
><filename
>SquaretheCircle</filename
></parameter
> </userinput
></para>
		<para
><userinput
><command
>R</command
> <option
>CMD INSTALL</option
> <parameter
><filename
>SquaretheCircle_0.1-3.tar.gz</filename
></parameter
> </userinput
></para>
		<tip
><para
>No cal construir el paquet com aquest a la línia d'ordres. Si utilitzeu la funció <function
>rk.build.package()</function
> del <link linkend="rkwarddev"
>paquet <application
>rkwarddev</application
></link
>, es construirà i/o comprovarà el paquet de connectors.</para
></tip>
	</sect1>
</chapter>

<chapter id="rkwarddev">
	<title
>Desenvolupament de connectors amb el paquet <application
>rkwarddev</application
></title>
	<sect1 id="rkdev_overview"
><title
>Vista general</title>
		<para
>Escriure connectors externs implica escriure fitxers en tres llenguatges (&XML;, &javascript; i R) i la creació d'una jerarquia estandarditzada de directoris. Per a fer-ho molt més fàcil als desenvolupadors voluntaris de connectors, estem proporcionant el paquet <application
>rkwarddev</application
>. Proporciona una sèrie de funcions simples de l'&R; per a crear el codi &XML; per a tots els elements de diàleg com els «tabbooks», caselles de selecció, llistes desplegables o navegadors de fitxers, així com funcions per a crear el codi &javascript; i fitxers d'ajuda del &rkward; per a començar. La funció <function
>rk.plugin.skeleton()</function
> crea l'arbre de directoris esperat i tots els fitxers necessaris on se suposa que són.</para>
		<para
>Aquest paquet no està instal·lat de manera predeterminada, però s'ha d'instal·lar manualment des del <ulink url="https://files.kde.org/rkward/R/"
>repositori propi del &rkward;</ulink
>. Podeu fer-ho utilitzant la interfície de la &IGU; (<menuchoice
><guimenu
>Arranjament</guimenu
><guimenuitem
>Configura els paquets</guimenuitem
></menuchoice
>), o des de qualsevol sessió &R; en execució:</para>
		<programlisting
>install.packages("rkwarddev", repos="https://files.kde.org/rkward/R")
                library(rkwarddev)
                </programlisting>
		<para
>El <application
>rkwarddev</application
> depèn d'un altre paquet petit anomenat «XiMpLe», que és un analitzador i generador de &XML; molt senzill i també està present en el mateix repositori.</para>
		<para
>També es pot trobar la <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev.pdf"
>documentació completa en format PDF</ulink
>. Es pot trobar una introducció més detallada per a treballar amb el paquet al <ulink url="https://files.kde.org/rkward/R/pckg/rkwarddev/rkwarddev_vignette.pdf"
>resum bàsic del «rkwarddev»</ulink
>.</para>
	</sect1>

	<sect1 id="rkdev_example"
><title
>Exemple pràctic</title>
		<para
>Per a tenir una idea de com «crear scripts en un connector», en comparació amb l'enfocament directe que heu vist en els capítols anteriors, crearem el connector complet de la prova t una vegada més; aquesta vegada només amb les funcions &R; del paquet <application
>rkwarddev</application
>.</para>

		<tip
><para
>El paquet afegirà un diàleg nou de la &IGU; al &rkward; a <menuchoice
><guimenu
>Fitxer</guimenu
><guimenuitem
>Exporta</guimenuitem
><guimenuitem
>Crea un script de connector del &rkward;</guimenuitem
></menuchoice
>. Com suggereix el nom, podeu crear esquelets de connectors per a una edició posterior. Aquest diàleg al seu torn es va generar amb un script del <application
>rkwarddev</application
> que trobareu al directori «demo» del paquet i de codi font de paquet instal·lat, com a exemple addicional. També podeu executar-la cridant <function
>demo("skeleton_dialog")</function
></para
></tip>

		<sect2 id="rkdev_gui"
><title
>Descripció de la &IGU;</title>
		<para
>Us adonareu immediatament que el flux de treball és molt diferent: al contrari d'escriure directament codi XML, no comenceu amb la definició <command
>&lt;document&gt;</command
>, sinó directament amb els elements del connector que us agradaria tenir al diàleg. Podeu assignar cada element d'interfície, ja siguin caselles de selecció, menús desplegables, «varslots» o qualsevol altra cosa, a objectes individuals de l'&R;, i després combinar aquests objectes amb la &IGU; real. El paquet té funcions per a <link linkend="interfaceelements"
>cada etiqueta XML</link
> que es pot utilitzar per a definir la &IGU; del connector, i la majoria fins i tot tenen el mateix nom, només amb el prefix <function
>rk.XML.*</function
>. Per exemple, la definició d'una variable <command
>&lt;varselector&gt;</command
> i dos elements <command
>&lt;varslot&gt;</command
> per a la variable <replaceable
>"x"</replaceable
> i <replaceable
>"y"</replaceable
> de l'exemple de prova t es pot fer mitjançant:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE, id.name="x")
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE, id.name="y")
                </programlisting>
		<para
>El detall més interessant probablement és <parameter
>source=</parameter
><replaceable
>variables</replaceable
>: Una característica destacada del paquet és que totes les funcions poden generar ID automàtics, de manera que no us heu de molestar pensant o recordant en valors d'<parameter
>id</parameter
> per a referir-vos a un element específic del connector. Senzillament, podeu donar els objectes &R; com a referència, ja que totes les funcions que necessiten un ID d'algun altre element també poden llegir-lo des d'aquests objectes. <function
>rk.XML.varselector()</function
> és una mica especial, ja que normalment no té contingut específic per a crear un ID (pot, però només si especifiqueu una etiqueta), de manera que hem d'establir un nom d'ID. Però <function
>rk.XML.varslot()</function
> no necessitaria els arguments <parameter
>id.name</parameter
>, així que això seria suficient:</para>
		<programlisting
>variables &lt;- rk.XML.varselector(id.name="vars")
var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
                </programlisting>
		<para
>Per tal de tornar a crear el codi d'exemple fins aquest punt, haureu d'establir tots els valors d'ID manualment. Però com que el paquet facilitarà les nostres vides, a partir d'ara ja no ens preocuparà.</para>
		<tip>
			<para
>El <application
>rkwarddev</application
> és capaç de fer molta automatització per a ajudar-vos a construir els vostres connectors. No obstant això, podria ser preferible no utilitzar-ho en tota la seva màxima extensió. Si el vostre objectiu és produir codi que no només funcioni, sinó que també es pugui llegir fàcilment i en comparació l'script generador amb un ésser humà, hauríeu de considerar establir sempre ID útils amb <parameter
>id.name</parameter
>. Anomenar els vostres objectes &R; idèntics a aquests ID també ajudarà a obtenir codi de script que sigui fàcil d'entendre. </para>
		</tip>
		<para
>Si voleu veure com es veu el codi XML de l'element definit si l'exporteu a un fitxer, només podeu cridar l'objecte pel seu nom. Per tant, si heu anomenat «var.x» en la vostra sessió &R;, hauríeu de veure quelcom com això:</para>
		<programlisting
>&lt;varslot id="vrsl_compare" label="compare" source="vars" types="number" required="true" /&gt;
                </programlisting>
		<para
>Algunes etiquetes només són útils en el context d'altres. Per tant, per exemple, no trobareu una funció per a l'etiqueta <command
>&lt;option&gt;</command
>. En lloc d'això, tant els botons d'opció com les llistes desplegables es defineixen incloent les seves opcions com una llista amb nom, on els noms representen les etiquetes que es mostraran en el diàleg, i el seu valor és un vector amb nom que pot tenir dues entrades, <parameter
>val</parameter
> per al valor d'una opció i el booleà <parameter
>chk</parameter
> per a especificar si aquesta opció està marcada de manera predeterminada.</para>
		<programlisting
>test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
        options=list(
                "Two-sided"=c(val="two.sided"),
                "First is greater"=c(val="greater"),
                "Second is greater"=c(val="less")
        )
)
                </programlisting>
		<para
>El resultat quedarà així:</para>
		<programlisting
>&lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
        &lt;option label="Two-sided" value="two.sided" /&gt;
        &lt;option label="First is greater" value="greater" /&gt;
        &lt;option label="Second is greater" value="less" /&gt;
&lt;/radio&gt;
                </programlisting>
		<para
>Tot el que falta als elements de la pestanya «Configuració bàsica» és la casella de selecció per a mostres aparellades, i l'estructuració de tots aquests elements en files i columnes:</para>
		<programlisting
>check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))
                </programlisting>
		<para
><function
>rk.XML.cbox()</function
> és una excepció rara on el nom de la funció no conté el nom complet de l'etiqueta, per a desar algun tecleig per a aquest element utilitzat sovint. Això és el que <function
>basic.settings</function
> conté ara:</para>
		<programlisting
>&lt;row id="row_vTFSPP10TF"&gt;
        &lt;varselector id="vars" /&gt;
        &lt;column id="clm_vrsTFSPP10"&gt;
                &lt;varslot id="vrsl_compare" label="compare" source="vars" types="number" required="true" /&gt;
                &lt;varslot id="vrsl_against" label="against" i18n_context="compare against" source="vars" types="number" required="true" /&gt;
                &lt;radio id="rad_usngtsth" label="using test hypothesis"&gt;
                        &lt;option label="Two-sided" value="two.sided" /&gt;
                        &lt;option label="First is greater" value="greater" /&gt;
                        &lt;option label="Second is greater" value="less" /&gt;
                &lt;/radio&gt;
                &lt;checkbox id="chc_Pardsmpl" label="Paired sample" value="1" value_unchecked="0" /&gt;
        &lt;/column&gt;
&lt;/row&gt;
                </programlisting>
		<para
>De manera similar, les línies següents crearan objectes &R; per als elements de la pestanya «Opcions», introduint funcions per a «spinboxes» (botons de selecció de valors), «frames» i «stretch»:</para>
		<programlisting
>check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")
                </programlisting>
		<para
>Tot el que hem de fer ara és reunir els objectes en un «tabbook», i col·locar-lo en una secció «dialog»:</para>
		<programlisting
>full.dialog &lt;- rk.XML.dialog(
        label="Two Variable t-Test",
        rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
)
                </programlisting>
		<para
>També podem crear la secció de l'assistent amb les seves dues pàgines utilitzant els mateixos objectes, de manera que els seus ID s'extrauran per a les etiquetes <command
>&lt;copy&gt;</command
>:</para>
		<programlisting
>full.wizard &lt;- rk.XML.wizard(
                label="Two Variable t-Test",
                rk.XML.page(
                        rk.XML.text("As a first step, select the two variables you want to compare against
                                each other. And specify, which one you theorize to be greater. Select two-sided,
                                if your theory does not tell you, which variable is greater."),
                        rk.XML.copy(basic.settings)),
                rk.XML.page(
                        rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                variables have equal variances. An appropriate correction will be applied then.
                                Choosing \"assume equal variances\" may increase test-strength, however."),
                        rk.XML.copy(check.eqvar),
                        rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                the difference in means. Below you can specify whether one should be shown, and
                                which confidence-level should be applied (95% corresponds to a 5% level of
                                significance)."),
                        rk.XML.copy(conf.frame)))
                </programlisting>
		<para
>Això és per a la &IGU;. El document global es combinarà al final amb <function
>rk.plugin.skeleton()</function
>.</para>
		</sect2>

		<sect2 id="rkdev_jscode"
><title
>Codi &javascript;</title>
			<para
>Fins ara, l'ús del paquet <application
>rkwarddev</application
> podria no haver ajudat tant. Això canviarà ara mateix.</para>
			<para
>En primer lloc, de la mateixa manera que no ens havien d'importar els ID dels elements en definir la disposició de la &IGU;, no ens haurà d'importar els noms de les variables &javascript; en el pas següent. Si voleu més control, podeu escriure codi &javascript; net i enganxar-lo al fitxer generat. Però probablement és molt més eficient fer-ho de la manera del <application
>rkwarddev</application
>.</para>
			<para
>El més notable és que no haureu de definir cap variable, ja que <function
>rk.plugin.skeleton()</function
> pot explorar el codi &XML; i definir automàticament totes les variables que probablement necessitareu; per exemple, no us molestareu a incloure una casella de selecció si després no utilitzeu el seu valor o estat. Així que podem començar a escriure el codi &R; real que genera JS immediatament.</para>
			<tip
><para
>La funció <function
>rk.JS.scan()</function
> també pot explorar els fitxers &XML; existents per a les variables.</para
></tip>
			<para
>El paquet té algunes funcions per a construccions de codi JS que s'utilitzen habitualment en connectors del &rkward;, com la funció <function
>echo()</function
> o les condicions <function
>if() {...} else {...}</function
>. Hi ha algunes diferències entre el JS i l'&R;, &pex;, per a <function
>paste()</function
> a l'&R; utilitzeu la coma per concatenar les cadenes de caràcters, mentre que per a <function
>echo()</function
> en el JS utilitzeu «+», i les línies han d'acabar amb un punt i coma. Mitjançant l'ús de les funcions &R;, gairebé podeu oblidar-vos d'aquestes diferències i continuar escrivint codi &R;.</para>
			<para
>Aquestes funcions poden prendre diferents classes d'objectes d'entrada: text net, objectes &R; amb codi &XML; com a dalt, o al seu torn resultats d'altres funcions JS del paquet. Al final, sempre cridareu <function
>rk.paste.JS()</function
>, el qual es comporta de manera similar a <function
>paste()</function
>, però depenent dels objectes d'entrada els reemplaçarà amb el seu ID &XML;, el nom de variable &javascript; o fins i tot blocs de codi &javascript; complets.</para>
			<para
>Per a l'exemple de la prova t, necessitem dos objectes JS: un per a calcular els resultats, i un per a imprimir-los a la funció <function
>printout()</function
>:</para>
		<programlisting
>JS.calc &lt;- rk.paste.JS(
        echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
        js(
                if(check.paired){
                        echo(", paired=TRUE")
                },
                if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                },
                if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                },
                linebreaks=TRUE
        ),
        echo(")\n"),
        level=2
)

JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)
                </programlisting>
		<para
>Com podeu veure, el <application
>rkwarddev</application
> també proporciona una implementació &R; de la funció <function
>echo()</function
>. Torna exactament una cadena de caràcters amb una versió JS vàlida d'ella mateixa. També us podeu adonar que tots els objectes &R; aquí són els que hem creat abans. Se substituiran automàticament pels seus noms de variables, per la qual cosa això hauria de ser bastant intuïtiu. Sempre que necessiteu aquest reemplaçament, es pot utilitzar la funció <function
>id()</function
>, que també retornarà exactament una cadena de caràcters de tots els objectes que s'han indicat (podríeu dir que es comporta com <function
>paste()</function
> amb una substitució d'objecte molt específica).</para>
    <para
>La funció <function
>js()</function
> és un embolcall que permet utilitzar les condicions <command
>if(){...} else {...}</command
> de l'&R; com les que esteu acostumat a fer. Es traduiran directament al codi JS. També conserva alguns operadors com <command
>&lt;</command
>, <command
>&gt;=</command
> o <command
>||</command
>, de manera que podeu comparar lògicament els objectes &R; sense la necessitat de posar cometes la major part del temps. Mirem l'objecte «JS.calc» resultant, que ara conté una cadena de caràcters amb aquest contingut:</para>
		<programlisting
>echo("res &lt;- t.test (x=" + vrslCompare + ", y=" + vrslAgainst + ", hypothesis=\"" + radUsngtsth + "\"");
        if(chcPardsmpl) {
                echo(", paired=TRUE");
        } else {}
        if(!chcPardsmpl &amp;&amp; chcAssmqlvr) {
                echo(", var.equal=TRUE");
        } else {}
        if(spnCnfdnclv != "0.95") {
                echo(", conf.level=" + spnCnfdnclv);
        } else {}
        echo(")\n");
                </programlisting>
    <note>
      <para
>Alternativament per a les condicions imbricades <function
>if()</function
> en <function
>js()</function
>, podeu utilitzar la funció <function
>ite()</function
>, que es comporta de manera similar a <function
>ifelse()</function
> de l'&R;. No obstant això, les sentències condicionals construïdes utilitzant <function
>ite()</function
> solen ser més difícils de llegir i s'han de substituir per <function
>js()</function
> sempre que sigui possible. </para>
    </note>
		</sect2>

		<sect2 id="rkdev_pluginmap"
><title
>Mapa de connectors</title>
		<para
>Aquesta secció és molt curta: no cal escriure cap &pluginmap;, ja que es pot generar automàticament amb <function
>rk.plugin.skeleton()</function
>. La jerarquia del menú es pot especificar mitjançant l'opció <parameter
>pluginmap</parameter
>:</para>
			<programlisting
>[...]
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test"))
        [...]
                        </programlisting>
		</sect2>

		<sect2 id="rkdev_rkh"
><title
>Pàgina d'ajuda</title>
			<para
>Aquesta secció també és molt curta: <function
>rk.plugin.skeleton()</function
> no pot escriure una pàgina d'ajuda completa a partir de la informació que té. Però també pot explorar el document &XML; cercant elements que probablement mereixen una entrada de pàgina d'ajuda, i crear automàticament una plantilla de pàgines d'ajuda per al nostre connector. Tot el que hem de fer després és escriure algunes línies per a cada secció llistada.</para>
			<tip
><para
>La funció <function
>rk.rkh.scan()</function
> també pot explorar els fitxers &XML; existents per a crear un esquelet de fitxer d'ajuda.</para
></tip>
		</sect2>

		<sect2 id="rkdev_plugin_generator"
><title
>Generació dels fitxers del connector</title>
			<para
>Ara ve el pas final, en el qual lliurarem tots els objectes generats a <function
>rk.plugin.skeleton()</function
>:</para>
			<programlisting
>plugin.dir &lt;- rk.plugin.skeleton("t-Test",
        xml=list(
                dialog=full.dialog,
                wizard=full.wizard),
        js=list(
                results.header="Two Variable t-Test",
                calculate=JS.calc,
                printout=JS.print),
        pluginmap=list(
                name="Two Variable t-Test",
                hierarchy=list("analysis", "means", "t-Test")),
        load=TRUE,
        edit=TRUE,
        show=TRUE)
                        </programlisting>
			<para
>Els fitxers es crearan en un directori temporal predeterminat. Les últimes tres opcions no són necessàries, però són molt útils: <parameter
>load=</parameter
><replaceable
>TRUE</replaceable
> afegirà automàticament el connector nou a la configuració del &rkward; (ja que està en un directori temporal i, per tant, deixarà d'existir quan es tanqui el &rkward;, s'eliminarà automàticament de nou pel &rkward; durant l'inici següent), <parameter
>edit=</parameter
><replaceable
>TRUE</replaceable
> obrirà tots els fitxers creats per a editar-los a les pestanyes de l'editor del &rkward;, i <parameter
>show=</parameter
><replaceable
>TRUE</replaceable
> intentarà llançar directament el connector, de manera que podreu examinar com es veu sense un clic. Podríeu considerar afegir <parameter
>overwrite=</parameter
><replaceable
>TRUE</replaceable
> si executareu l'script repetidament (&pex;, després dels canvis al codi), ja que de manera predeterminada no se sobreescriuran fitxers.</para>
			<para
>L'objecte resultant «plugin.dir» conté el camí al directori on es va crear el connector. Això pot ser útil en combinació amb la funció <function
>rk.build.package()</function
>, per a construir un paquet &R; real per a compartir el vostre connector amb altres; &pex;, per enviant-lo a l'equip de desenvolupament del &rkward; per a afegir-lo al nostre repositori de connectors.</para>
		</sect2>
		<sect2 id="rkdev_ttest_script"
><title
>L'script complet</title>
		<para
>Per a recapitular tot l'anterior, aquí hi ha l'script complet per a crear l'exemple de prova t que funciona. Afegint el codi ja explicat, també carrega el paquet si cal, i utilitza l'entorn <function
>local()</function
>, de manera que tots els objectes creats no acabaran a l'espai de treball actual (excepte el «plugin.dir»):</para>
		<programlisting
>require(rkwarddev)

local({
        variables &lt;- rk.XML.varselector(id.name="vars")
        var.x &lt;- rk.XML.varslot("compare", source=variables, types="number", required=TRUE)
        var.y &lt;- rk.XML.varslot("against", source=variables, types="number", required=TRUE)
        test.hypothesis &lt;- rk.XML.radio("using test hypothesis",
                options=list(
                        "Two-sided"=c(val="two.sided"),
                        "First is greater"=c(val="greater"),
                        "Second is greater"=c(val="less")
                )
        )
        check.paired &lt;- rk.XML.cbox("Paired sample", value="1", un.value="0")
        basic.settings &lt;- rk.XML.row(variables, rk.XML.col(var.x, var.y, test.hypothesis, check.paired))

        check.eqvar &lt;- rk.XML.cbox("assume equal variances", value="1", un.value="0")
        conf.level &lt;- rk.XML.spinbox("confidence level", min=0, max=1, initial=0.95)
        check.conf &lt;- rk.XML.cbox("print confidence interval", val="1", chk=TRUE)
        conf.frame &lt;- rk.XML.frame(conf.level, check.conf, rk.XML.stretch(), label="Confidence Interval")

        full.dialog &lt;- rk.XML.dialog(
                label="Two Variable t-Test",
                rk.XML.tabbook(tabs=list("Basic settings"=basic.settings, "Options"=list(check.eqvar, conf.frame)))
        )

        full.wizard &lt;- rk.XML.wizard(
                        label="Two Variable t-Test",
                        rk.XML.page(
                                rk.XML.text("As a first step, select the two variables you want to compare against
                                        each other. And specify, which one you theorize to be greater. Select two-sided,
                                        if your theory does not tell you, which variable is greater."),
                                rk.XML.copy(basic.settings)),
                        rk.XML.page(
                                rk.XML.text("Below are some advanced options. It is generally safe not to assume the
                                        variables have equal variances. An appropriate correction will be applied then.
                                        Choosing \"assume equal variances\" may increase test-strength, however."),
                                rk.XML.copy(check.eqvar),
                                rk.XML.text("Sometimes it is helpful to get an estimate of the confidence interval of
                                        the difference in means. Below you can specify whether one should be shown, and
                                        which confidence-level should be applied (95% corresponds to a 5% level of
                                        significance)."),
                                rk.XML.copy(conf.frame)))

        JS.calc &lt;- rk.paste.JS(
                echo("res &lt;- t.test (x=", var.x, ", y=", var.y, ", hypothesis=\"", test.hypothesis, "\""),
                js(
                        if(check.paired){
                        echo(", paired=TRUE")
                        },
                        if(!check.paired &amp;&amp; check.eqvar){
                        echo(", var.equal=TRUE")
                        },
                        if(conf.level != "0.95"){
                        echo(", conf.level=", conf.level)
                        },
                        linebreaks=TRUE
                ),
                echo(")\n"), level=2)

        JS.print &lt;- rk.paste.JS(echo("rk.print (res)\n"), level=2)

        plugin.dir &lt;&lt;- rk.plugin.skeleton("t-Test",
                xml=list(
                        dialog=full.dialog,
                        wizard=full.wizard),
                js=list(
                        results.header="Two Variable t-Test",
                        calculate=JS.calc,
                        printout=JS.print),
                pluginmap=list(
                        name="Two Variable t-Test",
                        hierarchy=list("analysis", "means", "t-Test")),
                load=TRUE,
                edit=TRUE,
                show=TRUE,
                overwrite=TRUE)
})
                </programlisting>
		</sect2>

  </sect1>
  <sect1 id="rkwarddev_rkh"
><title
>Afegir pàgines d'ajuda</title>
    <para
>Si voleu escriure una pàgina d'ajuda per al connector, la manera més directa de fer-ho és afegir les instruccions particulars directament a les definicions dels elements &XML; als quals pertanyen: </para>
    <programlisting
>variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse.",
  component="Data"
)
    </programlisting>
    <para
>El text donat al paràmetre <parameter
>help</parameter
> es pot obtenir amb <function
>rk.rkh.scan()</function
> i s'escriu a la pàgina d'ajuda d'aquest component del connector. Perquè això funcioni tècnicament, tanmateix, <function
>rk.rkh.scan()</function
> ha de saber quins objectes &R; pertanyen a un component del connector. Per això també heu de proporcionar el paràmetre <parameter
>component</parameter
> i assegurar-vos que és idèntic per a tots els objectes que pertanyen junts. </para>
    <para
>Com que normalment combinareu molts objectes en un diàleg i també us podria agradar reutilitzar objectes com el <command
>&lt;varslot&gt;</command
> en diversos components dels vostres connectors, és possible definir globalment un component amb <function
>rk.set.comp()</function
>. Si es defineix, s'assumeix que tots els objectes següents utilitzats en el vostre script pertanyen a aquest component en particular, fins que <function
>rk.set.comp()</function
> es torna a cridar amb un nom de component diferent. Després podeu ometre el paràmetre <parameter
>component</parameter
>: </para>
    <programlisting
>rk.set.comp("Data")
variables &lt;- rk.XML.varselector(
  id.name="vars",
  help="Select the data object you would like to analyse."
)
    </programlisting>
    <para
>Per a afegir seccions globals com <command
>&lt;summary&gt;</command
> o <command
>&lt;usage&gt;</command
> a la pàgina d'ajuda, utilitzeu funcions com <function
>rk.rkh.summary()</function
> o <function
>rk.rkh.usage()</function
> d'acord amb això. Els seus resultats s'utilitzen per a establir els elements de la llista com <parameter
>summary</parameter
> o <parameter
>usage</parameter
> en el paràmetre <parameter
>rkh</parameter
> de <function
>rk.plugin.component()</function
>/<function
>rk.plugin.skeleton()</function
>. </para>
	</sect1>
  <sect1 id="rkwarddev_i18n"
><title
>Connectors de traducció</title>
    <para
>El paquet <application
>rkwarddev</application
> és capaç de produir connectors externs amb suport complet d'«i18n». Per exemple, totes les funcions rellevants que generen objectes XML ofereixen un paràmetre opcional per a especificar <replaceable
>i18n_context</replaceable
> o <replaceable
>noi18n_label</replaceable
>: </para>
    <programlisting
>varComment &lt;- rk.XML.varselector(id.name="vars", i18n=list(comment="Main variable selector"))
varContext &lt;- rk.XML.varselector(id.name="vars", i18n=list(context="Main variable selector"))
cboxNoi18n &lt;- rk.XML.cbox(label="Power", id.name="power", i18n=FALSE)
    </programlisting>
    <para
>Els exemples anteriors produeixen una sortida com aquesta:</para>
    <programlisting
># varComment
&lt;!-- i18n: Main variable selector --&gt;
  &lt;varselector id="vars" /&gt;

# varContext
&lt;varselector id="vars" i18n_context="Main variable selector" /&gt;

# cboxNoi18n
&lt;checkbox id="power" noi18n_label="Power" value="true" /&gt;
    </programlisting>
    <para
>També hi ha suport per al codi JS traduïble. De fet, el paquet intenta afegir les crides <function
>i18n()</function
> predeterminades en els llocs on això sol ser útil. La funció <function
>rk.JS.header()</function
> és un bon exemple: </para>
    <programlisting
>jsHeader &lt;- rk.JS.header("Test results")
    </programlisting>
    <para
>Això produeix el codi JS següent:</para>
    <programlisting
>new Header(i18n("Test results")).print();
    </programlisting>
    <para
>Però també podeu marcar manualment les cadenes del codi JS com a traduïbles, utilitzant la funció <function
>i18n()</function
> tal com ho faríeu si escriviu el fitxer JS directament.</para>
  </sect1>
</chapter>

<appendix id="reference">
<title
>Referència</title>

<sect1 id="propertytypes"
><title
>Tipus de propietats/Modificadors</title>
<para
>En alguns llocs d'aquesta introducció hem parlat de «propietats» d'elements de la &IGU; o d'altres. De fet, hi ha diversos tipus de propietats. Normalment no cal que us preocupeu per això, ja que podeu utilitzar el sentit comú per a connectar qualsevol propietat a qualsevol altra propietat. No obstant això, internament, hi ha tipus diferents de propietats. El que importa és quan s'obtenen alguns valors especials a la plantilla JS. A les sentències getString ("id")/getBoolean ("id")/getList ("id") també podeu especificar alguns dels anomenats «modificadors» com aquest: <function
>getString ("id.modifier")</function
>. Aquest modificador afectarà, de manera que s'imprimirà el valor. Llegiu la llista de propietats i els modificadors que publiquen: </para>
<variablelist>
<varlistentry>
<term
>Propietats de cadena</term>
<listitem
><para
>El tipus de propietat més senzill, utilitzat per a contenir un tros de text. Modificadors: <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>La cadena com a definida/establerta.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>quoted</term>
	<listitem
><para
>La cadena en la forma citada (adequada per a passar a &R; com a caràcter).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats booleanes</term>
<listitem
><para
>Propietats que poden estar activades o desactivades, certes o falses. Per exemple, les propietats creades per les etiquetes &lt;convert&gt;, també la propietat que acompanya una &lt;checkbox&gt; (vegeu a sota). Es retornaran els valors següents segons el modificador indicat: <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>Per defecte, la propietat retornarà 1 si és certa i 0 en cas contrari. La manera recomanada d'obtenir els valors booleans és utilitzant <function
>getBoolean()</function
>. Tingueu en compte que per a <function
>getString()</function
>, es retornarà la cadena "0" quan la propietat sigui falsa. Aquesta cadena s'avaluaria a certa, no a falsa en JS.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"labeled"</term>
	<listitem
><para
>Retorna la cadena «true» (certa) quan és certa, «false» (falsa) quan és falsa, o qualsevol cadena personalitzada que s'hagi especificat (normalment en una &lt;checkbox&gt;).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"true"</term>
	<listitem
><para
>Retorna la cadena com si la propietat fos certa, encara que sigui falsa</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"false"</term>
	<listitem
><para
>Retorna la cadena com si la propietat fos falsa, encara que sigui certa</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"not"</term>
	<listitem
><para
>Això realment retorna una altra propietat booleana, la qual és la inversa de l'actual (&ead;, falsa si és certa, certa si és falsa)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"numeric"</term>
	<listitem
><para
>Obsoleta, proporcionada per a la compatibilitat cap enrere. Igual que sense modificador "". Retorna "1" si la propietat és certa, o "0" si és falsa.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats dels enters</term>
<listitem
><para
>Una propietat dissenyada per a tenir un valor enter (però, per descomptat, encara retorna una cadena de caràcters numèrics a la plantilla JS). No accepta cap modificador. Utilitzat en les &lt;spinbox&gt; (vegeu a sota)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats dels nombres reals</term>
<listitem
><para
>Una propietat dissenyada per a tenir un valor de nombre real (però, per descomptat, encara retorna una cadena de caràcters numèrics a la plantilla JS). Utilitzat en les &lt;spinbox&gt; (vegeu a sota) <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>Per a <function
>getValue()/getString()</function
>, això retorna el mateix que "formatted". En canvi, en versions futures serà possible obtenir una representació numèrica.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"formatted"</term>
	<listitem
><para
>Retorna el nombre amb format (com a cadena).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats dels RObject</term>
<listitem
><para
>Una propietat destinada a una selecció d'un o més objectes &R;. S'utilitza de forma més destacada en «varselectors» i «varslots». Es retornaran els valors següents segons el modificador indicat: <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>De manera predeterminada, la propietat retornarà el nom complet de l'objecte seleccionat. Si se selecciona més d'un objecte, els noms dels objectes se separaran amb salts de línia ("\n").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"shortname"</term>
	<listitem
><para
>Com a dalt, però només retorna els noms curts dels objectes. Per exemple, un objecte dins d'una llista només rebria el nom que té dins de la llista, sense el nom de la llista.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"label"</term>
	<listitem
><para
>Com a dalt, però retorna les etiquetes del &rkward; dels objectes (si no hi ha cap etiqueta disponible, aquesta serà la mateixa que el nom curt)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats de les llistes de cadenes</term>
<listitem
><para
>Aquesta propietat conté una llista de cadenes. <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>Per a <function
>getValue()/getString()</function
>, això retorna totes les cadenes separades per «\n». Qualsevol caràcter «\n» de cada element s'escapa com a literal «\n». No obstant això, l'ús recomanat és obtenir el valor amb <function
>getList()</function
>, en el seu lloc, el qual retornarà una matriu de cadenes.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"joined"</term>
	<listitem
><para
>Retorna la llista com una única cadena, amb els elements units amb «\n». En contrast a sense modificador (""), les cadenes individuals _no_ s'escapen.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>Propietats del codi</term>
<listitem
><para
>Una propietat dels connectors que han generat el codi. Això és important pels connectors incrustadors, per tal d'incrustar el codi generat pel connector incrustat en el codi generat pel connector incrustador (nivell superior). Es retornaran els valors següents segons el modificador indicat: <variablelist>
	<varlistentry>
	<term
>Sense modificador ("")</term>
	<listitem
><para
>Retorna el codi complet, &ead;, les seccions preprocess», «calculate», «printout» i (però no «preview») concatenades en una cadena.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preprocess"</term>
	<listitem
><para
>Retorna només la secció «preprocess» del codi</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"calculate"</term>
	<listitem
><para
>Retorna només la secció «calculate» del codi</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"printout"</term>
	<listitem
><para
>Retorna només la secció «printout» del codi</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>"preview"</term>
	<listitem
><para
>Retorna la secció «preview» del codi</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="globalxmlelements">
	<title
>Elements de propòsit general que s'utilitzaran en qualsevol fitxer &XML; (<literal role="extension"
>.xml</literal
>,<literal role="extension"
>.rkh</literal
>, &pluginmap;)</title>
	<variablelist>
	<varlistentry>
	<term
>&lt;snippets&gt;</term>
	<listitem
><para
>Permès com a fill directe del node &lt;document&gt; i només allà. S'ha de col·locar a prop de la part superior del fitxer. Vegeu la secció <link linkend="snippets"
>sobre l'ús de fragments</link
>. Només pot estar present un element &lt;snippets&gt;. Opcional, sense atributs.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;snippet&gt;</term>
	<listitem
><para
>Defineix un fragment únic. Només es permet com a fill directe de l'element &lt;snippets/&gt;. Atributs: <variablelist
> <varlistentry>
		<term
>&lt;id&gt;</term>
		<listitem
><para
>Una cadena d'identificador per al fragment. Requerit.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;insert&gt;</term>
	<listitem
><para
>Insereix el contingut d'un &lt;snippet&gt;. Permès en qualsevol lloc. Atributs: <variablelist
> <varlistentry>
		<term
>&lt;snippet&gt;</term>
		<listitem
><para
>La cadena de l'identificador del fragment a inserir. Requerit.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;include&gt;</term>
	<listitem
><para
>Inclou el contingut d'un altre fitxer &XML; (tot dins de l'element &lt;document&gt; d'aquest fitxer). Permès en qualsevol lloc. Atributs: <variablelist
> <varlistentry>
		<term
>&lt;file&gt;</term>
		<listitem
><para
>El nom del fitxer, relatiu al directori a on és el fitxer actual. Requerit.</para
></listitem>
		</varlistentry>
		</variablelist
></para
></listitem>
	</varlistentry>
	</variablelist>
</sect1>

<sect1 id="xmlelements"
><title
>Elements a utilitzar en la descripció &XML; del connector</title>
<para
>Les propietats dels elements s'enumeren en una <link linkend="elementproperties"
>secció separada</link
>.</para>

<sect2 id="generalelements"
><title
>Elements generals</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Cal que sigui present en cada fitxer «description.xml» com a node arrel. No hi ha cap funció especial. Sense atributs</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Informació sobre aquest connector (autor, llicència, &etc;). Aquest element està permès tant en el fitxer <literal role="extension"
>.xml</literal
> d'un connector individual com en els fitxers &pluginmap;. Consulteu la <link linkend="pluginmapelements"
>referència del fitxer &pluginmap;</link
> per als detalls de referència, <link linkend="chapter_about_information"
>el capítol sobre la informació «about»</link
> per a una introducció.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;code&gt;</term>
<listitem
><para
>Defineix on cercar la plantilla JS al connector. Utilitzeu-ho només una vegada per fitxer, com a fill directe de l'etiqueta del document. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nom de fitxer de la plantilla JS, relatiu al directori on està l'«xml» del connector</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;help&gt;</term>
<listitem
><para
>Defineix on cercar el fitxer d'ajuda del connector. Utilitzeu-ho només una vegada per fitxer, com a fill directe de l'etiqueta del document. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nom de fitxer del fitxer d'ajuda, relatiu al directori on està l'«xml» del connector</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;copy&gt;</term>
<listitem
><para
>Es pot utilitzar com a fill (directe o indirecte) dels elements principals de la disposició, &ead;, &lt;dialog&gt; i &lt;wizard&gt;. Això s'utilitza per a copiar 1:1 tot un bloc a elements &XML;. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID a cercar. L'etiqueta &lt;copy&gt; cercarà un element &XML; anterior que tingui el mateix ID, i el copiarà incloent-hi tots els elements descendents.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>copy_element_tag_name</parameter
></term>
	<listitem
><para
>En alguns casos, voldreu una còpia gairebé literal, però canvieu el nom d'etiqueta de l'element a copiar. L'exemple més important d'això és quan voleu copiar tot un &lt;tab&gt; des d'una interfície de diàleg a &lt;page&gt; d'una interfície assistent. En aquest cas, establiu copy_element_tag_name="page" per a fer aquesta conversió automàticament.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="interfaceelements"
><title
>Definicions d'interfície</title>
<variablelist>
<varlistentry>
<term
>&lt;dialog&gt;</term>
<listitem
><para
>Defineix una interfície de tipus diàleg. Col·loca la definició de la &IGU; dins d'aquesta etiqueta. Utilitzeu només una vegada per fitxer, com a fill directe de l'etiqueta document. Es requereix almenys una de les etiquetes «dialog» o «wizard» per a un connector. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Llegenda per al diàleg</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>S'ha d'utilitzar el diàleg com a interfície «recomanada» (&ead;, la interfície que es mostrarà de manera predeterminada, llevat que l'usuari hagi configurat el &rkward; a una interfície específica com a predeterminada)? Aquest atribut actualment no té cap efecte, ja que és implícitament «true», llevat que es recomani l'assistent.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;wizard&gt;</term>
<listitem
><para
>Defineix una interfície de tipus assistent. Col·loca la definició de la &IGU; dins d'aquesta etiqueta. Utilitzeu només una vegada per fitxer, com a fill directe de l'etiqueta del document. Es requereix almenys una de les etiquetes «dialog» o «wizard» per a un connector. Accepta només etiquetes &lt;page&gt; o &lt;embed&gt; com a fills directes. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Llegenda per a l'assistent</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>recommended</parameter
></term>
	<listitem
><para
>S'ha d'utilitzar l'assistent com a interfície «recomanada» (&ead;, la interfície que es mostrarà de manera predeterminada, llevat que l'usuari hagi configurat el &rkward; a una interfície específica com a predeterminada)? Opcional, el valor predeterminat és «false».</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="layoutelements"
><title
>Elements de disposició</title>
<para
>Tots els elements d'aquesta secció accepten un atribut id="identifierstring". Aquest atribut és opcional per a tots els elements. Es pot utilitzar, per exemple, per a ocultar/inhabilitar tot l'element de la disposició i tots els elements continguts en ell (vegeu el <link linkend="logic"
>capítol de la lògica de la &IGU;</link
>). La cadena «id» no pot contenir «.» (punt) ni «;» (punt i coma), i generalment s'ha de limitar a caràcters alfanumèrics i el guió baix («_»). Només es llisten els atributs addicionals.</para>
<variablelist>
<varlistentry>
<term
>&lt;page&gt;</term>
<listitem
><para
>Defineix una pàgina nova dins d'un assistent. Només es permet com a fill directe d'un element &lt;wizard&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;row&gt;</term>
<listitem
><para
>Tots els fills directes d'una etiqueta «row» es col·locaran d'esquerra a dreta.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;column&gt;</term>
<listitem
><para
>Tots els fills directes d'una etiqueta «column» es col·locaran de dalt a baix.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;stretch&gt;</term>
<listitem
><para
>De manera predeterminada, els elements de la &IGU; ocupen tot l'espai disponible. Per exemple, si teniu dues columnes una al costat de l'altra, l'esquerra està empaquetada amb elements, però la dreta només conté un sol <command
>&lt;radio&gt;</command
>, el control <command
>&lt;radio&gt;</command
> s'expandirà verticalment, tot i que realment no necessita l'espai disponible, i es veurà lleig. En aquest cas, realment voleu afegir un «blank» a sota del <command
>&lt;radio&gt;</command
>. Per a això, utilitzeu l'element &lt;stretch&gt;. Simplement utilitzarà una mica d'espai. No utilitzeu en excés aquest element, normalment és una bona idea que els elements de la &IGU; obtinguin tot l'espai disponible, només de vegades la disposició es veurà espaiada. L'element &lt;stretch&gt; no pren cap argument, ni tan sols una «id». Tampoc podeu posar un fill dins de l'element &lt;stretch&gt; (en altres paraules, només l'utilitzareu com a «&lt;stretch/&gt;»)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>Dibuixa un marc/quadre al voltant dels seus fills directes. Es pot utilitzar per a agrupar visualment les opcions relacionades. La disposició dins d'un marc és de dalt a baix, llevat que col·loqueu una &lt;row&gt; a dins. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Llegenda per al marc (opcional)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>Els marcs es poden marcar. En aquest cas, tots els elements continguts s'inhabilitaran quan el marc no estigui marcat i s'habilitaran quan estigui marcat. (Opcional, de manera predeterminada és "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Només per als marcs que es poden marcar: s'ha de marcar el marc de manera predeterminada? El valor predeterminat és «true». No s'interpreta per a marcs que no es poden marcar.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tabbook&gt;</term>
<listitem
><para
>Organitza elements en un «tabbook». Accepta només etiquetes &lt;tab&gt; com a fills directes.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;tab&gt;</term>
<listitem
><para
>Defineix una pàgina en un «tabbook». Col·loca la definició de la &IGU; per a la pestanya dins d'aquesta etiqueta. Només es pot utilitzar com a fill directe d'una etiqueta &lt;tabbook&gt;. Un &lt;tabbook&gt; hauria de tenir almenys dues pestanyes definides. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Llegenda per a la pàgina de pestanya (requerit)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>Mostra el text envoltat per aquesta etiqueta a la &IGU;. S'admeten alguns marcadors senzills d'estil &HTML; (en particular <markup
>&lt;b&gt;</markup
>, <markup
>&lt;i&gt;</markup
>, <markup
>&lt;p&gt;</markup
>, i <markup
>&lt;br/&gt;</markup
>). No obstant això, mantingueu el format al mínim. Inserir una línia completament buida afegeix un salt de línia dur. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Tipus del text. Un de "normal", "avís" o "error". Això influeix en l'aspecte del text (opcional, el predeterminat és "normal")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="activeelements"
><title
>Elements actius</title>
<para
>Tots els elements d'aquesta secció accepten l'atribut id="identifierstring". Aquest atribut és obligatori per a tots els elements. Només es llisten els atributs addicionals. La cadena d'identificació no pot contenir "." (punts).</para>
<variablelist>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Proporciona una llista d'objectes disponibles des dels quals l'usuari pot seleccionar-ne un o més. Requereix una o més &lt;varslot&gt; com a contrapartida per a ser útil. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al «varselector» (opcional, el predeterminat és "Select variable(s)")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>S'utilitza conjuntament amb un "varselector" per a permetre que l'usuari seleccioni una o més variables. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al «varslot» (recomanada, la predeterminada és «Variable:»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source</parameter
></term>
	<listitem
><para
>El «varselector» des d'on obtenir la selecció (requerit, llevat que es connecti manualment o usant «source_property»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>source_property</parameter
></term>
	<listitem
><para
>Una propietat arbitrària d'on copiar els valors, quan es fa clic al botó de selecció. Si s'especifica, això anul·la l'atribut «source».</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Si es requereix que per a enviar el codi aquest «varslot» tingui un valor vàlid. Vegeu la <link linkend="elementproperties"
>propietat requerida</link
> (opcional, predeterminada a "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>multi</parameter
></term>
	<listitem
><para
>Si el «varslot» només conté un (predeterminat, «fals») o diversos objectes</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_duplicates</parameter
></term>
	<listitem
><para
>Si el «varslot» només pot acceptar objectes únics (predeterminat, «fals»), o si el mateix objecte es pot afegir diverses vegades.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars</parameter
></term>
	<listitem
><para
>Només té sentit si és multi="true": nombre mínim de variables que s'han de seleccionar perquè la selecció es consideri vàlida (opcional, el valor predeterminat és "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_vars_if_any</parameter
></term>
	<listitem
><para
>Només té sentit si és multi="true": Alguns «varslots» es poden considerar vàlids, si, per exemple, el «varslot» està buit o té almenys dos valors. Això especifica quantes variables s'han de seleccionar si n'hi ha (2 a l'exemple). (Opcional, el valor predeterminat és "1")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_vars</parameter
></term>
	<listitem
><para
>Només té sentit si és multi="true": nombre màxim de variables a seleccionar (opcional, el valor predeterminat és "0", el qual vol dir sense màxim)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>classes</parameter
></term>
	<listitem
><para
>Si especifiqueu un o més noms de classe &R; (separats per espais (" ")), aquí, el «varslot» només acceptarà objectes pertanyents a aquestes classes (opcional, <emphasis
>useu-ho amb molta cura</emphasis
>, no s'hauria d'impedir a l'usuari prendre decisions vàlides, i &R; té <emphasis
>moltes</emphasis
> classes diferents)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>types</parameter
></term>
	<listitem
><para
>Si especifiqueu un o més tipus de variables (separades per espais («)»), aquí, el «varslot» només acceptarà objectes d'aquests tipus. Els tipus vàlids són "unknown", "number", "string", "factor", "invalid". (Opcional, <emphasis
>useu-ho amb molta cura</emphasis
>, no s'ha d'impedir a l'usuari que prengui decisions vàlides, i el &rkward; no sempre coneix el tipus d'una variable)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>num_dimensions</parameter
></term>
	<listitem
><para
>El nombre de dimensions que un objecte necessita tenir. "0" (predeterminat), vol dir que qualsevol nombre de dimensions és acceptable. (Opcional, el valor predeterminat és "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_length</parameter
></term>
	<listitem
><para
>La longitud mínima que un objecte ha de tenir per a ser acceptable. (Opcional, el valor predeterminat és "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_length</parameter
></term>
	<listitem
><para
>La longitud màxima que un objecte ha de tenir per tal de ser acceptable. (Opcional, predeterminat pel nombre enter més gran representable al sistema)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>Proporciona una llista de cadenes disponibles (no objectes &R;) que se seleccionaran en una o més àrees d'acompanyament &lt;valueslot&gt;. Les opcions de cadena es poden definir utilitzant etiquetes &lt;option&gt; com a fills directes (vegeu més avall), o establir-les utilitzant <link linkend="elementproperties"
>propietats</link
> dinàmiques. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al «valueselector» (opcional, predeterminat a sense etiqueta)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>S'utilitza conjuntament amb un &lt;valueselector&gt; per a permetre a l'usuari seleccionar un o més elements de cadena. Aquest element és majoritàriament idèntic a &lt;varslot&gt;, i comparteix els mateixos atributs, excepte els que es refereixen a les propietats dels elements acceptables (&ead; classes, types, num_dimensions, min_length, max_length).</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>Defineix un grup de botons exclusius d'opcions (només es pot seleccionar un alhora). Requereix almenys dues etiquetes &lt;option&gt; com a fills directes. No es permeten altres etiquetes com a filles. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al control d'opcions (recomanada, la predeterminada és «Select one:»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>Defineix un grup d'opcions de les quals es pot seleccionar una i només una alhora, utilitzant una llista desplegable. Això és funcionalment equivalent a un &lt;radio&gt;, però es veu diferent. Requereix almenys dues etiquetes &lt;option&gt; com a filles directes. No es permeten altres etiquetes com a filles. Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a la llista desplegable (recomanada, la predeterminada és «Select one:»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>Proporciona una llista de cadenes disponibles des de les quals l'usuari pot seleccionar un nombre arbitrari. Les opcions de cadena es poden definir utilitzant etiquetes &lt;option&gt; com a filles directes (vegeu més avall), o establir-les utilitzant <link linkend="elementproperties"
>propietats</link
> dinàmiques. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a &lt;select&gt; (opcional, predeterminat a sense etiqueta)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>single</parameter
></term>
	<listitem
><para
>Si s'estableix a cert, només es podrà seleccionar un valor únic, en lloc de diversos valors alhora (booleà, predeterminat a fals)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>Només es pot utilitzar com a fill directe d'un element &lt;radio&gt;, &lt;dropdown&gt;, &lt;valueselector&gt; o &lt;select&gt;. Representa una opció seleccionable en un control d'opcions o llista desplegable. Com que els elements &lt;option&gt; sempre formen part d'un dels elements de selecció, normalment no tenen una "id" pròpia, però vegeu a continuació. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a l'opció (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>El valor de la cadena que retornarà l'element pare si aquesta opció està marcada/seleccionada (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Si l'opció s'ha de marcar/seleccionar de manera predeterminada a «true» o «false». En un &lt;radio&gt; o &lt;dropdown&gt;, només es pot establir una opció a <parameter
>checked=</parameter
><replaceable
>"true"</replaceable
>, i si no s'estableix cap opció a «checked», es marcarà/seleccionarà automàticament la primera opció de l'element pare. En un &lt;select&gt;, es pot establir com a «checked» qualsevol nombre d'opcions. (Opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>És opcional especificar el paràmetre «id» per als elements &lt;option&gt; (i de fet, es recomana no establir un «id», llevat que realment en necessiteu un). No obstant això, especificar un "id" us permetrà habilitar/inhabilitar dinàmicament &lt;option&gt;, connectant-vos a la propietat booleana <replaceable
>id_of_radio.id_of_optionX.enabled</replaceable
>. Actualment això funciona per a opcions dins d'elements &lt;radio&gt; o &lt;dropdown&gt;, només; actualment les opcions &lt;valueselector&gt; i &lt;select&gt; no admeten els identificadors.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>Defineix una casella de selecció, &ead;, una opció única que es pot activar o desactivar. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a la casella de selecció (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value</parameter
></term>
	<listitem
><para
>El valor que la casella de selecció retornarà si està marcada (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>value_unchecked</parameter
></term>
	<listitem
><para
>El valor que es retornarà si la casella de selecció no està marcada (opcional, el valor predeterminat és "", &ead;, una cadena buida)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Si l'opció s'ha de marcar per defecte "true" o "false" (opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>L'element del marc s'utilitza generalment com un element de disposició pur, i es llista a la secció sobre <link linkend="layoutelements"
>elements de disposició</link
>. No obstant això, també es pot fer que es pugui marcar, actuant així com una casella de selecció senzilla al mateix temps. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>Defineix un camp d'entrada de text lliure. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al camp d'entrada (requerida)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Text inicial del camp de text (opcional, el valor predeterminat és "", &ead;, una cadena buida)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>size</parameter
></term>
	<listitem
><para
>Un de "small", "medium", o "large". "large" defineix un camp d'entrada multilínia, "small" i "medium" són camps d'una sola línia (opcional, el predeterminat és "medium")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Si es requereix que per a enviar el codi aquesta entrada no estigui buida. Vegeu la <link linkend="elementproperties"
>propietat requerida</link
> (opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;matrix&gt;</term>
<listitem
><para
>Una taula per a introduir dades de matrius (o vectors) a la &IGU;.</para
> <note
><para
>Aquest element d'entrada <emphasis
>no</emphasis
> està optimitzat per a introduir/editar grans quantitats de dades. Si bé no hi ha un límit estricte en la mida d'una &lt;matrix&gt;, en general no hauria de superar al voltant de deu files/columnes. Si espereu dades més grans, permeteu als usuaris seleccionar-lo com un objecte &R; (el qual pot ser una bona idea com a opció alternativa, en gairebé <emphasis
>cada</emphasis
> instància on utilitzeu un element de matriu).</para
></note
> <para
>Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a la taula (requerida)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Un d'entre "integer", "real", o "string". El tipus de dades que s'acceptaran a la taula (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Valor mínim acceptable (per a matrius de tipus "integer" o "real") (opcional, predeterminat al valor més petit representable)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Valor màxim acceptable (per a matrius de tipus "integer" o "real") (opcional, predeterminat al valor més gran representable)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_missings</parameter
></term>
	<listitem
><para
>Si es permeten valors (buits) a la matriu. Això està implícit per a matrius o mode «cadena» (opcional, el valor predeterminat és "false").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_columns</parameter
></term>
	<listitem
><para
>Quan s'estableix a «true» (cert), l'usuari pot afegir columnes escrivint a les cel·les (inactives) més a la dreta (opcional, predeterminat a "true").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_user_resize_rows</parameter
></term>
	<listitem
><para
>Quan s'estableix a «true» (cert), l'usuari pot afegir files escrivint a les cel·les (inactives) de la part de baix de tot (opcional, predeterminat a "true").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>rows</parameter
></term>
	<listitem
><para
>Nombre de files a la matriu. No té cap efecte per allow_user_resize_rows="true". <note
><para
>Això també es pot controlar establint la propietat "rows".</para
></note
> (opcional, predeterminat a 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>columns</parameter
></term>
	<listitem
><para
>Nombre de columnes a la matriu. No té cap efecte per allow_user_resize_columns="true". <note
><para
>Això també es pot controlar establint la propietat "columns".</para
></note
> (opcional, predeterminat a 2).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Nombre mínim de files a la matriu. La matriu refusarà reduir-se per sota d'aquesta mida. (Opcional, el valor predeterminat és 0; vegeu també: <parameter
>allow_missings</parameter
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_columns</parameter
></term>
	<listitem
><para
>Nombre mínim de columnes a la matriu. La matriu refusarà reduir-se per sota d'aquesta mida. (Opcional, el valor predeterminat és 0; vegeu també: <parameter
>allow_missings</parameter
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_height</parameter
></term>
	<listitem
><para
>Força l'element de la &IGU; a romandre a la seva alçada inicial. No l'utilitzeu en combinació amb matrius, on el nombre de files pot canviar de qualsevol manera. Especialment útil quan es crea un element d'entrada vectorial (columns="1"). Amb aquesta opció establerta a «true» (cert), no es mostrarà cap barra de desplaçament horitzontal, fins i tot si la matriu excedeix l'amplada disponible (ja que això afectaria l'alçada). (Opcional, el valor predeterminat és "false").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_width</parameter
></term>
	<listitem
><para
>Nom lleugerament incorrecte: suposa que el comptador de columnes no canviarà. L'última columna (o normalment només) s'estirarà per a agafar l'amplada disponible. No l'utilitzeu en combinació amb matrius, on el nombre de columnes pot canviar de qualsevol manera. Especialment útil quan es crea un element d'entrada vectorial (rows="1"). (Opcional, el valor predeterminat és "false").</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>horiz_headers</parameter
></term>
	<listitem
><para
>Cadenes a usar per a la capçalera horitzontal, separades per «;». La capçalera s'ocultarà, si s'estableix a "". (Opcional, el valor predeterminat és el número de columna).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>vert_headers</parameter
></term>
	<listitem
><para
>Cadenes a usar per a la capçalera vertical, separades per «;». La capçalera s'ocultarà, si s'estableix a "". (Opcional, el valor predeterminat és el número de fila).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;optionset&gt;</term>
<listitem
><para
>Una interfície d'usuari per a repetir un conjunt d'opcions per a un nombre arbitrari d'elements (<link linkend="optionset"
>introducció als «optionsets»</link
>). Atributs:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>min_rows</parameter
></term>
	<listitem
><para
>Si s'especifica, el conjunt es marcarà com a no vàlid, llevat que tingui almenys aquest nombre de files (opcional, enter).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min_rows_if_any</parameter
></term>
	<listitem
><para
>Com «min_rows», però només es provaran si hi ha almenys una fila (opcional, enter).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_rows</parameter
></term>
	<listitem
><para
>Si s'especifica, el conjunt es marcarà com a no vàlid, llevat que tingui com a màxim aquest nombre de files (opcional, enter).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>keycolumn</parameter
></term>
	<listitem
><para
>L'ID de la columna per a actuar com a «keycolumn». Un «optionset» amb una «keycolumn» (vàlida) actuarà com un «optionset» "driven". Un «optionset» sense «keycolumn» permetrà la inserció/eliminació manual d'elements. La «keycolumn» s'ha de marcar com a externa. (Opcional, de manera predeterminada no hi ha cap «keycolumn»).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elements fills:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;optioncolumn&gt;</term>
	<listitem
><para
>Declara una «optioncolumn» del conjunt. Per a cada valor que voleu obtenir des de l'«optionset», haureu de declarar una &lt;optioncolumn&gt; separada. Atributs: <variablelist>
			<varlistentry
><term
><parameter
>id</parameter
></term>
			<listitem
><para
>L'identificador de l'«optioncolumn» (requerit, cadena).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>external</parameter
></term>
			<listitem
><para
>Establiu-ho a «true» (cert), si l'«optioncolumn» es controla des de fora de l'«optionset» (opcional, booleà, el valor predeterminat és "false").</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>label</parameter
></term>
			<listitem
><para
>Si s'indica, l'«optioncolumn» es mostrarà en una columna amb aquesta etiqueta (opcional, cadena, de manera predeterminada no es mostrarà).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>connect</parameter
></term>
			<listitem
><para
>La propietat a la qual connectar aquesta «optioncolumn», donada com a «id» dins de l'àrea &lt;content&gt;. Per a &lt;optioncolumn&gt; externes, el valor corresponent s'establirà al valor establert externament. Per a les &lt;optioncolumn&gt; normals (no externes), la fila corresponent de la propietat &lt;optioncolumn&gt; s'establirà quan la propietat canviï dins de l'àrea de contingut. (Opcional, cadena, de manera predeterminada no està connectada).</para
></listitem
></varlistentry>
			<varlistentry
><term
><parameter
>default</parameter
></term>
			<listitem
><para
>Només per a columnes externes: el valor que s'ha d'assumir per a aquesta columna, si no es coneix cap valor per a una entrada. És útil rares vegades. (Opcional, el valor predeterminat és una cadena buida)</para
></listitem
></varlistentry>
		</variablelist>
	</para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;content&gt;</term>
	<listitem
><para
>Declara el contingut/IU del conjunt. Sense atributs. Es permeten tots els elements actius, passius i de disposició habituals com a elements de nom fill. A més, en versions anteriors del &rkward; (fins a 0,6.3), es va permetre l'element fill especial <command
>&lt;optiondisplay&gt;</command
>. Això és obsolet en el &rkward; 0.6.4, i simplement s'hauria d'eliminar dels connectors existents. </para
></listitem
></varlistentry>
	<varlistentry>
	<term
>&lt;logic&gt;</term>
	<listitem
><para
>Especificació opcional de la lògica de la IU a aplicar <emphasis
>dins de</emphasis
> la regió de contingut de l'«optionset». Vegeu <link linkend="logicelements"
>la referència a &lt;logic&gt;</link
> </para
></listitem
></varlistentry>
	</variablelist>
</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>Un element dissenyat per a seleccionar un únic nom de fitxer (o nom de directori). Tingueu en compte que aquest camp prendrà qualsevol cadena, encara que estigui destinada a utilitzar-se només per a fitxers: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al navegador (opcional, el valor predeterminat és "Enter filename")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Text inicial del navegador (opcional, predeterminat a "", &ead;, una cadena buida)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Un d'entre "file", "dir", o "savefile". Per a seleccionar un fitxer existent, un directori existent o un fitxer no existent, respectivament (opcional, el valor predeterminat és "file")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>allow_urls</parameter
></term>
	<listitem
><para
>Si es poden seleccionar &URL; (no locals) (opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>filter</parameter
></term>
	<listitem
><para
>Filtre del tipus de fitxer, &pex; ("*.txt *.csv" per als fitxers .txt i .csv). Automàticament s'afegeix una entrada separada per a "All files" (opcional, per defecte a "", &ead; "All files")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Si es requereix que per a enviar el codi el camp no estigui buit. Tingueu en compte que això no significa necessàriament que el nom de fitxer seleccionat sigui vàlid. Vegeu la <link linkend="elementproperties"
>propietat requerida</link
> (opcional, predeterminat a "true")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>Un element dissenyat per a seleccionar el nom d'un objecte &R; a on desar (&ead;, generalment no existeix prèviament, en contrast amb un «varslot»): <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per a l'entrada (opcional, predeterminada a "Save to:")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>Text inicial de l'entrada (opcional, predeterminat a "my.data")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>required</parameter
></term>
	<listitem
><para
>Si es requereix que per a enviar el codi el camp tingui un nom d'objecte admès. Vegeu la <link linkend="elementproperties"
>propietat requerida</link
> (opcional, predeterminat a "true")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checkable</parameter
></term>
	<listitem
><para
>En molts casos d'ús, desar a un objecte &R; és opcional. En aquests casos, es pot integrar una casella de selecció a l'element «saveobject» usant aquest atribut. Quan s'estableix a «true» (cert), la casella de selecció activarà/desactivarà el «saveobject». Vegeu la <link linkend="elementproperties"
>propietat activa</link
> de «saveobject» (opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>checked</parameter
></term>
	<listitem
><para
>Per a elements «saveobject» seleccionables, només: si el control està marcat/activat de manera predeterminada (opcional, el valor predeterminat és "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>Un «spinbox» en el qual l'usuari pot seleccionar un valor numèric, utilitzant l'entrada directa del teclat o les fletxes amunt/avall petites. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta per al «spinbox» (recomanada, la predeterminada és «Enter value:»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>El valor més baix que l'usuari pot introduir en el «spinbox» (opcional, de manera predeterminada el valor més baix que es pot representar tècnicament en el «spinbox»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>El valor més gran que l'usuari pot introduir al botó de selecció de valors (opcional, de manera predeterminada el valor més alt que es pot representar tècnicament en el «spinbox»)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>initial</parameter
></term>
	<listitem
><para
>El valor inicial que es mostra al botó de selecció de valors (opcional, el valor predeterminat és "0")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>type</parameter
></term>
	<listitem
><para
>Un entre "real" o "integer". Si el botó de selecció de valors accepta nombres reals o només enters (opcional, el valor predeterminat és "real")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default_precision</parameter
></term>
	<listitem
><para
>Només té sentit si el «spinbox» és de tipus="real". Especifica el nombre predeterminat de xifres decimals que es mostren al botó de selecció de valors (només es mostraran aquests zeros finals). Quan l'usuari prem les fletxes amunt/avall, aquest lloc decimal es canviarà. Tanmateix, l'usuari pot ser capaç d'introduir valors amb una precisió més alta (vegeu més avall) (opcional, predeterminat a "2")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max_precision</parameter
></term>
	<listitem
><para
>El nombre màxim de dígits que es poden representar significativament (opcional, predeterminat a "8")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>Aquest element avançat permet a l'usuari seleccionar una fórmula/conjunt d'interaccions a partir de les variables seleccionades. Per exemple, per un GLM, aquest element es pot utilitzar per a permetre a l'usuari especificar els termes d'interacció en el model. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>fixed_factors</parameter
></term>
	<listitem
><para
>L'ID del «varslot» que conté els factors fixos seleccionats (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dependent</parameter
></term>
	<listitem
><para
>L'ID del «varslot» que conté la variable dependent seleccionada (requerit)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Incrusta un connector diferent en aquest (vegeu el <link linkend="embedding"
>capítol sobre la incrustació</link
>). Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>component</parameter
></term>
	<listitem
><para
>El nom registrat del component a incrustar (vegeu el <link linkend="pluginmap"
>capítol sobre el registre de components</link
>) (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>as_button</parameter
></term>
	<listitem
><para
>Si s'estableix a "true", només es col·locarà un botó a la &IGU; incrustada, la &IGU; incrustada només es mostrarà (en una finestra separada) quan es premi el botó (opcional, de manera predeterminada és "false")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Només té sentit si as_button="true": l'etiqueta del botó (recomanada, la predeterminada és «Options»)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>Una casella de selecció per a commutar la funcionalitat de vista prèvia. Tingueu en compte que a partir de la versió 0.6.5 del &rkward; els elements de vista prèvia <command
>&lt;preview&gt;</command
> són casos especials en els diàlegs de connectors (no assistents): es col·locaran a la columna de botons, independentment d'on estiguin exactament definits a la interfície d'usuari. Continua sent una bona idea definir-les en un lloc assenyat de la disposició, per a la compatibilitat cap endarrere. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>Etiqueta del quadre (opcional, el valor predeterminat és "Preview")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>Tipus de vista prèvia. Els tipus admesos són "plot" (vegeu el <link linkend="preview_plots"
>capítol sobre les previsualitzacions de gràfics</link
>), "output" (vegeu el <link linkend="preview_output"
>capítol sobre les previsualitzacions de sortida (&HTML;)</link
>, "data" (vegeu les <link linkend="preview_data"
>previsualitzacions de dades</link
>), i "custom" (vegeu les <link linkend="preview_custom"
>previsualitzacions personalitzades </link
>). (Opcional, el valor predeterminat és "plot")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>placement</parameter
></term>
	<listitem
><para
>Col·locació de la vista prèvia: "attached" (al lloc de treball principal), "detached" (finestra independent), "docked" (adjunt al diàleg del connector) i "default" (actualment és el mateix que "docked", però pot arribar a ser configurable per l'usuari en algun moment). En general, es recomana deixar-ho com a paràmetre predeterminat per a la millor coherència de la interfície d'usuari (opcional, el valor predeterminat és "default")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>active</parameter
></term>
	<listitem
><para
>Si la vista prèvia està activa de manera predeterminada. En general, només les vistes prèvies acoblades es faran actives de manera predeterminada, i fins i tot per a aquestes, hi ha un motiu pel qual el valor predeterminat és de vistes prèvies inactives (opcional, el valor predeterminat és "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2 id="logicelements"
><title
>Secció de lògica</title>
<variablelist>
<varlistentry>
<term
>&lt;logic&gt;</term>
<listitem
><para
>L'element que conté la secció lògica. Tots els elements següents només es permeten dins de l'element &lt;logic&gt;. L'element &lt;logic&gt; només es permet com a fill directe de l'element &lt;document&gt; (com a màxim una vegada per document), o dels elements &lt;optionset&gt; (com a màxim una vegada per «optionset»). La secció lògica del document s'aplica tant a la IGU de &lt;dialog&gt; com a &lt;wizard&gt; de la mateixa manera.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;external&gt;</term>
<listitem
><para
>Crea una propietat nova (cadena) que se suposa que està connectada a una propietat externa si el connector s'incrusta. Vegeu la <link linkend="embedding_incomplete"
>secció sobre els connectors «incomplets»</link
>. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID de la propietat nova (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>default</parameter
></term>
	<listitem
><para
>El valor predeterminat de la cadena de la propietat nova, &ead;, el valor utilitzat si la propietat no està connectada a una propietat externa (opcional, el valor predeterminat és una cadena buida)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;i18n&gt;</term>
<listitem
><para
>Crea una propietat nova (cadena) que se suposa que proporciona una etiqueta que es pot traduir (i18n). Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID de la propietat nova (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>label</parameter
></term>
	<listitem
><para
>L'etiqueta. Això es traduirà. (Requerida)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;set&gt;</term>
<listitem
><para
>Estableix una propietat a un valor fix (per descomptat, si connecteu addicionalment la propietat a alguna altra propietat, el valor no es manté fix). Per exemple, si incrusteu un connector, però voleu ocultar alguns dels seus elements, podeu establir la propietat de visibilitat d'aquests elements a fals. Especialment útil per a connectors incrustats/incrustants. Nota: si hi ha diversos elements &lt;set&gt; per a un únic <parameter
>id</parameter
>, l'últim a definir tindrà prioritat. Això de vegades serà útil per a confiar quan s'usin les parts &lt;include&gt;. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID de la propietat a establir (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>to</parameter
></term>
	<listitem
><para
>El valor de la cadena a establir la propietat (requerit). Nota: Per a les propietats booleanes com la visibilitat, l'habilitació, normalment establireu l'atribut a «to="true"» o a «to="false"».</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Crea una propietat booleana nova que depèn de l'estat d'una o més propietats diferents. Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID de la propietat nova (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>sources</parameter
></term>
	<listitem
><para
>Els identificadors de les propietats de les quals dependrà aquesta propietat. Es poden especificar una o més propietats, separades per «;» (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>mode</parameter
></term>
	<listitem
><para
>El mode de conversió/operació. Un d'entre "equals", "notequals", "range", "and", "or". Si és en mode "equals", la propietat només serà certa si el valor de totes les seves fonts és igual que l'estàndard de l'atribut (vegeu a sota). Si està en el mode "notequals", la propietat només serà certa si el valor de totes les seves fonts són diferents de l'estàndard de l'atribut (vegeu a sota). Si està en mode "range", les fonts han de ser numèriques (entera o real). La propietat només serà certa, si totes les fonts estan en l'interval especificat pels atributs mín i màx. Si està en mode "and", les fonts han de ser propietats booleanes. La propietat només serà certa, si totes les fonts són certes simultàniament. Si està en mode "or", les fonts han de ser propietats booleanes. La propietat només serà certa, si almenys una de les fonts és certa. (Requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Només té sentit en els modes "equal" o "notequals": el valor de la cadena contra el qual comparar (requerit si està en un d'aquests modes)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>min</parameter
></term>
	<listitem
><para
>Només té sentit en el mode "range": el valor mínim contra el qual comparar (opcional, predeterminat al número de coma flotant més baix representable a la màquina)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>max</parameter
></term>
	<listitem
><para
>Només té sentit en el mode "range": el valor màxim contra el qual comparar (opcional, predeterminat al número de coma flotant més gran representable a la màquina)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>require_true</parameter
></term>
	<listitem
><para
>Si s'estableix a "true", la propietat serà obligatòria, i només es considerarà vàlida si el seu estat és cert/activat. Per tant, si la propietat és falsa, bloquejarà el botó <guibutton
>Envia</guibutton
> (opcional, el valor predeterminat és "false"). <caution
><para
>Si utilitzeu això, assegureu-vos que l'usuari pot detectar fàcilment el què està malament, com ara mostrar un &lt;text&gt; d'explicació.</para
></caution
></para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Crea una propietat nova que retransmetrà a diferents propietats de destinació (o cadenes fixes) en funció del valor d'una propietat de condició. Això permet crear una lògica similar a les construccions <function
>if()</function
> o <function
>switch()</function
>. Atributs:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>id</parameter
></term>
	<listitem
><para
>L'ID de la propietat nova (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>condition</parameter
></term>
	<listitem
><para
>L'identificador de la propietat de condició (requerit)</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elements fills:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;true&gt;</term>
	<listitem
><para
>Si la propietat condició és booleana, podeu especificar els dos elements fills &lt;true&gt; i &lt;false&gt; (i només aquests). (Requerit, si també es proporciona &lt;false&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;false&gt;</term>
	<listitem
><para
>Si la propietat condició és booleana, podeu especificar els dos elements fills &lt;true&gt; i &lt;false&gt; (i només aquests). (Requerit, si també es proporciona &lt;true&gt;)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;case&gt;</term>
	<listitem
><para
>Si la propietat condició no és booleana, podeu proporcionar un nombre arbitrari d'elements &lt;case&gt;, un per a cada valor de la propietat condició que voleu que coincideixi (almenys es requereix un d'aquests elements, si la propietat condició no és booleana)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;default&gt;</term>
	<listitem
><para
>Si la propietat condició no és booleana, l'element opcional &lt;default&gt; permet especificar el comportament, si no hi ha cap element &lt;case&gt; que coincideixi amb el valor de la propietat condició (opcional, permès només una vegada, en combinació amb un o més elements &lt;case&gt;).</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Els elements fills &lt;true&gt;, &lt;false&gt;, &lt;case&gt;, i &lt;default&gt; prenen els atributs següents:</para>
	<variablelist>
	<varlistentry>
	<term
><parameter
>standard</parameter
></term>
	<listitem
><para
>Només per als elements &lt;case&gt;: el valor amb el qual coincidir la propietat condició (requerit, cadena).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>fixed_value</parameter
></term>
	<listitem
><para
>Una cadena fixa que s'ha de proporcionar com el valor de la propietat &lt;switch&gt;, si la condició actual coincideix (requerit, si no es proporciona dynamic_value).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>dynamic_value</parameter
></term>
	<listitem
><para
>L'<parameter
>id</parameter
> de la propietat de destinació que s'ha de proporcionar com el valor de la propietat &lt;switch&gt;, si la condició actual coincideix (requerit, si no es proporciona fixed_value).</para
></listitem>
	</varlistentry>
	</variablelist>
	</listitem>
</varlistentry>

<varlistentry>
<term
>&lt;connect&gt;</term>
<listitem
><para
>Connecta dues propietats. La propietat del client es canviarà sempre que la propietat del governador canviï (però no a l'inrevés). Atributs: <variablelist>
	<varlistentry>
	<term
><parameter
>client</parameter
></term>
	<listitem
><para
>L'ID de la propietat del client, &ead;, la propietat que s'ajustarà (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>governor</parameter
></term>
	<listitem
><para
>L'ID de la propietat del governador, &ead;, la propietat que ajustarà la propietat del client. Això pot incloure un modificador (requerit)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>reconcile</parameter
></term>
	<listitem
><para
>Si és «true», la propietat del client ajustarà la propietat del governador en la connexió de tal manera que la propietat del governador només acceptarà valors que també siguin acceptables pel client (&pex;, suposem que el governador és una propietat numèrica amb valor mínim «0», i el client és una propietat numèrica amb valor mínim «100». El mínim d'ambdues propietats s'ajustarà a 100, si reconcile="true"). Generalment només funciona per a propietats del mateix tipus bàsic (opcional, predeterminat a "false")</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dependency_check&gt;</term>
<listitem
><para
>Crea una propietat booleana que és certa, si es compleixen les dependències especificades, falsa en cas contrari. La sintaxi &XML; de l'element és la mateixa que la de l'element <command
>&lt;dependencies&gt;</command
>, descrit en la <link linkend="pluginmapelements"
>referència del &pluginmap;</link
>. A partir del &rkward; 0.6.1, només es tindran en compte les especificacions de versió del &rkward; i &R;, no les dependències en els paquets o els &pluginmap;.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;script&gt;</term>
<listitem
><para
>Defineix el codi de script per a controlar la lògica de la IU. Vegeu la <link linkend="logic_scripted"
>secció sobre la lògica de script de GUJI</link
> per a més detalls. El codi de l'script a executar es pot donar utilitzant l'atribut <parameter
>"file"</parameter
>, o com un text (comentat) de l'element. L'element <command
>&lt;script&gt;</command
> no està permès a la secció <command
>&lt;logic&gt;</command
> d'un «optionset». Atributs: <variablelist
> <varlistentry>
	<term
><parameter
>file</parameter
></term>
	<listitem
><para
>Nom de fitxer del fitxer de script. (Requerit)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

</variablelist>
</sect2>

</sect1
>	<!-- Elements in main XML -->

<sect1 id="elementproperties"
><title
>Propietats dels elements del connector</title>
<para
>Tots els <link linkend="layoutelements"
>elements de disposició</link
>, i tots els <link linkend="activeelements"
>elements actius</link
> tenen les propietats següents, accessibles a través de "id_of_element.name_of_property": </para>
<variablelist>
<varlistentry>
<term
>visible</term>
<listitem
><para
>Si l'element de la &IGU; és visible o no (booleà)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>enabled</term>
<listitem
><para
>Si l'element de la &IGU; està habilitat o no (booleà)</para
></listitem>
</varlistentry>
<varlistentry>
<term
>required</term>
<listitem
><para
>Si es requereix o no l'element de la &IGU; (per a mantenir una configuració vàlida). Tingueu en compte que qualsevol element que estigui desactivat o ocult també és implícitament no requerit (booleà).</para
></listitem>
</varlistentry>
</variablelist>
<para
>A més d'això, alguns elements tenen propietats addicionals a les quals es pot connectar. La majoria dels elements actius també tenen una propietat "default", el valor de la qual es retornarà en les crides a <function
>getBoolean/getString/getList ("...")</function
>, si no s'ha nomenat cap propietat específica, com es descriu a continuació. </para>

<variablelist>
<varlistentry>
<term
>&lt;text&gt;</term>
<listitem
><para
>La propietat predeterminada és text <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>El text mostrat (text)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varselector&gt;</term>
<listitem
><para
>Sense propietat predeterminada <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Els objectes actualment seleccionats. Probablement, no voldreu utilitzar això. Usat internament (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>root</term>
	<listitem
><para
>L'objecte arrel/pare dels objectes oferts per a la selecció (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;varslot&gt;</term>
<listitem
><para
>La propietat predeterminada és "available" (disponible) <variablelist>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>Tots els objectes continguts en el «varslot» (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Dels objectes que hi ha al «varslot», els que estan seleccionats actualment. Probablement, no voldreu utilitzar això. Usat internament (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>source</term>
	<listitem
><para
>Una còpia dels objectes seleccionats en el «varselector» corresponent. Probablement no volen utilitzar això. Usat internament (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueselector&gt;</term>
<listitem
><para
>La propietat predeterminada és "selected" <variablelist>
	<varlistentry>
	<term
>selected</term>
	<listitem
><para
>Les cadenes actualment seleccionades. Modificador "labeled" per a recuperar les etiquetes corresponents. En un &lt;valueselector&gt; probablement no el voldreu utilitzar directament (només en un &lt;select&gt;). (Llegeix/escriu StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>available</term>
	<listitem
><para
>La llista de valors de cadena de la qual seleccionar. (Llegeix/escriu StringList)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Etiquetes a mostrar per als valors de cadena. (Llegeix/escriu StringList)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;valueslot&gt;</term>
<listitem
><para
>El mateix que &lt;varslot&gt;, però les propietats són llistes de cadenes, en lloc de RObjects.</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;radio&gt;</term>
<listitem
><para
>La propietat predeterminada és "string" <variablelist>
	<varlistentry>
	<term
>string</term>
	<listitem
><para
>El valor de l'opció actualment seleccionada (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>number</term>
	<listitem
><para
>El nombre de l'opció actualment seleccionada (les opcions estan numerades de dalt a baix, començant en el 0) (enter)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;dropdown&gt;</term>
<listitem
><para
>El mateix que &lt;radio&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;select&gt;</term>
<listitem
><para
>El mateix que &lt;valueselector&gt;</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;option&gt;</term>
<listitem
><para
>No hi ha cap propietat per defecte. "enabled" és la *única* propietat, i actualment no està disponible per a opcions dins de &lt;select&gt; o &lt;valueselector&gt;. &lt;option&gt; no té les propietats "visible" o "required". <variablelist
> <varlistentry>
	<term
>enabled</term>
	<listitem
><para
>Si s'ha d'activar o desactivar aquesta opció única. En la majoria dels casos activareu/desactivareu tot el &lt;radio&lt; o &lt;dropdown&lt;. Però això es pot utilitzar per a establir dinàmicament l'activació d'una opció única dins d'un &lt;radio&lt; o &lt;dropdown&lt; (booleà)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;checkbox&gt;</term>
<listitem
><para
>La propietat predeterminada és "state.labeled", el qual vol dir que es retornen els valors especificats pels atributs <parameter
>value</parameter
>, i <parameter
>value_unchecked</parameter
>, <emphasis
>no</emphasis
> l'etiqueta mostrada de la casella de selecció. <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Estat de la casella de selecció (activada o desactivada). Tingueu en compte que els modificadors útils d'aquesta propietat (com totes les propietats booleanes) són "not" i "labeled" (vegeu <link linkend="propertytypes"
>tipus de propietats</link
>). No obstant això, sovint és més útil connectar a la propietat sense modificador, &ead;, "<emphasis
>checkbox_id</emphasis
>.state", el qual retornarà l'estat de la casella de selecció en un format adequat per al seu ús en una declaració "if" (0 o 1). (Booleà)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;frame&gt;</term>
<listitem
><para
>La propietat predeterminada és "checked", si (i només si) el marc es pot marcar. Per als marcs que no es poden marcar, no hi ha cap propietat per defecte. <variablelist
> <varlistentry>
	<term
>checked</term>
	<listitem
><para
>Disponible només per als marcs que es poden marcar: estat de la casella de selecció (activada o desactivada). Tingueu en compte que els modificadors útils d'aquesta propietat (com totes les propietats booleanes) són "not" i "numeric" (vegeu <link linkend="propertytypes"
>tipus de propietats</link
>). (Booleà)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;input&gt;</term>
<listitem
><para
>La propietat predeterminada és "text" <variablelist
> <varlistentry>
	<term
>text</term>
	<listitem
><para
>Text actual en el camp d'entrada (cadena)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;matrix&gt;</term>
	<listitem
><para
>La propietat predeterminada és "cbind". <variablelist>
		<varlistentry>
			<term
>rows</term>
			<listitem
><para
>Nombre de files a la matriu (enter). Si la matriu permet a l'usuari afegir/eliminar files, aquesta propietat s'ha de tractar com de només lectura. En cas contrari, canviant-la, es canviarà la mida de la matriu.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>columns</term>
			<listitem
><para
>Nombre de columnes a la matriu (enter). Si la matriu permet a l'usuari afegir/eliminar columnes, aquesta propietat s'ha de tractar com de només lectura. En cas contrari, canviant-la, es canviarà la mida de la matriu.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>tsv</term>
			<listitem
><para
>Dades en la matriu en format «tsv» (cadena; lectura-escriptura). Tingueu en compte que en comparació amb la disposició «tsv» habitual, les <emphasis
>columnes</emphasis
>, no files, estan separades per caràcters de línia nova, i les cel·les dins d'una columna estan separades per caràcters tabuladors.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>0,1,2...</term>
			<listitem
><para
>Les dades d'una sola columna (0 per a la columna més a l'esquerra). <function
>getValue()</function
>/<function
>getString()</function
> retorna això com una sola cadena, separada per «\n». No obstant això, la manera recomanada d'obtenir-ho és utilitzant <function
>getList()</function
>, que retorna aquesta columna com una matriu de cadenes.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>row.0,row.1,row.2...</term>
			<listitem
><para
>Les dades d'una sola fila (0 per a la fila superior). <function
>getValue()</function
>/<function
>getString()</function
> retorna això com una sola cadena, separada per «\n». No obstant això, la manera recomanada d'obtenir-ho és utilitzant <function
>getList()</function
>, que retorna aquesta fila com una matriu de cadenes.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>cbind</term>
			<listitem
><para
>Dades en un format adequat per a enganxar a &R;, embolcallades en una expressió «cbind» (cadena; només lectura).</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
	<term
>&lt;optionset&gt;</term>
	<listitem
><para
>No hi ha cap propietat predeterminada. <variablelist>
		<varlistentry>
			<term
>row_count</term>
			<listitem
><para
>Nombre d'elements a l'«optionset» (enter). Només lectura.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
>current_row</term>
			<listitem
><para
>Element actualment actiu a l'«optionset» (enter). -1 per a cap element actiu. Lectura i escriptura.</para
></listitem>
		</varlistentry>
		<varlistentry>
			<term
><emphasis
>optioncolumn_ids</emphasis
></term>
			<listitem
><para
>Per a cada &lt;optioncolumn&gt; que definiu, es crearà una propietat de llista de cadenes amb l'identificador especificat.</para
></listitem>
		</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;browser&gt;</term>
<listitem
><para
>La propietat predeterminada és "selection" <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Text actual (nom de fitxer seleccionat) al navegador (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
><parameter
>overwrite</parameter
></term>
	<listitem
><para
>Si l'opció «overwrite» està marcada (booleana, només lectura, és a dir, per programa es pot llegir l'estat de la casella de selecció, però no canviar-la)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;saveobject&gt;</term>
<listitem
><para
>La propietat predeterminada és "selection" <variablelist>
	<varlistentry>
	<term
>selection</term>
	<listitem
><para
>Nom complet de l'objecte seleccionat (cadena; només lectura, per a establir-ho des del programa utilitzeu "parent" i "objectname")</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>parent</term>
	<listitem
><para
>L'objecte pare de l'objecte seleccionat. Aquest sempre és un objecte &R; existent d'un tipus que pot contenir altres objectes (&pex;, una llista o un «data.frame»). Quan s'estableix a una cadena buida o a un objecte no vàlid, s'assumeix ".GlobalEnv" (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>objectname</term>
	<listitem
><para
>El nom base de l'objecte seleccionat, &ead;, la cadena introduïda per l'usuari (canviada a un nom &R; vàlid, si cal) (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>active</term>
	<listitem
><para
>Només per a «saveobject» que es puguin marcar: si el control està activat/activat. Sempre cert per als «saveobject» que no es poden marcar (booleà)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;spinbox&gt;</term>
<listitem
><para
>La propietat predeterminada és "int" o "real.formatted", depenent del mode del botó de selecció de valors <variablelist>
	<varlistentry>
	<term
>int</term>
	<listitem
><para
>Valor enter que té el botó de selecció de valors, o enter més proper, si està en mode real (enter)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>real</term>
	<listitem
><para
>Valor real que té el botó de selecció de valors (o enter, si és enter) (real)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;formula&gt;</term>
<listitem
><para
>La propietat predeterminada és "model" <variablelist>
	<varlistentry>
	<term
>model</term>
	<listitem
><para
>La cadena del model actual (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>table</term>
	<listitem
><para
>El «data.frame» conté les variables requerides. Si només s'utilitzen variables d'un «data.frame», es retornarà el nom d'aquest «data.frame». Altrament es construeix un «data.frame» nou segons sigui necessari (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Si estan implicades les variables de diversos «data.frames», els seus noms es poden barrejar (per exemple, si ambdós «data.frames» contenen una variable anomenada «x»). Això retorna una llista amb els noms entrellaçats com a índexs i l'etiqueta descriptiva com a valor (cadena)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>fixed_factors</term>
	<listitem
><para
>Els factors fixos. Probablement no voldreu utilitzar això. Usat internament (RObject)</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>dependent</term>
	<listitem
><para
>Les variables dependents. Probablement no voldreu utilitzar això. Usat internament (RObject)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;embed&gt;</term>
<listitem
><para
>Sense propietat predeterminada <variablelist
> <varlistentry>
	<term
>code</term>
	<listitem
><para
>El codi generat pel connector incrustat (codi)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;preview&gt;</term>
<listitem
><para
>La propietat predeterminada és "state" <variablelist
> <varlistentry>
	<term
>state</term>
	<listitem
><para
>Si la casella de previsualització està marcada (no necessàriament si ja s'ha mostrat la previsualització) (booleà)</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;convert&gt;</term>
<listitem
><para
>Aquest element (utilitzat a la secció &lt;logic&gt;) és especial, ja que tècnicament *és* una propietat, en lloc de només tenir una o més propietats. És de tipus booleà. Tingueu en compte que els modificadors útils d'aquesta propietat (com totes les propietats booleanes) són "not" i "numeric" (vegeu <link linkend="propertytypes"
>tipus de propietats</link
>)</para
></listitem>
</varlistentry>

<varlistentry>
<term
>&lt;switch&gt;</term>
<listitem
><para
>Aquest element (utilitzat a la secció &lt;logic&gt;) és especial, ja que tècnicament *és* una propietat (cadena), en lloc de només tenir una o més propietats. Permet canviar entre diverses propietats de destinació depenent del valor d'una propietat de condició, o per a tornar a assignar els valors de la propietat de condició. Qualsevol modificador que proporcioneu es transmet a les propietats de destinació, per tant, &pex;, si totes les propietats de destinació són propietats RObject, també podreu utilitzar el modificador "shortname" al commutador. No obstant això, si les propietats de destinació són de tipus diferents, l'ús de modificadors pot provocar errors. Pels <replaceable
>fixed_value</replaceable
>, s'elimina qualsevol modificador, en silenci. Tingueu en compte que les propietats de destinació, quan s'accedeix a través d'un commutador, sempre són de només lectura.</para
></listitem>
</varlistentry>

</variablelist>
</sect1>

<sect1 id="standard_embeddable_plugins"
><title
>Connectors incrustables distribuïts amb la versió oficial del &rkward;</title>
<para
>Amb el &rkward; es distribueixen una sèrie de connectors incrustables, i es poden utilitzar en els vostres propis connectors. Actualment, la documentació detallada només està disponible en aquests fitxers de codi font o d'ajuda dels connectors. No obstant això, aquí hi ha una llista per a donar-vos una visió ràpida del que hi ha disponible:</para>
<table frame='all'
><title
>Connectors incrustables estàndards</title>
<tgroup cols='4'>
<thead>
<row>
  <entry
>ID</entry>
  <entry
>Pluginmap</entry>
  <entry
>Descripció</entry>
  <entry
>Exemple d'ús</entry>
</row>
</thead>
<tbody>
<row>
  <entry
>rkward::plot_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Proporciona una gran varietat d'opcions per als diagrames. La majoria dels connectors de traçat utilitzen això.</entry>
  <entry
>Diagrames->Diagrama de barres, la majoria dels altres connectors de traçat</entry>
</row>
<row>
  <entry
>rkward::color_chooser</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Connector molt senzill per a especificar un color. La implementació actual proporciona una llista de noms de color. Les implementacions futures poden proporcionar una tria de colors més elaborada.</entry>
  <entry
>Diagrames->Histograma</entry>
</row>
<row>
  <entry
>rkward::plot_stepfun_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opcions de diagrama amb funció esglaonada</entry>
  <entry
>Diagrames->Diagrama ECDF</entry>
</row>
<row>
  <entry
>rkward::histogram_options</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opcions de l'histograma (diagrama)</entry>
  <entry
>Diagrames->Histograma</entry>
</row>
<row>
  <entry
>rkward::barplot_embed</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Opcions del diagrama de barres</entry>
  <entry
>Diagrames->Diagrama de barres</entry>
</row>
<row>
  <entry
>rkward::one_var_tabulation</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Proporciona tabulació en una variable única.</entry>
  <entry
>Diagrames->Diagrama de barres</entry>
</row>
<row>
  <entry
>rkward::limit_vector_length</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Limita la longitud d'un vector (als n elements més grans o més petits).</entry>
  <entry
>Diagrames->Diagrama de barres</entry>
</row>
<row>
  <entry
>rkward::level_select</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Proporciona un &lt;valueselector&gt; ple amb els nivells (o valors únics) d'un vector.</entry>
  <entry
>Dades->Recodifica dades categòriques</entry>
</row>
<row>
  <entry
>rkward::multi_input</entry>
  <entry
>embedded.pluginmap</entry>
  <entry
>Combina els botons de selecció de valors, entrada i control d'opcions per a proporcionar entrada de dades de caràcters, numèriques i lògiques.</entry>
  <entry
>Dades->Recodifica dades categòriques</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>

<sect1 id="pluginmapelements"
><title
>Elements que s'utilitzaran en els fitxers &pluginmap;</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Cal que estigui present a cada fitxer &pluginmap; com a node arrel (exactament una vegada). Atributs: <variablelist>
	<varlistentry>
	<term
>base_prefix</term>
	<listitem
><para
>Els noms de fitxer especificats al fitxer &pluginmap; s'assumeixen que són relatius al directori del fitxer &pluginmap; + el prefix que especifiqueu aquí. Especialment útil si tots els vostres components es troben sota un únic subdirectori.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>namespace</term>
	<listitem
><para
>Un espai de noms ("namespace") per als identificadors dels components. Quan se cerquin components per a incrustar-los, els components es podran recuperar mitjançant una cadena "namespace::component_id". Establert a "rkward" per ara.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Una cadena d'identificador opcional per a aquest &pluginmap;. Especificar això permet als autors tercers referir-se i carregar el vostre &pluginmap; des del seu (vegeu el <link linkend="chapter_dependencies"
>capítol sobre la gestió de les dependències</link
>).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>priority</term>
	<listitem
><para
>Un d'entre <replaceable
>"hidden"</replaceable
>, <replaceable
>"low"</replaceable
>, <replaceable
>"medium"</replaceable
>, o <replaceable
>"high"</replaceable
>. Els &pluginmap; amb prioritat «medium» o «high» s'activen automàticament quan el &rkward; els troba per primera vegada. Utilitzeu <replaceable
>priority="hidden"</replaceable
> per als &pluginmap; que no estan destinats a ser activats, el directori (només per a la inclusió). En la implementació actual això no oculta realment el &pluginmap;. (Opcional, el valor predeterminat és "medium").</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;dependencies&gt;</term>
<listitem
><para
>Aquest element, especificant dependències, es permet com a fill directe de l'element &lt;document&gt; (un cop), i com a fill dels elements &lt;component&gt; (un cop per a cada element &lt;component&gt;). Especifica les dependències que s'han de complir per a utilitzar els connectors. Consulteu el <link linkend="chapter_dependencies"
>capítol sobre dependències</link
> per a una visió general. Atributs:</para>
	<variablelist>
	<varlistentry>
	<term
>rkward_min_version, rkward_max_version</term>
	<listitem
><para
>Versió mínima i màxima permesa del &rkward;. Les especificacions de versió poden incloure sufixos no numèrics, com "0.5.7z-devel1". Si no es compleix una dependència especificada, el/s connector/s al/s que s'aplica <emphasis
>s'ignorarà</emphasis
>. <link linkend="sect_dependencies_rkward_version"
>Més informació</link
>. Opcional; si no s'especifica, no es requerirà cap versió mínima/màxima del &rkward;.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>R_min_version, R_max_version</term>
	<listitem
><para
>Versió mínima i màxima permesa de l'&R;. Les especificacions de versió poden <emphasis
>no</emphasis
> incloure sufixos no numèrics, com "0.5.7z-devel1". La dependència de la versió de l'&R; es mostrarà a les pàgines d'ajuda dels connectors, però no té cap efecte directe, a partir del &rkward; 0.6.1. <link linkend="sect_dependencies_r_version"
>Més informació</link
>. Opcional; si no s'especifica, no es requerirà cap versió mínima/màxima de l'&R;.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elements fills:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;package&gt;</term>
	<listitem
><para
>Afegeix una dependència d'un paquet &R; específic. Atributs: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Nom del paquet (requerit).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Versió mínima/màxima permesa (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>repository</term>
		<listitem
><para
>Dipòsit on es troba el paquet. Opcional, però molt recomanat, si el paquet no està disponible al CRAN.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>&lt;pluginmap&gt;</term>
	<listitem
><para
>Afegeix una dependència d'un &pluginmap; específic del &rkward;. Atributs: <variablelist>
		<varlistentry>
		<term
>name</term>
		<listitem
><para
>Cadena d'«id» del connector &pluginmap; requerit (requerit).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>min_version, max_version</term>
		<listitem
><para
>Versió mínima/màxima permesa (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>&URL; on es pot trobar el &pluginmap;. Requerit.</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;about&gt;</term>
<listitem
><para
>Pot estar present exactament una vegada com a fill directe de l'element &lt;document&gt;. Conté la metainformació sobre el &pluginmap; (o connector). Consulteu el <link linkend="chapter_about_information"
>capítol sobre la informació «about»</link
> per a obtenir una visió general. Atributs:</para>
	<variablelist>
	<varlistentry>
	<term
>name</term>
	<listitem
><para
>Nom visible de l'usuari. Opcional. No ha de ser el mateix que "id".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>version</term>
	<listitem
><para
>Número de versió. Opcional. El format no està restringit, però per a estar sobre segur, seguiu esquemes de versions habituals com ara "x.y.z".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>releasedate</term>
	<listitem
><para
>Especificació de data de publicació. Opcional en format "AAAA-MM-DD".</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>shortinfo</term>
	<listitem
><para
>Una descripció <emphasis
>curta</emphasis
> del connector/&pluginmap;. Opcional.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>url</term>
	<listitem
><para
>&URL; a on es pot trobar més informació. Opcional, però recomanat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>copyright</term>
	<listitem
><para
>Especificació del copyright, &pex;, "2012-2013 de John Doe". Opcional, però recomanat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>licence</term>
	<listitem
><para
>Especificació de la llicència, &pex;, «GPL» o «BSD». Assegureu-vos d'acompanyar els fitxers amb una còpia completa de la llicència corresponent. Opcional, però recomanat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>category</term>
	<listitem
><para
>Categoria del/s connector/s, &pex;, «Teoria de resposta d'elements». A partir del &rkward; 0.6.1, no hi ha categories predefinides. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist>
<para
>Elements fills:</para>
	<variablelist>
	<varlistentry>
	<term
>&lt;author&gt;</term>
	<listitem
><para
>Afegeix informació sobre un autor. Atributs: <variablelist>
		<varlistentry>
		<term
>name, given, family</term>
		<listitem
><para
>Especifiqueu el nom complet per al <parameter
>name</parameter
>, o especifiqueu ambdós <parameter
>given</parameter
> i <parameter
>family</parameter
>, per separat.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>role</term>
		<listitem
><para
>Descripció del rol de l'autor (opcional).</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>email</term>
		<listitem
><para
>L'adreça de correu electrònic on es pot contactar amb l'autor. Requerida. Es pot establir a la llista de correu rkward-devel, si esteu subscrit, i el vostre connector està destinat a ser inclòs en la versió oficial del &rkward;.</para
></listitem>
		</varlistentry>
		<varlistentry>
		<term
>url</term>
		<listitem
><para
>L'&URL; amb més informació sobre l'autor, &pex;, la pàgina web (opcional).</para
></listitem>
		</varlistentry>
		</variablelist>
	</para
></listitem>
	</varlistentry>
	</variablelist>
</listitem>
</varlistentry>
<varlistentry>
<term
>&lt;components&gt;</term>
<listitem
><para
>Necessita estar present exactament una vegada com a fill directe de l'element &lt;document&gt;. Conté els elements individuals &lt;component&gt; descrits a continuació. Sense atributs.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;component&gt;</term>
<listitem
><para
>Un o més elements &lt;component&gt; s'han de donar com a fills directes de l'element &lt;components&gt; (i només allà). Registra un component/plugin amb el «rkward». Atributs: <variablelist>
	<varlistentry>
	<term
>type</term>
	<listitem
><para
>Per a futures extensions: el tipus de component/connector. S'estableix sempre a «standard» per ara (l'únic tipus admès actualment).</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>L'ID pel qual es pot recuperar aquest component (per a col·locar-lo al menú (vegeu a sota), o per a incrustar). Vegeu l'espai de noms &lt;document&gt; a dalt.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>Requerit almenys pels components de type="standard": el nom del fitxer &XML; que descriu la &IGU;.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>L'etiqueta d'aquest component, quan es col·loca a la jerarquia del menú.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;attribute&gt;</term>
<listitem
><para
>Defineix un atribut d'un component. Només té sentit per a <link linkend="context_import"
>connectors d'importació</link
> fins ara. Només es permet com a fill directe de &lt;component&gt;. Atributs: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Id de l'atribut</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>value</term>
	<listitem
><para
>Valor de l'atribut</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>labels</term>
	<listitem
><para
>Etiqueta associada amb l'atribut</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;hierarchy&gt;</term>
<listitem
><para
>Necessita estar present exactament una vegada com a fill directe de l'element &lt;document&gt;. Descriu on s'han de col·locar els components declarats a dalt a la jerarquia del menú. Accepta només elements &lt;menu&gt; com a fills directes. Sense atributs.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;menu&gt;</term>
<listitem
><para
>Un o més elements &lt;menu&gt; s'han de donar com a fills directes de l'element &lt;hierarchy&gt;. Declara un (sub)menú nou. Si ja existeix un menú amb l'ID indicat (vegeu més avall), els dos menús es fusionen. Es permet l'element &lt;menu&gt; com a fill directe de l'element &lt;hierarchy&gt; (menú de nivell superior), o com a fill directe en qualsevol altre element &lt;menu&gt; (menú inferior). Per contra, l'element &lt;menu&gt; accepta altres elements &lt;menu&gt; o &lt;entry&gt; com a elements fills. Atributs: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Una cadena d'identificació del menú. Útil quan les definicions del menú es llegeixen des de diversos fitxers del &pluginmap;, per a assegurar-se que els connectors es poden col·locar en el mateix menú. Alguns identificadors de menú com ara «file» es refereixen a menús predefinits (en aquest cas el menú «File»). Assegureu-vos de comprovar amb els fitxers existents del &pluginmap; per a utilitzar ID coherents.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>label</term>
	<listitem
><para
>Una etiqueta per al menú.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Permet controlar l'ordenació de les entrades del menú. Vegeu <link linkend="pluginmap_grouping"
>ordenació d'elements del menú</link
>. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;entry&gt;</term>
<listitem
><para
>Una entrada de menú, &ead;, una opció de menú per a invocar un connector. Només es pot utilitzar com a fill directe d'un element &lt;menu&gt;, no accepta elements fills. Atributs: <variablelist>
	<varlistentry>
	<term
>component</term>
	<listitem
><para
>L'ID del component que s'ha d'invocar quan s'activa aquesta entrada del menú.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>Permet controlar l'ordenació de les entrades del menú. Vegeu <link linkend="pluginmap_grouping"
>ordenació d'elements del menú</link
>. Opcional.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;group&gt;</term>
<listitem
><para
>Declara un grup d'elements al menú. Vegeu <link linkend="pluginmap_grouping"
>ordenació d'elements del menú</link
>. Atributs: <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>El nom d'aquest grup.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>separated</term>
	<listitem
><para
>Opcional. Si s'estableix a «true» (cert), l'element d'aquest grup se separarà visualment dels elements circumdants.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>group</term>
	<listitem
><para
>El nom del grup al qual afegir aquest grup (opcional).</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;context&gt;</term>
<listitem
><para
>Declara les entrades en un <link linkend="contextualized_plugins"
>context</link
>. Només es permet com a fill directe de l'etiqueta &lt;document&gt;. Només accepta etiquetes &lt;menu&gt; com a filles directes. Atributs: <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>L'ID del context. Fins ara només s'han implementat dos contextos: "x11" i "import".</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;require&gt;</term>
<listitem
><para
>Incloure un altre fitxer &pluginmap;. Aquest fitxer &pluginmap; només es carregarà una vegada, encara que sigui &lt;require&gt; des de diversos fitxers. El cas d'ús més important és incloure un fitxer «pluginmap», el qual declara alguns components que estan incrustats pels components declarats en aquest &pluginmap;. Només es permeten els elements &lt;require&gt; com a fills directes del node &lt;document&gt;. Atributs: <variablelist>
	<varlistentry>
	<term
>file</term>
	<listitem
><para
>El nom del fitxer del &pluginmap; a incloure. Això es veu en relació amb el directori del fitxer &pluginmap; actual + el base_prefix (vegeu més amunt l'element &lt;document&gt;). Si no coneixeu el camí relatiu al &pluginmap; que s'ha d'incloure, utilitzeu l'atribut <parameter
>map</parameter
> per a referir-vos a ell per ID.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>map</term>
	<listitem
><para
>Per a incloure un fitxer &pluginmap; des d'un paquet diferent (o un &pluginmap; del &rkward; des del vostre &pluginmap; extern), podeu referir-vos a ell pel seu <replaceable
>namespacename::id</replaceable
>, com s'especifica en l'element &lt;document&gt; necessari del &pluginmap;. La inclusió fallarà si no es coneix cap &pluginmap; per aquest identificador (&pex;, no està instal·lat en el sistema de l'usuari). Hauríeu d'utilitzar aquest mètode per a incloure els &pluginmap; fora del paquet, només. Per als mapes dins del paquet, especificar un camí relatiu (l'atribut <parameter
>file</parameter
>) és més ràpid i més fiable. </para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="helpfileelements"
><title
>Elements per a utilitzar en fitxers .rkh (ajuda)</title>
<variablelist>
<varlistentry>
<term
>&lt;document&gt;</term>
<listitem
><para
>Necessita estar present a cada fitxer <literal role="extension"
>.xml</literal
> com a node arrel (exactament una vegada). Sense atributs.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;title&gt;</term>
<listitem
><para
>Títol de la pàgina d'ajuda. Això <emphasis
>no</emphasis
> s'interpreta per a pàgines d'ajuda d'un connector (això pren el títol del mateix connector), només per a pàgines independents. Sense atributs. El text que conté l'etiqueta &lt;title&gt; es convertirà en la llegenda de la pàgina d'ajuda. Només es pot definir una vegada, com a fill directe del node &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;summary&gt;</term>
<listitem
><para
>Un breu resum de la pàgina d'ajuda (o per a què s'utilitza aquest connector). Això sempre es mostrarà a la part superior de la pàgina d'ajuda. Sense atributs. Es mostrarà el text contingut dins de l'etiqueta &lt;summary&gt;. Recomanat però no necessari. Només es pot definir una vegada, com a fill directe del node &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;usage&gt;</term>
<listitem
><para
>Un resum una mica més elaborat de l'ús. Això sempre es mostrarà directament després de &lt;summary&gt;. Sense atributs. Es mostrarà el text contingut dins de l'etiqueta &lt;usage&gt;. Recomanat per a les pàgines d'ajuda del connector, però no és necessari. Només es pot definir una vegada, com a fill directe del node &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;section&gt;</term>
<listitem
><para
>Secció de propòsits generals. Es pot utilitzar qualsevol nombre de vegades com a fill directe del node &lt;document&gt;. Aquestes seccions es mostren en l'ordre de la seva definició, però totes les <emphasis
>després</emphasis
> de la secció &lt;usage&gt; i <emphasis
>abans</emphasis
> de la secció &lt;settings&gt;. Es mostrarà el text contingut dins de l'etiqueta &lt;section&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>Un identificador necessari per a saltar a aquesta secció des de la barra de navegació (o un enllaç). Cal que sigui únic dins del fitxer. Requerit, sense valor predeterminat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>El títol (llegenda) d'aquesta secció. Requerit, sense valor predeterminat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>short_title</term>
	<listitem
><para
>Un títol curt adequat per a mostrar a la barra de navegació. Opcional, el valor predeterminat és el títol complet.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;settings&gt;</term>
<listitem
><para
>Defineix la secció que conté la referència sobre les diverses opcions de la &IGU;. Només té sentit i només s'utilitza per a les pàgines d'ajuda relacionades amb els connectors. Utilitzeu-ho com a fill directe del &lt;document&gt;. Pot contenir només elements &lt;setting&gt; i &lt;caption&gt; com a fills directes. Sense atributs.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;setting&gt;</term>
<listitem
><para
>Explica una configuració única a la &IGU;. Només es permet com a fill directe de l'element &lt;settings&gt;. Es mostra el text contingut dins de l'element. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>L'ID del paràmetre en el <literal role="extension"
>.xml</literal
> del connector. Requerit, sense valor predeterminat.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Un títol opcional per a la configuració. Si s'omet (es recomana l'omissió en la majoria dels casos), el títol es prendrà del <literal role="extension"
>.xml</literal
> del connector.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;caption&gt;</term>
<listitem
><para
>Una llegenda per a agrupar visualment diversos paràmetres. Només es pot utilitzar com a fill directe de l'element &lt;settings&gt;. <variablelist>
	<varlistentry>
	<term
>id</term>
	<listitem
><para
>L'ID de l'element corresponent (normalment un &lt;frame&gt;, &lt;page&gt; o &lt;tab&gt;) en el <literal role="extension"
>.xml</literal
> del connector.</para
></listitem>
	</varlistentry>
	<varlistentry>
	<term
>title</term>
	<listitem
><para
>Un títol opcional per a la llegenda. Si s'omet (es recomana l'omissió en la majoria dels casos), el títol es prendrà del <literal role="extension"
>.xml</literal
> del connector.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;related&gt;</term>
<listitem
><para
>Defineix una secció que conté enllaços a altra informació relacionada. Sempre es mostrarà després de la secció &lt;settings&gt;. Sense atributs. Es mostrarà el text contingut dins de l'etiqueta &lt;related&gt;. Normalment, això contindrà una llista d'estil &HTML;. Recomanat per a les pàgines d'ajuda del connector, però no és necessari. Només es pot definir una vegada, com a fill directe del node &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;technical&gt;</term>
<listitem
><para
>Defineix una secció que conté informació tècnica sense rellevància per als usuaris finals (com l'estructura interna del connector). Sempre es mostrarà l'últim en una pàgina d'ajuda. Sense atributs. Es mostrarà el text contingut dins de l'etiqueta &lt;related&gt;. No és necessari i no es recomana per a la majoria de les pàgines d'ajuda del connector. Només es pot definir una vegada, com a fill directe del node &lt;document&gt;.</para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;link&gt;</term>
<listitem
><para
>Un enllaç. Es pot utilitzar en qualsevol de les seccions descrites anteriorment. <variablelist
> <varlistentry>
	<term
>href</term>
	<listitem
><para
>L'&URL; de destinació. Tingueu en compte que hi ha disponibles diversos &URL; específics del &rkward;. Vegeu la <link linkend="pluginhelp"
>secció sobre l'escriptura de les pàgines d'ajuda</link
> per a més detalls.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;label&gt;</term>
<listitem
><para
>Insereix el valor d'una etiqueta d'interfície d'usuari. Es pot utilitzar en qualsevol de les seccions descrites anteriorment. <variablelist
> <varlistentry>
	<term
>id</term>
	<listitem
><para
>L'«id» de l'element en el connector, del qual copiar l'atribut <replaceable
>label</replaceable
>.</para
></listitem>
	</varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry>
<term
>&lt;etiquetes &HTML; diverses&gt;</term>
<listitem
><para
>Les etiquetes &HTML; més bàsiques estan permeses dins de les seccions. No obstant això, manteniu la formatació manual al mínim.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

<sect1 id="guilogic_functions"
><title
>Funcions disponibles per a la creació de scripts de lògica de la &IGU;</title>
<variablelist>
<varlistentry
><term
>Classe «Component»</term>
<listitem
><para
>Classe que representa un únic component o component-propietat. La instància més important d'aquesta classe és la variable "gui" que està predefinida com a propietat arrel del component actual. Hi ha disponibles els mètodes següents per a exemples de la classe «Component»: <variablelist>
	<varlistentry
><term
>absoluteId(base_id)</term
><listitem
><para
>Retorna l'ID absolut de <emphasis
>base_id</emphasis
>, o, si s'omet base_id, l'identificador del component.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getValue(id)</term
><listitem
><para
>Es descoratja. Utilitzeu <function
>getString(), getBoolean() o getList()</function
> en el seu lloc. Retorna el valor de la propietat filla donada. Retorna el valor d'aquesta propietat, si s'omet l'ID.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getString(id)</term
><listitem
><para
>Retorna el valor de la propietat filla donada com a cadena. Retorna el valor d'aquesta propietat, si s'omet l'ID.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getBoolean(id)</term
><listitem
><para
>Retorna el valor de la propietat filla donada com a booleà (si és possible). Retorna el valor d'aquesta propietat, si s'omet l'ID.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getList(id)</term
><listitem
><para
>Retorna el valor de la propietat filla donada com una matriu de cadenes (si és possible). Retorna el valor d'aquesta propietat, si s'omet l'ID.</para
></listitem
></varlistentry>
	<varlistentry
><term
>setValue(id, valor)</term
><listitem
><para
>Estableix el valor de la propietat filla donada a <emphasis
>valor</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>getChild(id)</term
><listitem
><para
>Retorna una instància de la propietat filla amb l'<emphasis
>id</emphasis
> donat.</para
></listitem
></varlistentry>
	<varlistentry
><term
>addChangeCommand(id, ordre)</term
><listitem
><para
>Executa l'<emphasis
>ordre</emphasis
> sempre que canviï la propietat filla donada per <emphasis
>id</emphasis
>.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Classe «RObject»</term>
<listitem
><para
>Classe que representa un únic objecte &R;. Es pot obtenir una instància d'aquesta classe utilitzant <command
>makeRObject(objectname)</command
>. Hi ha disponibles els mètodes següents per a exemples de la classe "RObject": <warning
><para
>Si hi ha ordres pendents al dorsal, la informació proporcionada per aquests mètodes pot estar desactualitzada en el moment en què s'executi el codi del connector. <emphasis
>No</emphasis
> confieu en ell per a operacions crítiques (s'està arriscant la pèrdua de dades).</para
></warning>
	<variablelist>
	<varlistentry
><term
>getName()</term
><listitem
><para
>Retorna el nom absolut de l'objecte.</para
></listitem
></varlistentry>
	<varlistentry
><term
>exists()</term
><listitem
><para
>Retorna si l'objecte existeix. Haureu de comprovar-ho abans d'utilitzar qualsevol dels mètodes llistats a continuació.</para
></listitem
></varlistentry>
	<varlistentry
><term
>dimensions()</term
><listitem
><para
>Retorna una matriu de dimensions (similar a <command
>dim()</command
> en l'R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>classes()</term
><listitem
><para
>Retorna una matriu de classes (similar a <command
>class()</command
> en l'R).</para
></listitem
></varlistentry>
	<varlistentry
><term
>isClass(classe)</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és de classe <emphasis
>class</emphasis
>.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFrame()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un «data.frame».</para
></listitem
></varlistentry>
	<varlistentry
><term
>isMatrix()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és una matriu.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isList()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és una llista.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isFunction()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és una funció.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isEnvironment()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un entorn.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataNumeric()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un vector de dades numèriques.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataFactor()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un vector de dades de factor.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataCharacter()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un vector de dades de caràcters.</para
></listitem
></varlistentry>
	<varlistentry
><term
>isDataLogical()</term
><listitem
><para
>Retorna «true» (cert), si l'objecte és un vector de dades lògiques.</para
></listitem
></varlistentry>
	<varlistentry
><term
>parent()</term
><listitem
><para
>Retorna una instància de «RObject» que representa el pare d'aquest objecte.</para
></listitem
></varlistentry>
	<varlistentry
><term
>child(nomfill)</term
><listitem
><para
>Retorna una instància de «RObject» que representa el <emphasis
>nom del fill</emphasis
> del fill d'aquest objecte.</para
></listitem
></varlistentry>
	</variablelist
></para
></listitem>
</varlistentry>
<varlistentry
><term
>Classe «RObjectArray»</term>
<listitem
><para
>Una matriu d'instàncies RObject. Una instància d'aquesta classe es pot obtenir utilitzant <command
>makeRObjectArray(objectnames)</command
>. És particularment útil quan es tracta de «varslots» que permeten seleccionar diversos objectes.</para
></listitem>
</varlistentry>
<varlistentry
><term
>include()-function</term>
<listitem
><para
><command
>include(filename)</command
> es pot utilitzar per a incloure un fitxer JS separat.</para
></listitem>
</varlistentry>
<varlistentry
><term
>doRCommand()-function</term>
<listitem
><para
><command
>doRCommand(command, callback)</command
> es pot utilitzar per a consultar l'&R; per a obtenir informació. Llegiu la secció sobre <link linkend="querying_r_for_info"
>consultes &R; des de dins d'un connector</link
> per a més detalls i advertències.</para
></listitem>
</varlistentry>
</variablelist>
</sect1>

</appendix>

<appendix id="troubleshooting">
<title
>Resolució de problemes durant el desenvolupament del connector</title>
<para
>Així que heu llegit tota la documentació, ho heu fet tot bé i encara no podeu fer-ho funcionar? No us preocupeu, ho resoldrem. El primer que cal fer és: activar la finestra <guilabel
>Missatges de depuració del &rkward;</guilabel
> (disponible des del menú <guimenu
>Finestres</guimenu
> -, o fer clic dret sobre una de les barres d'eines), i després iniciar el connector, de nou. Com a regla general, no hauríeu de veure cap sortida a la finestra de missatges quan s'invoqui el connector, o en qualsevol altre moment. Si n'hi ha una, probablement està relacionada amb la vostra extensió. Mireu si us ajuda. </para>
<para
>Si tot sembla estar bé a la consola, intenteu augmentar el nivell de depuració (des de la línia d'ordres, utilitzant <command
>rkward --debug-level 3</command
>, o establint el nivell de depuració a 3 en <menuchoice
><guimenu
>Arranjament</guimenu
> <guimenuitem
>Configura el &rkward;</guimenuitem
> <guimenuitem
>Depuració</guimenuitem
></menuchoice
>). No tots els missatges mostrats a nivells de depuració més alts indiquen necessàriament un problema, però hi ha possibilitats que el problema es mostri en algun lloc entre els missatges. </para>
<para
>Si encara no es pot esbrinar què és el que està malament, no espereu. Sabem que això és complicat, i després de tot, possiblement també us heu trobat amb un error en el &rkward;, i el &rkward; necessita ser corregit. Escriviu a la llista de correu de desenvolupament i expliqueu-nos el problema. Estarem encantats d'ajudar-vos. </para>
<para
>Finalment, fins i tot si heu descobert com fer-ho pel vostre compte, però heu trobat que la documentació no és tan útil o fins i tot equivocada en alguns aspectes, digueu-nos-ho també a la llista de correu, perquè puguem arreglar/millorar la documentació. </para>
</appendix>

<appendix id="license">
<title
>Llicència</title>
<para
>Traductor de la documentació: &credits.JosepMa.Ferrer;</para
> 
&underFDL;
</appendix>

&documentation.index;
</book>
<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:
-->
